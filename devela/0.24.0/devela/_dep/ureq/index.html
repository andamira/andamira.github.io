<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="`ureq` Simple, safe HTTP client."><title>devela::_dep::ureq - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-069232aa.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="devela" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-nightly (3672a55b7 2025-08-13)" data-channel="nightly" data-search-js="search-281b7574.js" data-settings-js="settings-5514c975.js" ><script src="../../../static.files/storage-68b7e25d.js"></script><script defer src="../../../crates.js"></script><script defer src="../../../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"><script>
  document.addEventListener("DOMContentLoaded", async function() {
    // Ensure this script runs only once per page load
    if (window.scriptLoaderInitialized) return;
    window.scriptLoaderInitialized = true;

    /* settings */

    const crateName = "devela";
    const allowedKatex = ["/all", "/media/color", "/num/", "/phys/"];
    const allowedKatexChem = ["/all/", "/phys/"];

    // Find the LAST occurrence of `/devela/` in the path
    const path = window.location.pathname;
    const lastCrateIndex = path.lastIndexOf(`/${crateName}/`);
    if (lastCrateIndex === -1) return;
    // Extract everything after the last `/devela/`
    const relativePath = path.slice(lastCrateIndex + crateName.length + 1);

    /* load resources */

    try {
      if (allowedKatex.some(prefix => relativePath.startsWith(prefix))) {
        await loadKatex().catch(handleMathError);
      }
      if (allowedKatexChem.some(prefix => relativePath.startsWith(prefix))) {
        await loadKatexChem().catch(handleMathError);
      }
    } catch (error) {
      handleMathError(error);
    }

    /* resource loading functions */

    // INFO: https://katex.org/docs/browser.html#starter-template
    // INFO: https://github.com/KaTeX/KaTeX/tree/main/contrib/copy-tex
    async function loadKatex() {
      console.log("Loading KaTeX for:", relativePath);

      // Load CSS, and scripts sequentially
      const katexCSS = document.createElement("link");
      katexCSS.rel = "stylesheet";
      katexCSS.href = "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css";
      katexCSS.integrity = "sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib";
      katexCSS.crossOrigin = "anonymous";
      document.head.appendChild(katexCSS);

      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js",
        integrity: "sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh"
      });
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js",
        integrity: "sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh"
      });
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/copy-tex.min.js",
        integrity: "sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi"
      });

      // Initialize KaTeX
      renderMathInElement(document.body, {
        delimiters: [
          {left: "$$", right: "$$", display: true},
          {left: "$", right: "$", display: false},
          {left: "\\(", right: "\\)", display: false},
          {left: "\\[", right: "\\]", display: true}
        ],
        trust: (context) => context.command === "\\href"
      });
      // Add custom styles: https://katex.org/docs/issues.html#css-customization
      const katexStyle = document.createElement("style");
      katexStyle.textContent = `
        .katex-display { overflow: hidden; }
        .docblock p { overflow-y: hidden; }
      `;
      document.head.appendChild(katexStyle);
    }

    // INFO: https://github.com/KaTeX/KaTeX/blob/main/contrib/mhchem/README.md
    async function loadKatexChem() {
      console.log("Loading KaTeX MhChem plugin for:", relativePath);
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/mhchem.min.js",
        integrity: "sha384-F2ptQFZqNJuqfGGl28mIXyQ5kXH48spn7rcoS0Y9psqIKAcZPLd1NzwFlm/bl1mH"
      });
    }

    /* helper functions */

    function loadScript(config) {
      return new Promise((resolve, reject) => {
        const script = document.createElement("script");
        script.src = config.src;
        if (config.integrity) {
          script.integrity = config.integrity;
          script.crossOrigin = "anonymous";
        }
        script.onload = resolve;
        script.onerror = () => reject(new Error(`Failed to load script: ${config.src}`));
        document.head.appendChild(script);
      });
    }
    function handleMathError(error) {
      console.error("Math rendering error:", error);
    }
  });
</script>

</head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../devela/index.html">devela</a><span class="version">0.25.0-wip</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#usage" title="Usage">Usage</a><ul><li><a href="#json" title="JSON">JSON</a></li><li><a href="#error-handling" title="Error handling">Error handling</a></li></ul></li><li><a href="#features" title="Features">Features</a><ul><li><a href="#unstable" title="Unstable">Unstable</a></li></ul></li><li><a href="#tls-https" title="TLS (https)">TLS (https)</a><ul><li><a href="#rustls" title="rustls">rustls</a></li><li><a href="#native-tls" title="native-tls">native-tls</a></li><li><a href="#root-certificates" title="Root certificates">Root certificates</a></li></ul></li><li><a href="#json-1" title="JSON">JSON</a></li><li><a href="#sending-body-data" title="Sending body data">Sending body data</a><ul><li><a href="#content-length" title="Content-Length">Content-Length</a></li><li><a href="#transfer-encoding-chunked" title="Transfer-Encoding: chunked">Transfer-Encoding: chunked</a></li><li><a href="#proxying-a-response-body" title="Proxying a response body">Proxying a response body</a></li><li><a href="#sending-form-data" title="Sending form data">Sending form data</a></li><li><a href="#overriding" title="Overriding">Overriding</a></li></ul></li><li><a href="#character-encoding" title="Character encoding">Character encoding</a><ul><li><a href="#lossy-utf-8" title="Lossy utf-8">Lossy utf-8</a></li></ul></li><li><a href="#proxying" title="Proxying">Proxying</a><ul><li><a href="#example-using-http" title="Example using HTTP">Example using HTTP</a></li><li><a href="#example-using-socks5" title="Example using SOCKS5">Example using SOCKS5</a></li></ul></li><li><a href="#log-levels" title="Log levels">Log levels</a></li><li><a href="#versioning" title="Versioning">Versioning</a><ul><li><a href="#semver-and-unversioned" title="Semver and `unversioned`">Semver and <code>unversioned</code></a></li><li><a href="#breaking-changes-in-dependencies" title="Breaking changes in dependencies">Breaking changes in dependencies</a></li><li><a href="#minimum-supported-rust-version-msrv" title="Minimum Supported Rust Version (MSRV)">Minimum Supported Rust Version (MSRV)</a></li></ul></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In devela::<wbr>_<wbr>dep</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">devela</a>::<wbr><a href="../index.html">_dep</a></div><h1>Crate <span>ureq</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"></span></div><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>dep_ureq</code></strong> only.</div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><span class='stab portability' title='re-exported `ureq`'><code>ureq</code></span>
Simple, safe HTTP client.</p>
<hr />
<div align="center">
  <!-- Version -->
  <a href="https://crates.io/crates/ureq">
    <img src="https://img.shields.io/crates/v/ureq.svg?style=flat-square"
    alt="Crates.io version" />
  </a>
  <!-- Docs -->
  <a href="https://docs.rs/ureq">
    <img src="https://img.shields.io/badge/docs-latest-blue.svg?style=flat-square"
      alt="docs.rs docs" />
  </a>
  <!-- Downloads -->
  <a href="https://crates.io/crates/ureq">
    <img src="https://img.shields.io/crates/d/ureq.svg?style=flat-square"
      alt="Crates.io downloads" />
  </a>
</div>
<p>A simple, safe HTTP client.</p>
<p>Ureq’s first priority is being easy for you to use. It’s great for
anyone who wants a low-overhead HTTP client that just gets the job done. Works
very well with HTTP APIs. Its features include cookies, JSON, HTTP proxies,
HTTPS, charset decoding, and is based on the API of the <code>http</code> crate.</p>
<p>Ureq is in pure Rust for safety and ease of understanding. It avoids using
<code>unsafe</code> directly. It uses blocking I/O instead of async I/O, because that keeps
the API simple and keeps dependencies to a minimum. For TLS, ureq uses
rustls or native-tls.</p>
<p>See the <a href="https://github.com/algesten/ureq/blob/main/CHANGELOG.md">changelog</a> for details of recent releases.</p>
<h2 id="usage"><a class="doc-anchor" href="#usage">§</a>Usage</h2>
<p>In its simplest form, ureq looks like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>body: String = ureq::get(<span class="string">"http://example.com"</span>)
    .header(<span class="string">"Example-Header"</span>, <span class="string">"header value"</span>)
    .call()<span class="question-mark">?
    </span>.body_mut()
    .read_to_string()<span class="question-mark">?</span>;</code></pre></div>
<p>For more involved tasks, you’ll want to create an <a href="https://docs.rs/ureq/3.0.0-rc4/ureq/struct.Agent.html"><code>Agent</code></a>. An Agent
holds a connection pool for reuse, and a cookie store if you use the
<strong>cookies</strong> feature. An Agent can be cheaply cloned due to internal
<a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code>Arc</code></a> and all clones of an Agent share state among each other. Creating
an Agent also allows setting options like the TLS configuration.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ureq::Agent;
<span class="kw">use </span>std::time::Duration;

<span class="kw">let </span><span class="kw-2">mut </span>config = Agent::config_builder()
    .timeout_global(<span class="prelude-val">Some</span>(Duration::from_secs(<span class="number">5</span>)))
    .build();

<span class="kw">let </span>agent: Agent = config.into();

<span class="kw">let </span>body: String = agent.get(<span class="string">"http://example.com/page"</span>)
    .call()<span class="question-mark">?
    </span>.body_mut()
    .read_to_string()<span class="question-mark">?</span>;

<span class="comment">// Reuses the connection from previous request.
</span><span class="kw">let </span>response: String = agent.put(<span class="string">"http://example.com/upload"</span>)
    .header(<span class="string">"Authorization"</span>, <span class="string">"example-token"</span>)
    .send(<span class="string">"some body data"</span>)<span class="question-mark">?
    </span>.body_mut()
    .read_to_string()<span class="question-mark">?</span>;</code></pre></div>
<h3 id="json"><a class="doc-anchor" href="#json">§</a>JSON</h3>
<p>Ureq supports sending and receiving json, if you enable the <strong>json</strong> feature:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>serde::{Serialize, Deserialize};

<span class="attr">#[derive(Serialize)]
</span><span class="kw">struct </span>MySendBody {
   thing: String,
}

<span class="attr">#[derive(Deserialize)]
</span><span class="kw">struct </span>MyRecvBody {
   other: String,
}

<span class="kw">let </span>send_body = MySendBody { thing: <span class="string">"yo"</span>.to_string() };

<span class="comment">// Requires the `json` feature enabled.
</span><span class="kw">let </span>recv_body = ureq::post(<span class="string">"http://example.com/post/ingest"</span>)
    .header(<span class="string">"X-My-Header"</span>, <span class="string">"Secret"</span>)
    .send_json(<span class="kw-2">&amp;</span>send_body)<span class="question-mark">?
    </span>.body_mut()
    .read_json::&lt;MyRecvBody&gt;()<span class="question-mark">?</span>;</code></pre></div>
<h3 id="error-handling"><a class="doc-anchor" href="#error-handling">§</a>Error handling</h3>
<p>ureq returns errors via <code>Result&lt;T, ureq::Error&gt;</code>. That includes I/O errors,
protocol errors. By default, also HTTP status code errors (when the
server responded 4xx or 5xx) results in <a href="https://docs.rs/ureq/3.0.0-rc4/ureq/enum.Error.html"><code>Error</code></a>.</p>
<p>This behavior can be turned off via <a href="https://docs.rs/ureq/3.0.0-rc4/ureq/config/struct.ConfigBuilder.html#method.http_status_as_error"><code>http_status_as_error()</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ureq::Error;

<span class="kw">match </span>ureq::get(<span class="string">"http://mypage.example.com/"</span>).call() {
    <span class="prelude-val">Ok</span>(response) =&gt; { <span class="comment">/* it worked */</span>},
    <span class="prelude-val">Err</span>(Error::StatusCode(code)) =&gt; {
        <span class="comment">/* the server returned an unexpected status
           code (such as 400, 500 etc) */
    </span>}
    <span class="prelude-val">Err</span>(<span class="kw">_</span>) =&gt; { <span class="comment">/* some kind of io/transport/etc error */ </span>}
}</code></pre></div>
<h2 id="features"><a class="doc-anchor" href="#features">§</a>Features</h2>
<p>To enable a minimal dependency tree, some features are off by default.
You can control them when including ureq as a dependency.</p>
<p><code>ureq = { version = "3", features = ["socks-proxy", "charset"] }</code></p>
<p>The default enabled features are: <strong>rustls</strong> and <strong>gzip</strong>.</p>
<ul>
<li><strong>rustls</strong> enables the rustls TLS implementation. This is the default for the the crate level
convenience calls (<code>ureq::get</code> etc). It currently uses <code>ring</code> as the TLS provider.</li>
<li><strong>native-tls</strong> enables the native tls backend for TLS. Due to the risk of diamond dependencies
accidentally switching on an unwanted TLS implementation, <code>native-tls</code> is never picked up as
a default or used by the crate level convenience calls (<code>ureq::get</code> etc) – it must be configured
on the agent</li>
<li><strong>platform-verifier</strong> enables verifying the server certificates using a method native to the
platform ureq is executing on. See <a href="https://crates.io/crates/rustls-platform-verifier">rustls-platform-verifier</a> crate</li>
<li><strong>socks-proxy</strong> enables proxy config using the <code>socks4://</code>, <code>socks4a://</code>, <code>socks5://</code>
and <code>socks://</code> (equal to <code>socks5://</code>) prefix</li>
<li><strong>cookies</strong> enables cookies</li>
<li><strong>gzip</strong> enables requests of gzip-compressed responses and decompresses them</li>
<li><strong>brotli</strong> enables requests brotli-compressed responses and decompresses them</li>
<li><strong>charset</strong> enables interpreting the charset part of the Content-Type header
(e.g.  <code>Content-Type: text/plain; charset=iso-8859-1</code>). Without this, the
library defaults to Rust’s built in <code>utf-8</code></li>
<li><strong>json</strong> enables JSON sending and receiving via serde_json</li>
</ul>
<h4 id="unstable"><a class="doc-anchor" href="#unstable">§</a>Unstable</h4>
<p>These features are unstable and might change in a minor version.</p>
<ul>
<li>
<p><strong>rustls-no-provider</strong> Enables rustls, but does not enable any <a href="https://docs.rs/rustls/latest/rustls/crypto/struct.CryptoProvider.html"><code>CryptoProvider</code></a> such as <code>ring</code>.
Providers other than the default (currently <code>ring</code>) are never picked up from feature flags alone.
It must be configured on the agent.</p>
</li>
<li>
<p><strong>vendored</strong> compiles and statically links to a copy of non-Rust vendors (e.g. OpenSSL from <code>native-tls</code>)</p>
</li>
</ul>
<h2 id="tls-https"><a class="doc-anchor" href="#tls-https">§</a>TLS (https)</h2><h3 id="rustls"><a class="doc-anchor" href="#rustls">§</a>rustls</h3>
<p>By default, ureq uses <a href="https://crates.io/crates/rustls"><code>rustls</code> crate</a> with the <code>ring</code> cryptographic provider.
As of Sep 2024, the <code>ring</code> provider has a higher chance of compiling successfully. If the user
installs another process <a href="https://docs.rs/rustls/latest/rustls/crypto/struct.CryptoProvider.html#method.install_default">default provider</a>, that choice is respected.</p>
<p>ureq does not guarantee to default to ring indefinitely. <code>rustls</code> as a feature flag will always
work, but the specific crypto backend might change in a minor version.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// This uses rustls
</span>ureq::get(<span class="string">"https://www.google.com/"</span>).call().unwrap();</code></pre></div>
<h4 id="rustls-without-ring"><a class="doc-anchor" href="#rustls-without-ring">§</a>rustls without ring</h4>
<p>ureq never changes TLS backend from feature flags alone. It is possible to compile ureq
without ring, but it requires specific feature flags and configuring the <a href="https://docs.rs/ureq/3.0.0-rc4/ureq/struct.Agent.html"><code>Agent</code></a>.</p>
<p>Since rustls is not semver 1.x, this requires non-semver-guaranteed API. I.e. ureq might
change this behavior without a major version bump.</p>
<p>Read more at [<code>TlsConfigBuilder::unversioned_rustls_crypto_provider</code>][crate::tls::TlsConfigBuilder::unversioned_rustls_crypto_provider].</p>
<h3 id="native-tls"><a class="doc-anchor" href="#native-tls">§</a>native-tls</h3>
<p>As an alternative, ureq ships with <a href="https://crates.io/crates/native-tls"><code>native-tls</code></a> as a TLS provider. This must be
enabled using the <strong>native-tls</strong> feature. Due to the risk of diamond dependencies
accidentally switching on an unwanted TLS implementation, <code>native-tls</code> is never picked
up as a default or used by the crate level convenience calls (<code>ureq::get</code> etc) – it
must be configured on the agent.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ureq::config::Config;
<span class="kw">use </span>ureq::tls::{TlsConfig, TlsProvider};

<span class="kw">let </span><span class="kw-2">mut </span>config = Config::builder()
    .tls_config(
        TlsConfig::builder()
            <span class="comment">// requires the native-tls feature
            </span>.provider(TlsProvider::NativeTls)
            .build()
    )
    .build();

<span class="kw">let </span>agent = config.new_agent();

agent.get(<span class="string">"https://www.google.com/"</span>).call().unwrap();</code></pre></div>
<h3 id="root-certificates"><a class="doc-anchor" href="#root-certificates">§</a>Root certificates</h3><h4 id="webpki-roots"><a class="doc-anchor" href="#webpki-roots">§</a>webpki-roots</h4>
<p>By default, ureq uses Mozilla’s root certificates via the <a href="https://crates.io/crates/webpki-roots">webpki-roots</a> crate. This is a static
bundle of root certificates that do not update automatically. It also circumvents whatever root
certificates are installed on the host running ureq, which might be a good or a bad thing depending
on your perspective. There is also no mechanism for <a href="https://en.wikipedia.org/wiki/Certificate_Transparency">SCT</a>, <a href="https://en.wikipedia.org/wiki/Certificate_revocation_list">CRL</a>s or other revocations.
To maintain a “fresh” list of root certs, you need to bump the ureq dependency from time to time.</p>
<p>The main reason for chosing this as the default is to minimize the number of dependencies. More
details about this decision can be found at [PR 818].</p>
<p>If your use case for ureq is talking to a limited number of servers with high trust, the
default setting is likely sufficient. If you use ureq with a high number of servers, or servers
you don’t trust, we recommend using the platform verifier (see below).</p>
<h4 id="platform-verifier"><a class="doc-anchor" href="#platform-verifier">§</a>platform-verifier</h4>
<p>The <a href="https://crates.io/crates/rustls-platform-verifier">rustls-platform-verifier</a> crate provides access to natively checking the certificate via your OS.
To use this verifier, you need to enable it using feature flag <strong>platform-verifier</strong> as well as
configure an agent to use it.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ureq::Agent;
<span class="kw">use </span>ureq::tls::{TlsConfig, RootCerts};

<span class="kw">let </span>agent = Agent::config_builder()
    .tls_config(
        TlsConfig::builder()
            .root_certs(RootCerts::PlatformVerifier)
            .build()
    )
    .build()
    .new_agent();

<span class="kw">let </span>response = agent.get(<span class="string">"https://httpbin.org/get"</span>).call()<span class="question-mark">?</span>;</code></pre></div>
<p>Setting <code>RootCerts::PlatformVerifier</code> together with <code>TlsProvider::NativeTls</code> means
also native-tls will use the OS roots instead of <a href="https://crates.io/crates/webpki-roots">webpki-roots</a> crate. Whether that
results in a config that has CRLs and revocations is up to whatever native-tls links to.</p>
<h2 id="json-1"><a class="doc-anchor" href="#json-1">§</a>JSON</h2>
<p>By enabling the <strong>json</strong> feature, the library supports serde json.</p>
<p>This is enabled by default.</p>
<ul>
<li><a href="https://docs.rs/ureq/3.0.0-rc4/ureq/struct.RequestBuilder.html#method.send_json"><code>request.send_json()</code></a> send body as json.</li>
<li><a href="https://docs.rs/ureq/3.0.0-rc4/ureq/struct.Body.html#method.read_json"><code>body.read_json()</code></a> transform response to json.</li>
</ul>
<h2 id="sending-body-data"><a class="doc-anchor" href="#sending-body-data">§</a>Sending body data</h2>
<p>HTTP/1.1 has two ways of transfering body data. Either of a known size with
the <code>Content-Length</code> HTTP header, or unknown size with the
<code>Transfer-Encoding: chunked</code> header. ureq supports both and will use the
appropriate method depending on which body is being sent.</p>
<p>ureq has a <a href="https://docs.rs/ureq/3.0.0-rc4/ureq/trait.AsSendBody.html"><code>AsSendBody</code></a> trait that is implemented for many well known types
of data that we might want to send. The request body can thus be anything
from a <code>String</code> to a <code>File</code>, see below.</p>
<h3 id="content-length"><a class="doc-anchor" href="#content-length">§</a>Content-Length</h3>
<p>The library will send a <code>Content-Length</code> header on requests with bodies of
known size, in other words, if the body to send is one of:</p>
<ul>
<li><code>&amp;[u8]</code></li>
<li><code>&amp;[u8; N]</code></li>
<li><code>&amp;str</code></li>
<li><code>String</code></li>
<li><code>&amp;String</code></li>
<li><code>Vec&lt;u8&gt;</code></li>
<li><code>&amp;Vec&lt;u8&gt;)</code></li>
<li><a href="https://docs.rs/ureq/3.0.0-rc4/ureq/struct.SendBody.html#method.from_json"><code>SendBody::from_json()</code></a> (implicitly via <a href="https://docs.rs/ureq/3.0.0-rc4/ureq/struct.RequestBuilder.html#method.send_json"><code>request.send_json()</code></a>)</li>
</ul>
<h3 id="transfer-encoding-chunked"><a class="doc-anchor" href="#transfer-encoding-chunked">§</a>Transfer-Encoding: chunked</h3>
<p>ureq will send a <code>Transfer-Encoding: chunked</code> header on requests where the body
is of unknown size. The body is automatically converted to an <a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>std::io::Read</code></a>
when the type is one of:</p>
<ul>
<li><code>File</code></li>
<li><code>&amp;File</code></li>
<li><code>TcpStream</code></li>
<li><code>&amp;TcpStream</code></li>
<li><code>Stdin</code></li>
<li><code>UnixStream</code> (not on windows)</li>
</ul>
<h4 id="from-readers"><a class="doc-anchor" href="#from-readers">§</a>From readers</h4>
<p>The chunked method also applies for bodies constructed via:</p>
<ul>
<li><a href="https://docs.rs/ureq/3.0.0-rc4/ureq/struct.SendBody.html#method.from_reader"><code>SendBody::from_reader()</code></a></li>
<li><a href="https://docs.rs/ureq/3.0.0-rc4/ureq/struct.SendBody.html#method.from_owned_reader"><code>SendBody::from_owned_reader()</code></a></li>
</ul>
<h3 id="proxying-a-response-body"><a class="doc-anchor" href="#proxying-a-response-body">§</a>Proxying a response body</h3>
<p>As a special case, when ureq sends a <a href="https://docs.rs/ureq/3.0.0-rc4/ureq/struct.Body.html"><code>Body</code></a> from a previous http call, the
use of <code>Content-Length</code> or <code>chunked</code> depends on situation. For input such as
gzip decoding (<strong>gzip</strong> feature) or charset transformation (<strong>charset</strong> feature),
the output body might not match the input, which means ureq is forced to use
the <code>chunked</code> method.</p>
<ul>
<li><code>Response&lt;Body&gt;</code></li>
</ul>
<h3 id="sending-form-data"><a class="doc-anchor" href="#sending-form-data">§</a>Sending form data</h3>
<p><a href="https://docs.rs/ureq/3.0.0-rc4/ureq/struct.RequestBuilder.html#method.send_form"><code>request.send_form()</code></a> provides a way to send <code>application/x-www-form-urlencoded</code>
encoded data. The key/values provided will be URL encoded.</p>
<h3 id="overriding"><a class="doc-anchor" href="#overriding">§</a>Overriding</h3>
<p>If you set your own Content-Length or Transfer-Encoding header before
sending the body, ureq will respect that header by not overriding it,
and by encoding the body or not, as indicated by the headers you set.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>resp = ureq::put(<span class="string">"https://httpbin.org/put"</span>)
    .header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>)
    .send(<span class="string">"Hello world"</span>)<span class="question-mark">?</span>;</code></pre></div>
<h2 id="character-encoding"><a class="doc-anchor" href="#character-encoding">§</a>Character encoding</h2>
<p>By enabling the <strong>charset</strong> feature, the library supports receiving other
character sets than <code>utf-8</code>.</p>
<p>For <a href="https://docs.rs/ureq/3.0.0-rc4/ureq/struct.Body.html#method.read_to_string"><code>Body::read_to_string()</code></a> we read the header like:</p>
<p><code>Content-Type: text/plain; charset=iso-8859-1</code></p>
<p>and if it contains a charset specification, we try to decode the body using that
encoding. In the absence of, or failing to interpret the charset, we fall back on <code>utf-8</code>.</p>
<p>Currently ureq does not provide a way to encode when sending request bodies.</p>
<h3 id="lossy-utf-8"><a class="doc-anchor" href="#lossy-utf-8">§</a>Lossy utf-8</h3>
<p>When reading text bodies (with a <code>Content-Type</code> starting <code>text/</code> as in <code>text/plain</code>,
<code>text/html</code>, etc), ureq can ensure the body is possible to read as a <code>String</code> also if
it contains characters that are not valid for utf-8. Invalid characters are replaced
with a question mark <code>?</code> (NOT the utf-8 replacement character).</p>
<p>For <a href="https://docs.rs/ureq/3.0.0-rc4/ureq/struct.Body.html#method.read_to_string"><code>Body::read_to_string()</code></a> this is turned on by default, but it can be disabled
and conversely for <a href="https://docs.rs/ureq/3.0.0-rc4/ureq/struct.Body.html#method.as_reader"><code>Body::as_reader()</code></a> it is not enabled, but can be.</p>
<p>To precisely configure the behavior use <a href="https://docs.rs/ureq/3.0.0-rc4/ureq/struct.Body.html#method.with_config"><code>Body::with_config()</code></a>.</p>
<h2 id="proxying"><a class="doc-anchor" href="#proxying">§</a>Proxying</h2>
<p>ureq supports two kinds of proxies,  <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Proxy_servers_and_tunneling#http_tunneling"><code>HTTP</code></a> (<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT"><code>CONNECT</code></a>), <a href="https://en.wikipedia.org/wiki/SOCKS#SOCKS4"><code>SOCKS4</code></a>/<a href="https://en.wikipedia.org/wiki/SOCKS#SOCKS5"><code>SOCKS5</code></a>,
the former is always available while the latter must be enabled using the feature
<strong>socks-proxy</strong>.</p>
<p>Proxies settings are configured on an <a href="https://docs.rs/ureq/3.0.0-rc4/ureq/struct.Agent.html"><code>Agent</code></a>. All request sent through the agent will be proxied.</p>
<h3 id="example-using-http"><a class="doc-anchor" href="#example-using-http">§</a>Example using HTTP</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ureq::{Agent, Proxy};
<span class="comment">// Configure an http connect proxy.
</span><span class="kw">let </span>proxy = Proxy::new(<span class="string">"http://user:password@cool.proxy:9090"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>agent: Agent = Agent::config_builder()
    .proxy(<span class="prelude-val">Some</span>(proxy))
    .build()
    .into();

<span class="comment">// This is proxied.
</span><span class="kw">let </span>resp = agent.get(<span class="string">"http://cool.server"</span>).call()<span class="question-mark">?</span>;</code></pre></div>
<h3 id="example-using-socks5"><a class="doc-anchor" href="#example-using-socks5">§</a>Example using SOCKS5</h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ureq::{Agent, Proxy};
<span class="comment">// Configure a SOCKS proxy.
</span><span class="kw">let </span>proxy = Proxy::new(<span class="string">"socks5://user:password@cool.proxy:9090"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>agent: Agent = Agent::config_builder()
    .proxy(<span class="prelude-val">Some</span>(proxy))
    .build()
    .into();

<span class="comment">// This is proxied.
</span><span class="kw">let </span>resp = agent.get(<span class="string">"http://cool.server"</span>).call()<span class="question-mark">?</span>;</code></pre></div>
<h2 id="log-levels"><a class="doc-anchor" href="#log-levels">§</a>Log levels</h2>
<p>ureq uses the log crate. These are the definitions of the log levels, however we
do not guarantee anything for dependencies such as <code>http</code> and <code>rustls</code>.</p>
<ul>
<li><code>ERROR</code> - nothing</li>
<li><code>WARN</code> - if we detect a user configuration problem.</li>
<li><code>INFO</code> - nothing</li>
<li><code>DEBUG</code> - uri, state changes, transport, resolver and selected request/response headers</li>
<li><code>TRACE</code> - wire level debug. NOT REDACTED!</li>
</ul>
<p>The request/response headers on DEBUG levels are allow-listed to only include headers that
are considered safe. The code has the <a href="https://github.com/algesten/ureq/blob/81127cfc38516903330dc1b9c618122372f8dc29/src/util.rs#L184-L198">allow list</a>.</p>
<h2 id="versioning"><a class="doc-anchor" href="#versioning">§</a>Versioning</h2><h3 id="semver-and-unversioned"><a class="doc-anchor" href="#semver-and-unversioned">§</a>Semver and <code>unversioned</code></h3>
<p>ureq follows semver. From ureq 3.x we strive to have a much closer adherence to semver than 2.x.
The main mistake in 2.x was to re-export crates that were not yet semver 1.0. In ureq 3.x TLS and
cookie configuration is shimmed using our own types.</p>
<p>ureq 3.x is trying out two new traits that had no equivalent in 2.x, <a href="https://docs.rs/ureq/3.0.0-rc4/ureq/unversioned/transport/trait.Transport.html"><code>Transport</code></a> and <a href="https://docs.rs/ureq/3.0.0-rc4/ureq/unversioned/resolver/trait.Resolver.html"><code>Resolver</code></a>.
These allow the user write their own bespoke transports and (DNS name) resolver. The API:s for
these parts are not yet solidified. They live under the <a href="https://docs.rs/ureq/3.0.0-rc4/ureq/unversioned/index.html"><code>unversioned</code></a> module, and do not
follow semver. See module doc for more info.</p>
<h3 id="breaking-changes-in-dependencies"><a class="doc-anchor" href="#breaking-changes-in-dependencies">§</a>Breaking changes in dependencies</h3>
<p>ureq relies on non-semver 1.x crates such as <code>rustls</code> and <code>native-tls</code>. Some scenarios, such
as configuring <code>rustls</code> to not use <code>ring</code>, a user of ureq might need to interact with these
crates directly instead of going via ureq’s provided API.</p>
<p>Such changes can break when ureq updates dependencies. This is not considered a breaking change
for ureq and will not be reflected by a major version bump.</p>
<p>We strive to mark ureq’s API with the word “unversioned” to identify places where this risk arises.</p>
<h3 id="minimum-supported-rust-version-msrv"><a class="doc-anchor" href="#minimum-supported-rust-version-msrv">§</a>Minimum Supported Rust Version (MSRV)</h3>
<p>From time to time we will need to update our minimum supported Rust version (MSRV). This is not
something we do lightly; our ambition is to be as conservative with MSRV as possible.</p>
<ul>
<li>For some dependencies, we will opt for pinning the version of the dep instead
of bumping our MSRV.</li>
<li>For important dependencies, like the TLS libraries, we cannot hold back our MSRV if they change.</li>
<li>We do not consider MSRV changes to be breaking for the purposes of semver.</li>
<li>We will not make MSRV changes in patch releases.</li>
<li>MSRV changes will get their own minor release, and not be co-mingled with other changes.</li>
</ul>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="config/index.html" title="mod devela::_dep::ureq::config">config</a></dt><dd>Agent configuration</dd><dt><a class="mod" href="http/index.html" title="mod devela::_dep::ureq::http">http</a></dt><dd>A general purpose library of common HTTP types</dd><dt><a class="mod" href="middleware/index.html" title="mod devela::_dep::ureq::middleware">middleware</a></dt><dd>Chained interception to modify the request or response.</dd><dt><a class="mod" href="typestate/index.html" title="mod devela::_dep::ureq::typestate">typestate</a></dt><dd>Typestate variables.</dd><dt><a class="mod" href="unversioned/index.html" title="mod devela::_dep::ureq::unversioned">unversioned</a></dt><dd>API that does not (yet) follow semver.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Agent.html" title="struct devela::_dep::ureq::Agent">Agent</a></dt><dd>Agents keep state between requests.</dd><dt><a class="struct" href="struct.Body.html" title="struct devela::_dep::ureq::Body">Body</a></dt><dd>A response body returned as <a href="http/struct.Response.html" title="struct devela::_dep::ureq::http::Response"><code>http::Response&lt;Body&gt;</code></a>.</dd><dt><a class="struct" href="struct.BodyBuilder.html" title="struct devela::_dep::ureq::BodyBuilder">Body<wbr>Builder</a></dt><dd>Builder for creating a response body.</dd><dt><a class="struct" href="struct.BodyReader.html" title="struct devela::_dep::ureq::BodyReader">Body<wbr>Reader</a></dt><dd>A reader of the response data.</dd><dt><a class="struct" href="struct.BodyWithConfig.html" title="struct devela::_dep::ureq::BodyWithConfig">Body<wbr>With<wbr>Config</a></dt><dd>Configuration of how to read the body.</dd><dt><a class="struct" href="struct.Proxy.html" title="struct devela::_dep::ureq::Proxy">Proxy</a></dt><dd>Proxy server settings</dd><dt><a class="struct" href="struct.ProxyBuilder.html" title="struct devela::_dep::ureq::ProxyBuilder">Proxy<wbr>Builder</a></dt><dd>Builder for configuring a proxy.</dd><dt><a class="struct" href="struct.RequestBuilder.html" title="struct devela::_dep::ureq::RequestBuilder">Request<wbr>Builder</a></dt><dd>Transparent wrapper around <a href="http/request/struct.Builder.html" title="struct devela::_dep::ureq::http::request::Builder"><code>http::request::Builder</code></a>.</dd><dt><a class="struct" href="struct.SendBody.html" title="struct devela::_dep::ureq::SendBody">Send<wbr>Body</a></dt><dd>Request body for sending data via POST, PUT and PATCH.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.Error.html" title="enum devela::_dep::ureq::Error">Error</a></dt><dd>Errors from ureq.</dd><dt><a class="enum" href="enum.ProxyProtocol.html" title="enum devela::_dep::ureq::ProxyProtocol">Proxy<wbr>Protocol</a></dt><dd>Proxy protocol</dd><dt><a class="enum" href="enum.Timeout.html" title="enum devela::_dep::ureq::Timeout">Timeout</a></dt><dd>The various timeouts.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.AsSendBody.html" title="trait devela::_dep::ureq::AsSendBody">AsSend<wbr>Body</a></dt><dd>Trait for common types to send in POST, PUT or PATCH.</dd><dt><a class="trait" href="trait.RequestExt.html" title="trait devela::_dep::ureq::RequestExt">Request<wbr>Ext</a></dt><dd>Extension trait for <a href="http/struct.Request.html" title="struct devela::_dep::ureq::http::Request"><code>http::Request&lt;impl AsSendBody&gt;</code></a>.</dd><dt><a class="trait" href="trait.ResponseExt.html" title="trait devela::_dep::ureq::ResponseExt">Response<wbr>Ext</a></dt><dd>Extension trait for <a href="http/struct.Response.html" title="struct devela::_dep::ureq::http::Response"><code>http::Response&lt;Body&gt;</code></a>.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.agent.html" title="fn devela::_dep::ureq::agent">agent</a></dt><dd>A new <a href="struct.Agent.html" title="struct devela::_dep::ureq::Agent">Agent</a> with default configuration</dd><dt><a class="fn" href="fn.connect.html" title="fn devela::_dep::ureq::connect">connect</a></dt><dd>Make a CONNECT request.</dd><dt><a class="fn" href="fn.delete.html" title="fn devela::_dep::ureq::delete">delete</a></dt><dd>Make a DELETE request.</dd><dt><a class="fn" href="fn.get.html" title="fn devela::_dep::ureq::get">get</a></dt><dd>Make a GET request.</dd><dt><a class="fn" href="fn.head.html" title="fn devela::_dep::ureq::head">head</a></dt><dd>Make a HEAD request.</dd><dt><a class="fn" href="fn.options.html" title="fn devela::_dep::ureq::options">options</a></dt><dd>Make an OPTIONS request.</dd><dt><a class="fn" href="fn.patch.html" title="fn devela::_dep::ureq::patch">patch</a></dt><dd>Make a PATCH request.</dd><dt><a class="fn" href="fn.post.html" title="fn devela::_dep::ureq::post">post</a></dt><dd>Make a POST request.</dd><dt><a class="fn" href="fn.put.html" title="fn devela::_dep::ureq::put">put</a></dt><dd>Make a PUT request.</dd><dt><a class="fn" href="fn.run.html" title="fn devela::_dep::ureq::run">run</a></dt><dd>Run a <a href="http/struct.Request.html" title="struct devela::_dep::ureq::http::Request"><code>http::Request&lt;impl AsSendBody&gt;</code></a>.</dd><dt><a class="fn" href="fn.trace.html" title="fn devela::_dep::ureq::trace">trace</a></dt><dd>Make a TRACE request.</dd></dl></section></div></main></body></html>