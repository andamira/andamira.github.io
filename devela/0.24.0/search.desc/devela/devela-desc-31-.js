searchState.loadedDescShard("devela", 31, "Terminal functionality.\nANSI escape codes.\nANSI 3-bit color codes, 8 colors.\nANSI 8-bit color codes, 256 colors.\n0 Black\n4 Blue\n6 Cyan\n2 Green\n5 Magenta\n1 Red\nThe size of the terminal.\n7 White\n3 Yellow\nConcatenates or prints <code>Ansi</code> escape codes.\nColumns of cells.\nRows of cells.\nHorizontal pixels.\nVertical pixels.\nAsynchronous functionality.\nNative processes.\nSynchronization primitives.\nNative threads.\nThe coroutine completed with a return value.\nA managed dynamic collection of single-thread <code>CoroWorker</code> …\nA future that alternates between <code>Ready</code> and <code>Pending</code> status …\nRepresents a single-thread stackless coroutine worker.\n<code>core</code> The trait implemented by builtin coroutine types.\n<code>core</code> The result of a coroutine resumption.\nExtension trait providing additional methods for <code>Future</code>s.\n<code>core</code> An asynchronous computation obtained by use of <code>async</code>.\n<code>core</code> A future which never resolves, representing a …\n<code>core</code> A Future that wraps a function returning [<code>TaskPoll</code>].\n<code>core</code> A future that is immediately ready with a value.\n<code>core</code> Conversion into a <code>Future</code>.\nWhich kind of future are we turning this into?\nThe type of value produced on completion.\nThe output that the future will produce on completion.\nRepresents that a value is not ready yet.\nRepresents that a value is immediately ready.\nThe type of value this coroutine returns.\n<code>core</code> The context of an asynchronous task.\n<code>core</code> Indicates whether a value is ready or if the current …\n<code>core</code> Allows the implementor of a task executor to create a …\n<code>core</code> A virtual function pointer table that specifies the …\n⚛️ <code>?alloc</code> The implementation of waking a task on an …\n<code>core</code> A handle for waking up a task by notifying its …\nThe type of value this coroutine yields.\nThe coroutine suspended with a value.\nBlocks the thread until the future is ready.\nCreates a future from a value.\nCreates a future which never resolves.\nAttempts to resolve the future to a final value, …\nCreates a future that wraps a <code>function</code> returning <code>TaskPoll</code>.\nCreates a future that is immediately ready with a <code>value</code>.\nResumes the execution of this coroutine.\n<code>core</code> Extracts the successful type of a [<code>TaskPoll&lt;T&gt;</code>].\nWake this task.\nWake this task without consuming the waker.\nWake this task without consuming the waker.\n🌐 Extension trait providing additional methods for …\n<code>std</code> Representation of a running or exited child process.\n<code>std</code> A builder for configuring and spawning new processes.\n<code>std</code> An iterator over the command arguments.\n<code>std</code> An iterator over the command environment variables.\n⚖️ <code>std</code> The status code the process returns to its …\n⚖️ <code>std</code> Describes the result of a process after it has …\n<code>std</code> The output of a finished process.\n<code>std</code> A handle to a child process’s stderr.\n<code>std</code> A handle to a child process’s standard input (stdin).\n<code>std</code> Specifies how to handle standard I/O streams in […\n<code>std</code> A handle to a child process’s standard output …\n<code>std</code> A trait for implementing arbitrary return types in the …\nTerminates the current process in an abnormal fashion.\nConstructs a new <code>ProcessCommand</code> for launching the <code>program</code>.\nTerminates the current process with the specified exit …\nReturns the OS-assigned process identifier associated with …\nIs called to get the representation of the value as status …\nThe status (exit code) of the process.\nThe handle for reading from the child’s standard error …\nThe data that the process wrote to stderr.\nThe handle for writing to the child’s standard input …\nThe handle for reading from the child’s standard output …\nThe data that the process wrote to stdout.\n⚛️ <code>?alloc</code> A thread-safe reference-counting pointer.\n⚛️ <code>?alloc</code> A version of <code>Arc</code> that holds a non-owning …\n<code>std</code> Enables multiple threads to synchronize the beginning …\n⚖️ <code>std</code> Returned by <code>Barrier::wait()</code> when all threads in …\n<code>std</code> A Condition Variable\nContains the error value\nContains the error value\n<code>std</code> A value which is initialized on the first access.\n⚖️ <code>std</code> A type alias for the result of a lock method …\n<code>std</code> A mutual exclusion primitive useful for protecting …\n<code>std</code> An RAII implementation of a “scoped lock” of a …\nContains the success value\nContains the success value\n<code>std</code> A synchronization primitive for one-time global …\n<code>std</code> A synchronization primitive which can be written to …\n<code>std</code> State yielded to <code>Once::call_once_force()</code>’s closure …\n🚩 <code>std</code> A type of error which can be returned whenever a …\nThe lock could not be acquired because another thread …\n<code>std</code> A reader-writer lock\n<code>std</code> RAII structure used to release the shared read access …\n<code>std</code> RAII structure used to release the exclusive write …\nA spinlock providing mutual exclusion without blocking.\nA guard that grants exclusive access to a <code>SpinLock</code> value.\n🚩+ <code>std</code> An enumeration of possible errors associated …\n⚖️ <code>std</code> A type alias for the result of a nonblocking …\n⚖️ <code>std</code> Whether a timed wait on a condition variable …\nThe lock could not be acquired at this time because the …\nAtomic types.\nMulti-producer, single-consumer channel.\nHas the effects of both <code>Acquire</code> and <code>Release</code> together: For …\nWhen coupled with a load, if the loaded value was written …\n⚛️ <code>atomic</code> A generic atomic wrapper type.\n⚛️ <code>?core</code> A boolean type which can be safely shared …\n⚛️ <code>portable-atomic</code> A thread-safe floating-point type.\n⚛️ <code>portable-atomic</code> A thread-safe floating-point type.\n⚛️ <code>portable-atomic</code> A thread-safe signed integer type.\n⚛️ <code>?core</code> A thread-safe signed integer type.\n⚛️ <code>?core</code> A thread-safe signed integer type.\n⚛️ <code>?core</code> A thread-safe signed integer type.\n⚛️ <code>?core</code> A thread-safe signed integer type.\n⚛️ <code>?core</code> A thread-safe signed integer type.\n⚛️ <code>core</code> Atomic memory ordering.\n⚛️ <code>?core</code> A raw pointer type which can be safely shared …\n⚛️ <code>portable-atomic</code> A thread-safe unsigned integer type.\n⚛️ <code>?core</code> A thread-safe unsigned integer type.\n⚛️ <code>?core</code> A thread-safe unsigned integer type.\n⚛️ <code>?core</code> A thread-safe unsigned integer type.\n⚛️ <code>?core</code> A thread-safe unsigned integer type.\n⚛️ <code>?core</code> A thread-safe unsigned integer type.\nNo ordering constraints, only atomic operations.\nWhen coupled with a store, all previous operations become …\nLike <code>Acquire</code>/<code>Release</code>/<code>AcqRel</code> (for load, store, and …\n⚛️ <code>core</code> A compiler memory fence.\n⚛️ <code>core</code> An atomic fence.\nThe <strong>channel</strong>’s sending half has become disconnected, and …\nThe <strong>channel</strong>’s sending half has become disconnected, and …\nThis <code>sync_channel</code>’s receiving half has disconnected, so …\nThis <strong>channel</strong> is currently empty, but the <strong>Sender</strong>(s) have …\nThe data could not be sent on the <code>sync_channel</code> because it …\n🌐 Multi-producer, single-consumer channel operations.\n🔄 <code>std</code> An owning iterator over messages on an […\n🔄 <code>std</code> An iterator over messages on an [<code>MpscReceiver</code>]\n🚩 <code>std</code> An error returned from [<code>MpscReceiver::recv</code>].\n<code>std</code> The receiving half of an [<code>Mpsc</code>][crate::Mpsc] [<code>channel</code>][…\n🚩+ <code>std</code> Possible errors that made [<code>recv_timeout</code>][…\n🚩 <code>std</code> An error returned from [<code>MpscSender::send</code>] or […\n<code>std</code> The sending half of an <em>async</em> <code>Mpsc</code> channel.\n<code>std</code> The sending half of a <em>sync</em> <code>Mpsc</code> channel.\n🔄 <code>std</code> Attempts to yield all pending values for an […\n🚩+ <code>std</code> Possible reasons that [<code>try_recv</code>][…\n🚩+ <code>std</code> Possible error outcomes for the [<code>try_send</code>][…\nThis <strong>channel</strong> is currently empty, but the <strong>Sender</strong>(s) have …\nContains the error value\n🌐 Extension trait providing additional methods for …\nContains the success value\n<code>std</code> A handle to a thread.\n🚩 <code>std</code> An error returned by [<code>ThreadLocalKey::try_with</code>].\n<code>std</code> Thread factory, which can be used to configure the …\n<code>std</code> A unique identifier for a running thread.\n<code>std</code> An owned permission to join on a thread (block on its …\n<code>std</code> A thread local storage key which owns its contents.\n⚖️ <code>std</code> A specialized <code>Result</code> type for threads.\n<code>std</code> A scope to spawn scoped threads in.\n<code>std</code> An owned permission to join on a scoped thread (block …\nReturns an estimate of the default amount of parallelism a …\nGets a handle to the thread that invokes it.\nDetermines whether the current thread is unwinding because …\nBlocks unless or until the current thread’s token is …\nBlocks unless or until the current thread’s token is …\nCreate a scope for spawning scoped threads.\nPuts the current thread to sleep for at least the …\nA more compact <code>Thread::sleep</code>.\nPuts the current thread to sleep for at least the …\nPuts the current thread to sleep for at least the …\nPuts the current thread to sleep for at least the …\nSpawns a new thread, returning a <code>ThreadJoinHandle</code> for it.\n<code>std</code> Declare a new thread local storage key of type […\nCooperatively gives up a timeslice to the OS scheduler.")