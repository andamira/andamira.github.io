<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="`core` A wrapper type to construct uninitialized instances of `T`."><title>MaybeUninit in devela::all - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="devela" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-nightly (fe5536432 2025-08-29)" data-channel="nightly" data-search-js="search-03d23683.js" data-stringdex-js="stringdex-0e748618.js" data-settings-js="settings-c38705f0.js" ><script src="../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"><script>
  document.addEventListener("DOMContentLoaded", async function() {
    // Ensure this script runs only once per page load
    if (window.scriptLoaderInitialized) return;
    window.scriptLoaderInitialized = true;

    /* settings */

    const crateName = "devela";
    const allowedKatex = ["/all", "/media/color", "/num/", "/phys/"];
    const allowedKatexChem = ["/all/", "/phys/"];

    // Find the LAST occurrence of `/devela/` in the path
    const path = window.location.pathname;
    const lastCrateIndex = path.lastIndexOf(`/${crateName}/`);
    if (lastCrateIndex === -1) return;
    // Extract everything after the last `/devela/`
    const relativePath = path.slice(lastCrateIndex + crateName.length + 1);

    /* load resources */

    try {
      if (allowedKatex.some(prefix => relativePath.startsWith(prefix))) {
        await loadKatex().catch(handleMathError);
      }
      if (allowedKatexChem.some(prefix => relativePath.startsWith(prefix))) {
        await loadKatexChem().catch(handleMathError);
      }
    } catch (error) {
      handleMathError(error);
    }

    /* resource loading functions */

    // INFO: https://katex.org/docs/browser.html#starter-template
    // INFO: https://github.com/KaTeX/KaTeX/tree/main/contrib/copy-tex
    async function loadKatex() {
      console.log("Loading KaTeX for:", relativePath);

      // Load CSS, and scripts sequentially
      const katexCSS = document.createElement("link");
      katexCSS.rel = "stylesheet";
      katexCSS.href = "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css";
      katexCSS.integrity = "sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib";
      katexCSS.crossOrigin = "anonymous";
      document.head.appendChild(katexCSS);

      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js",
        integrity: "sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh"
      });
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js",
        integrity: "sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh"
      });
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/copy-tex.min.js",
        integrity: "sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi"
      });

      // Initialize KaTeX
      renderMathInElement(document.body, {
        delimiters: [
          {left: "$$", right: "$$", display: true},
          {left: "$", right: "$", display: false},
          {left: "\\(", right: "\\)", display: false},
          {left: "\\[", right: "\\]", display: true}
        ],
        trust: (context) => context.command === "\\href"
      });
      // Add custom styles: https://katex.org/docs/issues.html#css-customization
      const katexStyle = document.createElement("style");
      katexStyle.textContent = `
        .katex-display { overflow: hidden; }
        .docblock p { overflow-y: hidden; }
      `;
      document.head.appendChild(katexStyle);
    }

    // INFO: https://github.com/KaTeX/KaTeX/blob/main/contrib/mhchem/README.md
    async function loadKatexChem() {
      console.log("Loading KaTeX MhChem plugin for:", relativePath);
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/mhchem.min.js",
        integrity: "sha384-F2ptQFZqNJuqfGGl28mIXyQ5kXH48spn7rcoS0Y9psqIKAcZPLd1NzwFlm/bl1mH"
      });
    }

    /* helper functions */

    function loadScript(config) {
      return new Promise((resolve, reject) => {
        const script = document.createElement("script");
        script.src = config.src;
        if (config.integrity) {
          script.integrity = config.integrity;
          script.crossOrigin = "anonymous";
        }
        script.onload = resolve;
        script.onerror = () => reject(new Error(`Failed to load script: ${config.src}`));
        document.head.appendChild(script);
      });
    }
    function handleMathError(error) {
      console.error("Math rendering error:", error);
    }
  });
</script>

</head><body class="rustdoc union"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">MaybeUninit</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../devela/index.html">devela</a><span class="version">0.25.0-wip</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Maybe<wbr>Uninit</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#initialization-invariant" title="Initialization invariant">Initialization invariant</a></li><li><a href="#examples" title="Examples">Examples</a><ul><li><a href="#out-pointers" title="out-pointers">out-pointers</a></li><li><a href="#initializing-an-array-element-by-element" title="Initializing an array element-by-element">Initializing an array element-by-element</a></li><li><a href="#initializing-a-struct-field-by-field" title="Initializing a struct field-by-field">Initializing a struct field-by-field</a></li></ul></li><li><a href="#layout-1" title="Layout">Layout</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.array_assume_init" title="array_assume_init">array_assume_init</a></li><li><a href="#method.as_bytes" title="as_bytes">as_bytes</a></li><li><a href="#method.as_bytes_mut" title="as_bytes_mut">as_bytes_mut</a></li><li><a href="#method.as_mut_ptr" title="as_mut_ptr">as_mut_ptr</a></li><li><a href="#method.as_ptr" title="as_ptr">as_ptr</a></li><li><a href="#method.assume_init" title="assume_init">assume_init</a></li><li><a href="#method.assume_init-1" title="assume_init">assume_init</a></li><li><a href="#method.assume_init_drop" title="assume_init_drop">assume_init_drop</a></li><li><a href="#method.assume_init_mut" title="assume_init_mut">assume_init_mut</a></li><li><a href="#method.assume_init_read" title="assume_init_read">assume_init_read</a></li><li><a href="#method.assume_init_ref" title="assume_init_ref">assume_init_ref</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.slice_as_mut_ptr" title="slice_as_mut_ptr">slice_as_mut_ptr</a></li><li><a href="#method.slice_as_ptr" title="slice_as_ptr">slice_as_ptr</a></li><li><a href="#method.transpose" title="transpose">transpose</a></li><li><a href="#method.uninit" title="uninit">uninit</a></li><li><a href="#method.write" title="write">write</a></li><li><a href="#method.write-1" title="write">write</a></li><li><a href="#method.zeroed" title="zeroed">zeroed</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-AnyBitPattern-for-MaybeUninit%3CT%3E" title="AnyBitPattern">AnyBitPattern</a></li><li><a href="#impl-Clone-for-MaybeUninit%3CT%3E" title="Clone">Clone</a></li><li><a href="#impl-Copy-for-MaybeUninit%3CT%3E" title="Copy">Copy</a></li><li><a href="#impl-Debug-for-MaybeUninit%3CT%3E" title="Debug">Debug</a></li><li><a href="#impl-MemPod-for-MaybeUninit%3CT%3E" title="MemPod">MemPod</a></li><li><a href="#impl-Zeroable-for-MaybeUninit%3CT%3E" title="Zeroable">Zeroable</a></li><li><a href="#impl-Zeroize-for-MaybeUninit%3CZ%3E" title="Zeroize">Zeroize</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-MaybeUninit%3CT%3E" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-MaybeUninit%3CT%3E" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-MaybeUninit%3CT%3E" title="Send">Send</a></li><li><a href="#impl-Sync-for-MaybeUninit%3CT%3E" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-MaybeUninit%3CT%3E" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-MaybeUninit%3CT%3E" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-ByteSized-for-T" title="ByteSized">ByteSized</a></li><li><a href="#impl-Chain%3CR%3E-for-T" title="Chain&#60;R&#62;">Chain&#60;R&#62;</a></li><li><a href="#impl-CheckedBitPattern-for-T" title="CheckedBitPattern">CheckedBitPattern</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-Duplex%3CS%3E-for-T" title="Duplex&#60;S&#62;">Duplex&#60;S&#62;</a></li><li><a href="#impl-ExtAny-for-T" title="ExtAny">ExtAny</a></li><li><a href="#impl-ExtMem-for-T" title="ExtMem">ExtMem</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-FromSample%3CS%3E-for-S" title="FromSample&#60;S&#62;">FromSample&#60;S&#62;</a></li><li><a href="#impl-Hook-for-T" title="Hook">Hook</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-IntoEither-for-T" title="IntoEither">IntoEither</a></li><li><a href="#impl-IntoSample%3CT%3E-for-F" title="IntoSample&#60;T&#62;">IntoSample&#60;T&#62;</a></li><li><a href="#impl-Pointable-for-T" title="Pointable">Pointable</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-ToSample%3CU%3E-for-T" title="ToSample&#60;U&#62;">ToSample&#60;U&#62;</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li><li><a href="#impl-Ungil-for-T" title="Ungil">Ungil</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In devela::<wbr>all</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../index.html">devela</a>::<wbr><a href="index.html">all</a></div><h1>Union <span class="union">Maybe<wbr>Uninit</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#261">Source</a> </span></div><pre class="rust item-decl"><code>pub union MaybeUninit&lt;T&gt; {
    <span class="comment">/* private fields */</span>
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><span class='stab portability' title='re-exported from rust&#39;s `core`'><code>core</code></span>
A wrapper type to construct uninitialized instances of <code>T</code>.</p>
<p><em>Re-exported from <a href="../_core/index.html" title="mod devela::_core"><code>core</code></a>::<a href="https://doc.rust-lang.org/core/mem/"><code>mem::</code></a></em>
.</p>
<hr />
<p>A wrapper type to construct uninitialized instances of <code>T</code>.</p>
<h2 id="initialization-invariant"><a class="doc-anchor" href="#initialization-invariant">§</a>Initialization invariant</h2>
<p>The compiler, in general, assumes that a variable is properly initialized
according to the requirements of the variable’s type. For example, a variable of
reference type must be aligned and non-null. This is an invariant that must
<em>always</em> be upheld, even in unsafe code. As a consequence, zero-initializing a
variable of reference type causes instantaneous <a href="../../reference/behavior-considered-undefined.html">undefined behavior</a>,
no matter whether that reference ever gets used to access memory:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::{<span class="self">self</span>, MaybeUninit};

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>i32 = <span class="kw">unsafe </span>{ mem::zeroed() }; <span class="comment">// undefined behavior! ⚠️
// The equivalent code with `MaybeUninit&lt;&amp;i32&gt;`:
</span><span class="kw">let </span>x: <span class="kw-2">&amp;</span>i32 = <span class="kw">unsafe </span>{ MaybeUninit::zeroed().assume_init() }; <span class="comment">// undefined behavior! ⚠️</span></code></pre></div>
<p>This is exploited by the compiler for various optimizations, such as eliding
run-time checks and optimizing <code>enum</code> layout.</p>
<p>Similarly, entirely uninitialized memory may have any content, while a <code>bool</code> must
always be <code>true</code> or <code>false</code>. Hence, creating an uninitialized <code>bool</code> is undefined behavior:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::{<span class="self">self</span>, MaybeUninit};

<span class="kw">let </span>b: bool = <span class="kw">unsafe </span>{ mem::uninitialized() }; <span class="comment">// undefined behavior! ⚠️
// The equivalent code with `MaybeUninit&lt;bool&gt;`:
</span><span class="kw">let </span>b: bool = <span class="kw">unsafe </span>{ MaybeUninit::uninit().assume_init() }; <span class="comment">// undefined behavior! ⚠️</span></code></pre></div>
<p>Moreover, uninitialized memory is special in that it does not have a fixed value (“fixed”
meaning “it won’t change without being written to”). Reading the same uninitialized byte
multiple times can give different results. This makes it undefined behavior to have
uninitialized data in a variable even if that variable has an integer type, which otherwise can
hold any <em>fixed</em> bit pattern:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::{<span class="self">self</span>, MaybeUninit};

<span class="kw">let </span>x: i32 = <span class="kw">unsafe </span>{ mem::uninitialized() }; <span class="comment">// undefined behavior! ⚠️
// The equivalent code with `MaybeUninit&lt;i32&gt;`:
</span><span class="kw">let </span>x: i32 = <span class="kw">unsafe </span>{ MaybeUninit::uninit().assume_init() }; <span class="comment">// undefined behavior! ⚠️</span></code></pre></div>
<p>On top of that, remember that most types have additional invariants beyond merely
being considered initialized at the type level. For example, a <code>1</code>-initialized <a href="../../std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a>
is considered initialized (under the current implementation; this does not constitute
a stable guarantee) because the only requirement the compiler knows about it
is that the data pointer must be non-null. Creating such a <code>Vec&lt;T&gt;</code> does not cause
<em>immediate</em> undefined behavior, but will cause undefined behavior with most
safe operations (including dropping it).</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<p><code>MaybeUninit&lt;T&gt;</code> serves to enable unsafe code to deal with uninitialized data.
It is a signal to the compiler indicating that the data here might <em>not</em>
be initialized:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="comment">// Create an explicitly uninitialized reference. The compiler knows that data inside
// a `MaybeUninit&lt;T&gt;` may be invalid, and hence this is not UB:
</span><span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;<span class="kw-2">&amp;</span>i32&gt;::uninit();
<span class="comment">// Set it to a valid value.
</span>x.write(<span class="kw-2">&amp;</span><span class="number">0</span>);
<span class="comment">// Extract the initialized data -- this is only allowed *after* properly
// initializing `x`!
</span><span class="kw">let </span>x = <span class="kw">unsafe </span>{ x.assume_init() };</code></pre></div>
<p>The compiler then knows to not make any incorrect assumptions or optimizations on this code.</p>
<p>You can think of <code>MaybeUninit&lt;T&gt;</code> as being a bit like <code>Option&lt;T&gt;</code> but without
any of the run-time tracking and without any of the safety checks.</p>
<h3 id="out-pointers"><a class="doc-anchor" href="#out-pointers">§</a>out-pointers</h3>
<p>You can use <code>MaybeUninit&lt;T&gt;</code> to implement “out-pointers”: instead of returning data
from a function, pass it a pointer to some (uninitialized) memory to put the
result into. This can be useful when it is important for the caller to control
how the memory the result is stored in gets allocated, and you want to avoid
unnecessary moves.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">unsafe fn </span>make_vec(out: <span class="kw-2">*mut </span>Vec&lt;i32&gt;) {
    <span class="comment">// `write` does not drop the old contents, which is important.
    </span><span class="kw">unsafe </span>{ out.write(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); }
}

<span class="kw">let </span><span class="kw-2">mut </span>v = MaybeUninit::uninit();
<span class="kw">unsafe </span>{ make_vec(v.as_mut_ptr()); }
<span class="comment">// Now we know `v` is initialized! This also makes sure the vector gets
// properly dropped.
</span><span class="kw">let </span>v = <span class="kw">unsafe </span>{ v.assume_init() };
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>v, <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</code></pre></div>
<h3 id="initializing-an-array-element-by-element"><a class="doc-anchor" href="#initializing-an-array-element-by-element">§</a>Initializing an array element-by-element</h3>
<p><code>MaybeUninit&lt;T&gt;</code> can be used to initialize a large array element-by-element:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::{<span class="self">self</span>, MaybeUninit};

<span class="kw">let </span>data = {
    <span class="comment">// Create an uninitialized array of `MaybeUninit`.
    </span><span class="kw">let </span><span class="kw-2">mut </span>data: [MaybeUninit&lt;Vec&lt;u32&gt;&gt;; <span class="number">1000</span>] = [<span class="kw">const </span>{ MaybeUninit::uninit() }; <span class="number">1000</span>];

    <span class="comment">// Dropping a `MaybeUninit` does nothing, so if there is a panic during this loop,
    // we have a memory leak, but there is no memory safety issue.
    </span><span class="kw">for </span>elem <span class="kw">in </span><span class="kw-2">&amp;mut </span>data[..] {
        elem.write(<span class="macro">vec!</span>[<span class="number">42</span>]);
    }

    <span class="comment">// Everything is initialized. Transmute the array to the
    // initialized type.
    </span><span class="kw">unsafe </span>{ mem::transmute::&lt;<span class="kw">_</span>, [Vec&lt;u32&gt;; <span class="number">1000</span>]&gt;(data) }
};

<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>data[<span class="number">0</span>], <span class="kw-2">&amp;</span>[<span class="number">42</span>]);</code></pre></div>
<p>You can also work with partially initialized arrays, which could
be found in low-level datastructures.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="comment">// Create an uninitialized array of `MaybeUninit`.
</span><span class="kw">let </span><span class="kw-2">mut </span>data: [MaybeUninit&lt;String&gt;; <span class="number">1000</span>] = [<span class="kw">const </span>{ MaybeUninit::uninit() }; <span class="number">1000</span>];
<span class="comment">// Count the number of elements we have assigned.
</span><span class="kw">let </span><span class="kw-2">mut </span>data_len: usize = <span class="number">0</span>;

<span class="kw">for </span>elem <span class="kw">in </span><span class="kw-2">&amp;mut </span>data[<span class="number">0</span>..<span class="number">500</span>] {
    elem.write(String::from(<span class="string">"hello"</span>));
    data_len += <span class="number">1</span>;
}

<span class="comment">// For each item in the array, drop if we allocated it.
</span><span class="kw">for </span>elem <span class="kw">in </span><span class="kw-2">&amp;mut </span>data[<span class="number">0</span>..data_len] {
    <span class="kw">unsafe </span>{ elem.assume_init_drop(); }
}</code></pre></div>
<h3 id="initializing-a-struct-field-by-field"><a class="doc-anchor" href="#initializing-a-struct-field-by-field">§</a>Initializing a struct field-by-field</h3>
<p>You can use <code>MaybeUninit&lt;T&gt;</code>, and the <a href="../_core/ptr/macro.addr_of_mut.html" title="macro devela::_core::ptr::addr_of_mut"><code>std::ptr::addr_of_mut</code></a> macro, to initialize structs field by field:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;
<span class="kw">use </span>std::ptr::addr_of_mut;

<span class="attr">#[derive(Debug, PartialEq)]
</span><span class="kw">pub struct </span>Foo {
    name: String,
    list: Vec&lt;u8&gt;,
}

<span class="kw">let </span>foo = {
    <span class="kw">let </span><span class="kw-2">mut </span>uninit: MaybeUninit&lt;Foo&gt; = MaybeUninit::uninit();
    <span class="kw">let </span>ptr = uninit.as_mut_ptr();

    <span class="comment">// Initializing the `name` field
    // Using `write` instead of assignment via `=` to not call `drop` on the
    // old, uninitialized value.
    </span><span class="kw">unsafe </span>{ <span class="macro">addr_of_mut!</span>((<span class="kw-2">*</span>ptr).name).write(<span class="string">"Bob"</span>.to_string()); }

    <span class="comment">// Initializing the `list` field
    // If there is a panic here, then the `String` in the `name` field leaks.
    </span><span class="kw">unsafe </span>{ <span class="macro">addr_of_mut!</span>((<span class="kw-2">*</span>ptr).list).write(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]); }

    <span class="comment">// All the fields are initialized, so we call `assume_init` to get an initialized Foo.
    </span><span class="kw">unsafe </span>{ uninit.assume_init() }
};

<span class="macro">assert_eq!</span>(
    foo,
    Foo {
        name: <span class="string">"Bob"</span>.to_string(),
        list: <span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]
    }
);</code></pre></div>
<h2 id="layout-1"><a class="doc-anchor" href="#layout-1">§</a>Layout</h2>
<p><code>MaybeUninit&lt;T&gt;</code> is guaranteed to have the same size, alignment, and ABI as <code>T</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;
<span class="macro">assert_eq!</span>(size_of::&lt;MaybeUninit&lt;u64&gt;&gt;(), size_of::&lt;u64&gt;());
<span class="macro">assert_eq!</span>(align_of::&lt;MaybeUninit&lt;u64&gt;&gt;(), align_of::&lt;u64&gt;());</code></pre></div>
<p>However remember that a type <em>containing</em> a <code>MaybeUninit&lt;T&gt;</code> is not necessarily the same
layout; Rust does not in general guarantee that the fields of a <code>Foo&lt;T&gt;</code> have the same order as
a <code>Foo&lt;U&gt;</code> even if <code>T</code> and <code>U</code> have the same size and alignment. Furthermore because any bit
value is valid for a <code>MaybeUninit&lt;T&gt;</code> the compiler can’t apply non-zero/niche-filling
optimizations, potentially resulting in a larger size:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(size_of::&lt;<span class="prelude-ty">Option</span>&lt;bool&gt;&gt;(), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(size_of::&lt;<span class="prelude-ty">Option</span>&lt;MaybeUninit&lt;bool&gt;&gt;&gt;(), <span class="number">2</span>);</code></pre></div>
<p>If <code>T</code> is FFI-safe, then so is <code>MaybeUninit&lt;T&gt;</code>.</p>
<p>While <code>MaybeUninit</code> is <code>#[repr(transparent)]</code> (indicating it guarantees the same size,
alignment, and ABI as <code>T</code>), this does <em>not</em> change any of the previous caveats. <code>Option&lt;T&gt;</code> and
<code>Option&lt;MaybeUninit&lt;T&gt;&gt;</code> may still have different sizes, and types containing a field of type
<code>T</code> may be laid out (and sized) differently than if that field were <code>MaybeUninit&lt;T&gt;</code>.
<code>MaybeUninit</code> is a union type, and <code>#[repr(transparent)]</code> on unions is unstable (see <a href="https://github.com/rust-lang/rust/issues/60405">the
tracking issue</a>). Over time, the exact
guarantees of <code>#[repr(transparent)]</code> on unions may evolve, and <code>MaybeUninit</code> may or may not
remain <code>#[repr(transparent)]</code>. That said, <code>MaybeUninit&lt;T&gt;</code> will <em>always</em> guarantee that it has
the same size, alignment, and ABI as <code>T</code>; it’s just that the way <code>MaybeUninit</code> implements that
guarantee may evolve.</p>
<p>Note that even though <code>T</code> and <code>MaybeUninit&lt;T&gt;</code> are ABI compatible it is still unsound to
transmute <code>&amp;mut T</code> to <code>&amp;mut MaybeUninit&lt;T&gt;</code> and expose that to safe code because it would allow
safe code to access uninitialized memory:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>core::mem::MaybeUninit;

<span class="kw">fn </span>unsound_transmute&lt;T&gt;(val: <span class="kw-2">&amp;mut </span>T) -&gt; <span class="kw-2">&amp;mut </span>MaybeUninit&lt;T&gt; {
    <span class="kw">unsafe </span>{ core::mem::transmute(val) }
}

<span class="kw">fn </span>main() {
    <span class="kw">let </span><span class="kw-2">mut </span>code = <span class="number">0</span>;
    <span class="kw">let </span>code = <span class="kw-2">&amp;mut </span>code;
    <span class="kw">let </span>code2 = unsound_transmute(code);
    <span class="kw-2">*</span>code2 = MaybeUninit::uninit();
    std::process::exit(<span class="kw-2">*</span>code); <span class="comment">// UB! Accessing uninitialized memory.
</span>}</code></pre></div>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-MaybeUninit%3CT%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#285">Source</a><a href="#impl-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0, const since 1.36.0">1.36.0 (const: 1.36.0)</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#307">Source</a></span><h4 class="code-header">pub const fn <a href="#method.new" class="fn">new</a>(val: T) -&gt; <a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Creates a new <code>MaybeUninit&lt;T&gt;</code> initialized with the given value.
It is safe to call <a href="union.MaybeUninit.html#method.assume_init" title="method devela::all::MaybeUninit::assume_init"><code>assume_init</code></a> on the return value of this function.</p>
<p>Note that dropping a <code>MaybeUninit&lt;T&gt;</code> will never call <code>T</code>’s drop code.
It is your responsibility to make sure <code>T</code> gets dropped if it got initialized.</p>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span>v: MaybeUninit&lt;Vec&lt;u8&gt;&gt; = MaybeUninit::new(<span class="macro">vec!</span>[<span class="number">42</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.uninit" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0, const since 1.36.0">1.36.0 (const: 1.36.0)</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#330">Source</a></span><h4 class="code-header">pub const fn <a href="#method.uninit" class="fn">uninit</a>() -&gt; <a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Creates a new <code>MaybeUninit&lt;T&gt;</code> in an uninitialized state.</p>
<p>Note that dropping a <code>MaybeUninit&lt;T&gt;</code> will never call <code>T</code>’s drop code.
It is your responsibility to make sure <code>T</code> gets dropped if it got initialized.</p>
<p>See the <a href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">type-level documentation</a> for some examples.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span>v: MaybeUninit&lt;String&gt; = MaybeUninit::uninit();</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.zeroed" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0, const since 1.75.0">1.36.0 (const: 1.75.0)</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#380">Source</a></span><h4 class="code-header">pub const fn <a href="#method.zeroed" class="fn">zeroed</a>() -&gt; <a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h4></section></summary><div class="docblock"><p>Creates a new <code>MaybeUninit&lt;T&gt;</code> in an uninitialized state, with the memory being
filled with <code>0</code> bytes. It depends on <code>T</code> whether that already makes for
proper initialization. For example, <code>MaybeUninit&lt;usize&gt;::zeroed()</code> is initialized,
but <code>MaybeUninit&lt;&amp;'static i32&gt;::zeroed()</code> is not because references must not
be null.</p>
<p>Note that if <code>T</code> has padding bytes, those bytes are <em>not</em> preserved when the
<code>MaybeUninit&lt;T&gt;</code> value is returned from this function, so those bytes will <em>not</em> be zeroed.</p>
<p>Note that dropping a <code>MaybeUninit&lt;T&gt;</code> will never call <code>T</code>’s drop code.
It is your responsibility to make sure <code>T</code> gets dropped if it got initialized.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<p>Correct usage of this function: initializing a struct with zero, where all
fields of the struct can hold the bit-pattern 0 as a valid value.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span>x = MaybeUninit::&lt;(u8, bool)&gt;::zeroed();
<span class="kw">let </span>x = <span class="kw">unsafe </span>{ x.assume_init() };
<span class="macro">assert_eq!</span>(x, (<span class="number">0</span>, <span class="bool-val">false</span>));</code></pre></div>
<p>This can be used in const contexts, such as to indicate the end of static arrays for
plugin registration.</p>
<p><em>Incorrect</em> usage of this function: calling <code>x.zeroed().assume_init()</code>
when <code>0</code> is not a valid bit-pattern for the type:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">enum </span>NotZero { One = <span class="number">1</span>, Two = <span class="number">2 </span>}

<span class="kw">let </span>x = MaybeUninit::&lt;(u8, NotZero)&gt;::zeroed();
<span class="kw">let </span>x = <span class="kw">unsafe </span>{ x.assume_init() };
<span class="comment">// Inside a pair, we create a `NotZero` that does not have a valid discriminant.
// This is undefined behavior. ⚠️</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.55.0, const since 1.85.0">1.55.0 (const: 1.85.0)</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#474">Source</a></span><h4 class="code-header">pub const fn <a href="#method.write" class="fn">write</a>(&amp;mut self, val: T) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class="docblock"><p>Sets the value of the <code>MaybeUninit&lt;T&gt;</code>.</p>
<p>This overwrites any previous value without dropping it, so be careful
not to use this twice unless you want to skip running the destructor.
For your convenience, this also returns a mutable reference to the
(now safely initialized) contents of <code>self</code>.</p>
<p>As the content is stored inside a <code>ManuallyDrop</code>, the destructor is not
run for the inner data if the MaybeUninit leaves scope without a call to
<a href="union.MaybeUninit.html#method.assume_init" title="method devela::all::MaybeUninit::assume_init"><code>assume_init</code></a>, <a href="union.MaybeUninit.html#method.assume_init_drop" title="method devela::all::MaybeUninit::assume_init_drop"><code>assume_init_drop</code></a>, or similar. Code that receives
the mutable reference returned by this function needs to keep this in
mind. The safety model of Rust regards leaks as safe, but they are
usually still undesirable. This being said, the mutable reference
behaves like any other mutable reference would, so assigning a new value
to it will drop the old content.</p>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">§</a>Examples</h5>
<p>Correct usage of this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;Vec&lt;u8&gt;&gt;::uninit();

{
    <span class="kw">let </span>hello = x.write((<span class="kw-2">&amp;</span><span class="string">b"Hello, world!"</span>).to_vec());
    <span class="comment">// Setting hello does not leak prior allocations, but drops them
    </span><span class="kw-2">*</span>hello = (<span class="kw-2">&amp;</span><span class="string">b"Hello"</span>).to_vec();
    hello[<span class="number">0</span>] = <span class="string">'h' </span><span class="kw">as </span>u8;
}
<span class="comment">// x is initialized now:
</span><span class="kw">let </span>s = <span class="kw">unsafe </span>{ x.assume_init() };
<span class="macro">assert_eq!</span>(<span class="string">b"hello"</span>, s.as_slice());</code></pre></div>
<p>This usage of the method causes a leak:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;String&gt;::uninit();

x.write(<span class="string">"Hello"</span>.to_string());
<span class="comment">// This leaks the contained string:
</span>x.write(<span class="string">"hello"</span>.to_string());
<span class="comment">// x is initialized now:
</span><span class="kw">let </span>s = <span class="kw">unsafe </span>{ x.assume_init() };</code></pre></div>
<p>This method can be used to avoid unsafe in some cases. The example below
shows a part of an implementation of a fixed sized arena that lends out
pinned references.
With <code>write</code>, we can avoid the need to write through a raw pointer:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>core::pin::Pin;
<span class="kw">use </span>core::mem::MaybeUninit;

<span class="kw">struct </span>PinArena&lt;T&gt; {
    memory: Box&lt;[MaybeUninit&lt;T&gt;]&gt;,
    len: usize,
}

<span class="kw">impl </span>&lt;T&gt; PinArena&lt;T&gt; {
    <span class="kw">pub fn </span>capacity(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; usize {
        <span class="self">self</span>.memory.len()
    }
    <span class="kw">pub fn </span>push(<span class="kw-2">&amp;mut </span><span class="self">self</span>, val: T) -&gt; Pin&lt;<span class="kw-2">&amp;mut </span>T&gt; {
        <span class="kw">if </span><span class="self">self</span>.len &gt;= <span class="self">self</span>.capacity() {
            <span class="macro">panic!</span>(<span class="string">"Attempted to push to a full pin arena!"</span>);
        }
        <span class="kw">let </span>ref_ = <span class="self">self</span>.memory[<span class="self">self</span>.len].write(val);
        <span class="self">self</span>.len += <span class="number">1</span>;
        <span class="kw">unsafe </span>{ Pin::new_unchecked(ref_) }
    }
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_ptr" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0, const since 1.59.0">1.36.0 (const: 1.59.0)</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#517">Source</a></span><h4 class="code-header">pub const fn <a href="#method.as_ptr" class="fn">as_ptr</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*const T</a></h4></section></summary><div class="docblock"><p>Gets a pointer to the contained value. Reading from this pointer or turning it
into a reference is undefined behavior unless the <code>MaybeUninit&lt;T&gt;</code> is initialized.
Writing to memory that this pointer (non-transitively) points to is undefined behavior
(except inside an <code>UnsafeCell&lt;T&gt;</code>).</p>
<h5 id="examples-2"><a class="doc-anchor" href="#examples-2">§</a>Examples</h5>
<p>Correct usage of this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();
x.write(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);
<span class="comment">// Create a reference into the `MaybeUninit&lt;T&gt;`. This is okay because we initialized it.
</span><span class="kw">let </span>x_vec = <span class="kw">unsafe </span>{ <span class="kw-2">&amp;*</span>x.as_ptr() };
<span class="macro">assert_eq!</span>(x_vec.len(), <span class="number">3</span>);</code></pre></div>
<p><em>Incorrect</em> usage of this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();
<span class="kw">let </span>x_vec = <span class="kw">unsafe </span>{ <span class="kw-2">&amp;*</span>x.as_ptr() };
<span class="comment">// We have created a reference to an uninitialized vector! This is undefined behavior. ⚠️</span></code></pre></div>
<p>(Notice that the rules around references to uninitialized data are not finalized yet, but
until they are, it is advisable to avoid them.)</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_mut_ptr" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0, const since 1.83.0">1.36.0 (const: 1.83.0)</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#559">Source</a></span><h4 class="code-header">pub const fn <a href="#method.as_mut_ptr" class="fn">as_mut_ptr</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut T</a></h4></section></summary><div class="docblock"><p>Gets a mutable pointer to the contained value. Reading from this pointer or turning it
into a reference is undefined behavior unless the <code>MaybeUninit&lt;T&gt;</code> is initialized.</p>
<h5 id="examples-3"><a class="doc-anchor" href="#examples-3">§</a>Examples</h5>
<p>Correct usage of this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();
x.write(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);
<span class="comment">// Create a reference into the `MaybeUninit&lt;Vec&lt;u32&gt;&gt;`.
// This is okay because we initialized it.
</span><span class="kw">let </span>x_vec = <span class="kw">unsafe </span>{ <span class="kw-2">&amp;mut *</span>x.as_mut_ptr() };
x_vec.push(<span class="number">3</span>);
<span class="macro">assert_eq!</span>(x_vec.len(), <span class="number">4</span>);</code></pre></div>
<p><em>Incorrect</em> usage of this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();
<span class="kw">let </span>x_vec = <span class="kw">unsafe </span>{ <span class="kw-2">&amp;mut *</span>x.as_mut_ptr() };
<span class="comment">// We have created a reference to an uninitialized vector! This is undefined behavior. ⚠️</span></code></pre></div>
<p>(Notice that the rules around references to uninitialized data are not finalized yet, but
until they are, it is advisable to avoid them.)</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assume_init" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0, const since 1.59.0">1.36.0 (const: 1.59.0)</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#614">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.assume_init" class="fn">assume_init</a>(self) -&gt; T</h4></section></summary><div class="docblock"><p>Extracts the value from the <code>MaybeUninit&lt;T&gt;</code> container. This is a great way
to ensure that the data will get dropped, because the resulting <code>T</code> is
subject to the usual drop handling.</p>
<h5 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h5>
<p>It is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> really is in an initialized
state. Calling this when the content is not yet fully initialized causes immediate undefined
behavior. The <a href="#initialization-invariant">type-level documentation</a> contains more information about
this initialization invariant.</p>
<p>On top of that, remember that most types have additional invariants beyond merely
being considered initialized at the type level. For example, a <code>1</code>-initialized <a href="../../std/vec/struct.Vec.html"><code>Vec&lt;T&gt;</code></a>
is considered initialized (under the current implementation; this does not constitute
a stable guarantee) because the only requirement the compiler knows about it
is that the data pointer must be non-null. Creating such a <code>Vec&lt;T&gt;</code> does not cause
<em>immediate</em> undefined behavior, but will cause undefined behavior with most
safe operations (including dropping it).</p>
<h5 id="examples-4"><a class="doc-anchor" href="#examples-4">§</a>Examples</h5>
<p>Correct usage of this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;bool&gt;::uninit();
x.write(<span class="bool-val">true</span>);
<span class="kw">let </span>x_init = <span class="kw">unsafe </span>{ x.assume_init() };
<span class="macro">assert_eq!</span>(x_init, <span class="bool-val">true</span>);</code></pre></div>
<p><em>Incorrect</em> usage of this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();
<span class="kw">let </span>x_init = <span class="kw">unsafe </span>{ x.assume_init() };
<span class="comment">// `x` had not been initialized yet, so this last line caused undefined behavior. ⚠️</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assume_init_read" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.60.0, const since 1.75.0">1.60.0 (const: 1.75.0)</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#686">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.assume_init_read" class="fn">assume_init_read</a>(&amp;self) -&gt; T</h4></section></summary><div class="docblock"><p>Reads the value from the <code>MaybeUninit&lt;T&gt;</code> container. The resulting <code>T</code> is subject
to the usual drop handling.</p>
<p>Whenever possible, it is preferable to use <a href="union.MaybeUninit.html#method.assume_init" title="method devela::all::MaybeUninit::assume_init"><code>assume_init</code></a> instead, which
prevents duplicating the content of the <code>MaybeUninit&lt;T&gt;</code>.</p>
<h5 id="safety-1"><a class="doc-anchor" href="#safety-1">§</a>Safety</h5>
<p>It is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> really is in an initialized
state. Calling this when the content is not yet fully initialized causes undefined
behavior. The <a href="#initialization-invariant">type-level documentation</a> contains more information about
this initialization invariant.</p>
<p>Moreover, similar to the <a href="../_core/ptr/fn.read.html" title="fn devela::_core::ptr::read"><code>ptr::read</code></a> function, this function creates a
bitwise copy of the contents, regardless whether the contained type
implements the <a href="trait.Copy.html" title="trait devela::all::Copy"><code>Copy</code></a> trait or not. When using multiple copies of the
data (by calling <code>assume_init_read</code> multiple times, or first calling
<code>assume_init_read</code> and then <a href="union.MaybeUninit.html#method.assume_init" title="method devela::all::MaybeUninit::assume_init"><code>assume_init</code></a>), it is your responsibility
to ensure that data may indeed be duplicated.</p>
<h5 id="examples-5"><a class="doc-anchor" href="#examples-5">§</a>Examples</h5>
<p>Correct usage of this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;u32&gt;::uninit();
x.write(<span class="number">13</span>);
<span class="kw">let </span>x1 = <span class="kw">unsafe </span>{ x.assume_init_read() };
<span class="comment">// `u32` is `Copy`, so we may read multiple times.
</span><span class="kw">let </span>x2 = <span class="kw">unsafe </span>{ x.assume_init_read() };
<span class="macro">assert_eq!</span>(x1, x2);

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;<span class="prelude-ty">Option</span>&lt;Vec&lt;u32&gt;&gt;&gt;::uninit();
x.write(<span class="prelude-val">None</span>);
<span class="kw">let </span>x1 = <span class="kw">unsafe </span>{ x.assume_init_read() };
<span class="comment">// Duplicating a `None` value is okay, so we may read multiple times.
</span><span class="kw">let </span>x2 = <span class="kw">unsafe </span>{ x.assume_init_read() };
<span class="macro">assert_eq!</span>(x1, x2);</code></pre></div>
<p><em>Incorrect</em> usage of this method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;<span class="prelude-ty">Option</span>&lt;Vec&lt;u32&gt;&gt;&gt;::uninit();
x.write(<span class="prelude-val">Some</span>(<span class="macro">vec!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]));
<span class="kw">let </span>x1 = <span class="kw">unsafe </span>{ x.assume_init_read() };
<span class="kw">let </span>x2 = <span class="kw">unsafe </span>{ x.assume_init_read() };
<span class="comment">// We now created two copies of the same vector, leading to a double-free ⚠️ when
// they both get dropped!</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assume_init_drop" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.60.0">1.60.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#717">Source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.assume_init_drop" class="fn">assume_init_drop</a>(&amp;mut self)</h4></section></summary><div class="docblock"><p>Drops the contained value in place.</p>
<p>If you have ownership of the <code>MaybeUninit</code>, you can also use
<a href="union.MaybeUninit.html#method.assume_init" title="method devela::all::MaybeUninit::assume_init"><code>assume_init</code></a> as an alternative.</p>
<h5 id="safety-2"><a class="doc-anchor" href="#safety-2">§</a>Safety</h5>
<p>It is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> really is
in an initialized state. Calling this when the content is not yet fully
initialized causes undefined behavior.</p>
<p>On top of that, all additional invariants of the type <code>T</code> must be
satisfied, as the <code>Drop</code> implementation of <code>T</code> (or its members) may
rely on this. For example, setting a <code>Vec&lt;T&gt;</code> to an invalid but
non-null address makes it initialized (under the current implementation;
this does not constitute a stable guarantee), because the only
requirement the compiler knows about it is that the data pointer must be
non-null. Dropping such a <code>Vec&lt;T&gt;</code> however will cause undefined
behavior.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assume_init_ref" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.55.0, const since 1.59.0">1.55.0 (const: 1.59.0)</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#782">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.assume_init_ref" class="fn">assume_init_ref</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class="docblock"><p>Gets a shared reference to the contained value.</p>
<p>This can be useful when we want to access a <code>MaybeUninit</code> that has been
initialized but don’t have ownership of the <code>MaybeUninit</code> (preventing the use
of <code>.assume_init()</code>).</p>
<h5 id="safety-3"><a class="doc-anchor" href="#safety-3">§</a>Safety</h5>
<p>Calling this when the content is not yet fully initialized causes undefined
behavior: it is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> really
is in an initialized state.</p>
<h5 id="examples-6"><a class="doc-anchor" href="#examples-6">§</a>Examples</h5><h6 id="correct-usage-of-this-method"><a class="doc-anchor" href="#correct-usage-of-this-method">§</a>Correct usage of this method:</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();
<span class="comment">// Initialize `x`:
</span>x.write(<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);
<span class="comment">// Now that our `MaybeUninit&lt;_&gt;` is known to be initialized, it is okay to
// create a shared reference to it:
</span><span class="kw">let </span>x: <span class="kw-2">&amp;</span>Vec&lt;u32&gt; = <span class="kw">unsafe </span>{
    <span class="comment">// SAFETY: `x` has been initialized.
    </span>x.assume_init_ref()
};
<span class="macro">assert_eq!</span>(x, <span class="kw-2">&amp;</span><span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</code></pre></div>
<h6 id="incorrect-usages-of-this-method"><a class="doc-anchor" href="#incorrect-usages-of-this-method">§</a><em>Incorrect</em> usages of this method:</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span>x = MaybeUninit::&lt;Vec&lt;u32&gt;&gt;::uninit();
<span class="kw">let </span>x_vec: <span class="kw-2">&amp;</span>Vec&lt;u32&gt; = <span class="kw">unsafe </span>{ x.assume_init_ref() };
<span class="comment">// We have created a reference to an uninitialized vector! This is undefined behavior. ⚠️</span></code></pre></div>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::{cell::Cell, mem::MaybeUninit};

<span class="kw">let </span>b = MaybeUninit::&lt;Cell&lt;bool&gt;&gt;::uninit();
<span class="comment">// Initialize the `MaybeUninit` using `Cell::set`:
</span><span class="kw">unsafe </span>{
    b.assume_init_ref().set(<span class="bool-val">true</span>);
    <span class="comment">//^^^^^^^^^^^^^^^ Reference to an uninitialized `Cell&lt;bool&gt;`: UB!
</span>}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.assume_init_mut" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.55.0, const since 1.84.0">1.55.0 (const: 1.84.0)</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#899">Source</a></span><h4 class="code-header">pub const unsafe fn <a href="#method.assume_init_mut" class="fn">assume_init_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class="docblock"><p>Gets a mutable (unique) reference to the contained value.</p>
<p>This can be useful when we want to access a <code>MaybeUninit</code> that has been
initialized but don’t have ownership of the <code>MaybeUninit</code> (preventing the use
of <code>.assume_init()</code>).</p>
<h5 id="safety-4"><a class="doc-anchor" href="#safety-4">§</a>Safety</h5>
<p>Calling this when the content is not yet fully initialized causes undefined
behavior: it is up to the caller to guarantee that the <code>MaybeUninit&lt;T&gt;</code> really
is in an initialized state. For instance, <code>.assume_init_mut()</code> cannot be used to
initialize a <code>MaybeUninit</code>.</p>
<h5 id="examples-7"><a class="doc-anchor" href="#examples-7">§</a>Examples</h5><h6 id="correct-usage-of-this-method-1"><a class="doc-anchor" href="#correct-usage-of-this-method-1">§</a>Correct usage of this method:</h6>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">extern </span><span class="string">"C" </span>{
    <span class="doccomment">/// Initializes *all* the bytes of the input buffer.
    </span><span class="kw">fn </span>initialize_buffer(buf: <span class="kw-2">*mut </span>[u8; <span class="number">1024</span>]);
}

<span class="kw">let </span><span class="kw-2">mut </span>buf = MaybeUninit::&lt;[u8; <span class="number">1024</span>]&gt;::uninit();

<span class="comment">// Initialize `buf`:
</span><span class="kw">unsafe </span>{ initialize_buffer(buf.as_mut_ptr()); }
<span class="comment">// Now we know that `buf` has been initialized, so we could `.assume_init()` it.
// However, using `.assume_init()` may trigger a `memcpy` of the 1024 bytes.
// To assert our buffer has been initialized without copying it, we upgrade
// the `&amp;mut MaybeUninit&lt;[u8; 1024]&gt;` to a `&amp;mut [u8; 1024]`:
</span><span class="kw">let </span>buf: <span class="kw-2">&amp;mut </span>[u8; <span class="number">1024</span>] = <span class="kw">unsafe </span>{
    <span class="comment">// SAFETY: `buf` has been initialized.
    </span>buf.assume_init_mut()
};

<span class="comment">// Now we can use `buf` as a normal slice:
</span>buf.sort_unstable();
<span class="macro">assert!</span>(
    buf.windows(<span class="number">2</span>).all(|pair| pair[<span class="number">0</span>] &lt;= pair[<span class="number">1</span>]),
    <span class="string">"buffer is sorted"</span>,
);</code></pre></div>
<h6 id="incorrect-usages-of-this-method-1"><a class="doc-anchor" href="#incorrect-usages-of-this-method-1">§</a><em>Incorrect</em> usages of this method:</h6>
<p>You cannot use <code>.assume_init_mut()</code> to initialize a value:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>b = MaybeUninit::&lt;bool&gt;::uninit();
<span class="kw">unsafe </span>{
    <span class="kw-2">*</span>b.assume_init_mut() = <span class="bool-val">true</span>;
    <span class="comment">// We have created a (mutable) reference to an uninitialized `bool`!
    // This is undefined behavior. ⚠️
</span>}</code></pre></div>
<p>For instance, you cannot <a href="../../std/io/trait.Read.html"><code>Read</code></a> into an uninitialized buffer:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::{io, mem::MaybeUninit};

<span class="kw">fn </span>read_chunk (reader: <span class="kw-2">&amp;</span><span class="lifetime">'_ </span><span class="kw-2">mut </span><span class="kw">dyn </span>io::Read) -&gt; io::Result&lt;[u8; <span class="number">64</span>]&gt;
{
    <span class="kw">let </span><span class="kw-2">mut </span>buffer = MaybeUninit::&lt;[u8; <span class="number">64</span>]&gt;::uninit();
    reader.read_exact(<span class="kw">unsafe </span>{ buffer.assume_init_mut() })<span class="question-mark">?</span>;
    <span class="comment">//                         ^^^^^^^^^^^^^^^^^^^^^^^^
    // (mutable) reference to uninitialized memory!
    // This is undefined behavior.
    </span><span class="prelude-val">Ok</span>(<span class="kw">unsafe </span>{ buffer.assume_init() })
}</code></pre></div>
<p>Nor can you use direct field access to do field-by-field gradual initialization:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::{mem::MaybeUninit, ptr};

<span class="kw">struct </span>Foo {
    a: u32,
    b: u8,
}

<span class="kw">let </span>foo: Foo = <span class="kw">unsafe </span>{
    <span class="kw">let </span><span class="kw-2">mut </span>foo = MaybeUninit::&lt;Foo&gt;::uninit();
    ptr::write(<span class="kw-2">&amp;mut </span>foo.assume_init_mut().a <span class="kw">as </span><span class="kw-2">*mut </span>u32, <span class="number">1337</span>);
    <span class="comment">//              ^^^^^^^^^^^^^^^^^^^^^
    // (mutable) reference to uninitialized memory!
    // This is undefined behavior.
    </span>ptr::write(<span class="kw-2">&amp;mut </span>foo.assume_init_mut().b <span class="kw">as </span><span class="kw-2">*mut </span>u8, <span class="number">42</span>);
    <span class="comment">//              ^^^^^^^^^^^^^^^^^^^^^
    // (mutable) reference to uninitialized memory!
    // This is undefined behavior.
    </span>foo.assume_init()
};</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.array_assume_init" class="method"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#936">Source</a><h4 class="code-header">pub const unsafe fn <a href="#method.array_assume_init" class="fn">array_assume_init</a>&lt;const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;(
    array: [<a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;T&gt;; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.array.html">N</a>],
) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.array.html">[T; N]</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_array_assume_init</code>)</span></div></span></summary><div class="docblock"><p>Extracts the values from an array of <code>MaybeUninit</code> containers.</p>
<h5 id="safety-5"><a class="doc-anchor" href="#safety-5">§</a>Safety</h5>
<p>It is up to the caller to guarantee that all elements of the array are
in an initialized state.</p>
<h5 id="examples-8"><a class="doc-anchor" href="#examples-8">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(maybe_uninit_array_assume_init)]
</span><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span><span class="kw-2">mut </span>array: [MaybeUninit&lt;i32&gt;; <span class="number">3</span>] = [MaybeUninit::uninit(); <span class="number">3</span>];
array[<span class="number">0</span>].write(<span class="number">0</span>);
array[<span class="number">1</span>].write(<span class="number">1</span>);
array[<span class="number">2</span>].write(<span class="number">2</span>);

<span class="comment">// SAFETY: Now safe as we initialised all elements
</span><span class="kw">let </span>array = <span class="kw">unsafe </span>{
    MaybeUninit::array_assume_init(array)
};

<span class="macro">assert_eq!</span>(array, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_bytes" class="method"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#966">Source</a><h4 class="code-header">pub const fn <a href="#method.as_bytes" class="fn">as_bytes</a>(&amp;self) -&gt; &amp;[<a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;] <a href="#" class="tooltip" data-notable-ty="&amp;[MaybeUninit&lt;u8&gt;]">ⓘ</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_as_bytes</code>)</span></div></span></summary><div class="docblock"><p>Returns the contents of this <code>MaybeUninit</code> as a slice of potentially uninitialized bytes.</p>
<p>Note that even if the contents of a <code>MaybeUninit</code> have been initialized, the value may still
contain padding bytes which are left uninitialized.</p>
<h5 id="examples-9"><a class="doc-anchor" href="#examples-9">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(maybe_uninit_as_bytes, maybe_uninit_slice)]
</span><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span>val = <span class="number">0x12345678_i32</span>;
<span class="kw">let </span>uninit = MaybeUninit::new(val);
<span class="kw">let </span>uninit_bytes = uninit.as_bytes();
<span class="kw">let </span>bytes = <span class="kw">unsafe </span>{ uninit_bytes.assume_init_ref() };
<span class="macro">assert_eq!</span>(bytes, val.to_ne_bytes());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_bytes_mut" class="method"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#997">Source</a><h4 class="code-header">pub const fn <a href="#method.as_bytes_mut" class="fn">as_bytes_mut</a>(&amp;mut self) -&gt; &amp;mut [<a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>&gt;] <a href="#" class="tooltip" data-notable-ty="&amp;mut [MaybeUninit&lt;u8&gt;]">ⓘ</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_as_bytes</code>)</span></div></span></summary><div class="docblock"><p>Returns the contents of this <code>MaybeUninit</code> as a mutable slice of potentially uninitialized
bytes.</p>
<p>Note that even if the contents of a <code>MaybeUninit</code> have been initialized, the value may still
contain padding bytes which are left uninitialized.</p>
<h5 id="examples-10"><a class="doc-anchor" href="#examples-10">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(maybe_uninit_as_bytes)]
</span><span class="kw">use </span>std::mem::MaybeUninit;

<span class="kw">let </span>val = <span class="number">0x12345678_i32</span>;
<span class="kw">let </span><span class="kw-2">mut </span>uninit = MaybeUninit::new(val);
<span class="kw">let </span>uninit_bytes = uninit.as_bytes_mut();
<span class="kw">if </span><span class="macro">cfg!</span>(target_endian = <span class="string">"little"</span>) {
    uninit_bytes[<span class="number">0</span>].write(<span class="number">0xcd</span>);
} <span class="kw">else </span>{
    uninit_bytes[<span class="number">3</span>].write(<span class="number">0xcd</span>);
}
<span class="kw">let </span>val2 = <span class="kw">unsafe </span>{ uninit.assume_init() };
<span class="macro">assert_eq!</span>(val2, <span class="number">0x123456cd</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.slice_as_ptr" class="method"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#1010">Source</a><h4 class="code-header">pub const fn <a href="#method.slice_as_ptr" class="fn">slice_as_ptr</a>(this: &amp;[<a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;T&gt;]) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*const T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_slice</code>)</span></div></span></summary><div class="docblock"><p>Gets a pointer to the first element of the array.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.slice_as_mut_ptr" class="method"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#1017">Source</a><h4 class="code-header">pub const fn <a href="#method.slice_as_mut_ptr" class="fn">slice_as_mut_ptr</a>(this: &amp;mut [<a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;T&gt;]) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut T</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_slice</code>)</span></div></span></summary><div class="docblock"><p>Gets a mutable pointer to the first element of the array.</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-MaybeUninit%3C%5BT;+N%5D%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#1436">Source</a><a href="#impl-MaybeUninit%3C%5BT;+N%5D%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, const N: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.array.html">[T; N]</a>&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.transpose" class="method"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#1449">Source</a><h4 class="code-header">pub const fn <a href="#method.transpose" class="fn">transpose</a>(self) -&gt; [<a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;T&gt;; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.array.html">N</a>]</h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>maybe_uninit_uninit_array_transpose</code>)</span></div></span></summary><div class="docblock"><p>Transposes a <code>MaybeUninit&lt;[T; N]&gt;</code> into a <code>[MaybeUninit&lt;T&gt;; N]</code>.</p>
<h5 id="examples-11"><a class="doc-anchor" href="#examples-11">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(maybe_uninit_uninit_array_transpose)]

</span><span class="kw">let </span>data: [MaybeUninit&lt;u8&gt;; <span class="number">1000</span>] = MaybeUninit::uninit().transpose();</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Box%3CMaybeUninit%3CT%3E,+A%3E" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/boxed.rs.html#900">Source</a><a href="#impl-Box%3CMaybeUninit%3CT%3E,+A%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T, A&gt; <a class="struct" href="struct.Box.html" title="struct devela::all::Box">Box</a>&lt;<a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;T&gt;, A&gt;<div class="where">where
    A: <a class="trait" href="../_core/alloc/trait.Allocator.html" title="trait devela::_core::alloc::Allocator">Allocator</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.assume_init-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.82.0">1.82.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/alloc/boxed.rs.html#925">Source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.assume_init-1" class="fn">assume_init</a>(self) -&gt; <a class="struct" href="struct.Box.html" title="struct devela::all::Box">Box</a>&lt;T, A&gt;</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>alloc</code></strong> only.</div></span></summary><div class="docblock"><p>Converts to <code>Box&lt;T, A&gt;</code>.</p>
<h5 id="safety-6"><a class="doc-anchor" href="#safety-6">§</a>Safety</h5>
<p>As with <a href="union.MaybeUninit.html#method.assume_init" title="method devela::all::MaybeUninit::assume_init"><code>MaybeUninit::assume_init</code></a>,
it is up to the caller to guarantee that the value
really is in an initialized state.
Calling this when the content is not yet fully initialized
causes immediate undefined behavior.</p>
<h5 id="examples-12"><a class="doc-anchor" href="#examples-12">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>five = Box::&lt;u32&gt;::new_uninit();
<span class="comment">// Deferred initialization:
</span>five.write(<span class="number">5</span>);
<span class="kw">let </span>five: Box&lt;u32&gt; = <span class="kw">unsafe </span>{ five.assume_init() };

<span class="macro">assert_eq!</span>(<span class="kw-2">*</span>five, <span class="number">5</span>)</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write-1" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.87.0">1.87.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/alloc/boxed.rs.html#957">Source</a></span><h4 class="code-header">pub fn <a href="#method.write-1" class="fn">write</a>(boxed: <a class="struct" href="struct.Box.html" title="struct devela::all::Box">Box</a>&lt;<a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;T&gt;, A&gt;, value: T) -&gt; <a class="struct" href="struct.Box.html" title="struct devela::all::Box">Box</a>&lt;T, A&gt;</h4></section><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>alloc</code></strong> only.</div></span></summary><div class="docblock"><p>Writes the value and converts to <code>Box&lt;T, A&gt;</code>.</p>
<p>This method converts the box similarly to <a href="struct.Box.html#method.assume_init" title="method devela::all::Box::assume_init"><code>Box::assume_init</code></a> but
writes <code>value</code> into it before conversion thus guaranteeing safety.
In some scenarios use of this method may improve performance because
the compiler may be able to optimize copying from stack.</p>
<h5 id="examples-13"><a class="doc-anchor" href="#examples-13">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>big_box = Box::&lt;[usize; <span class="number">1024</span>]&gt;::new_uninit();

<span class="kw">let </span><span class="kw-2">mut </span>array = [<span class="number">0</span>; <span class="number">1024</span>];
<span class="kw">for </span>(i, place) <span class="kw">in </span>array.iter_mut().enumerate() {
    <span class="kw-2">*</span>place = i;
}

<span class="comment">// The optimizer may be able to elide this copy, so previous code writes
// to heap directly.
</span><span class="kw">let </span>big_box = Box::write(big_box, array);

<span class="kw">for </span>(i, x) <span class="kw">in </span>big_box.iter().enumerate() {
    <span class="macro">assert_eq!</span>(<span class="kw-2">*</span>x, i);
}</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-MaybeUninit%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#267">Source</a></span><a href="#impl-Clone-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../code/trait.Clone.html" title="trait devela::code::Clone">Clone</a> for <a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="trait.Copy.html" title="trait devela::all::Copy">Copy</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#269">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="../code/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="../code/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#246-248">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="../code/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="../code/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-MaybeUninit%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.41.0">1.41.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#276">Source</a></span><a href="#impl-Debug-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="trait.Debug.html" title="trait devela::all::Debug">Debug</a> for <a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#277">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="struct.Formatter.html" title="struct devela::all::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="enum.Result.html" title="enum devela::all::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.FmtError.html" title="struct devela::all::FmtError">Error</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;(), Error&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-MemPod-for-MaybeUninit%3CT%3E" class="impl"><a class="src rightside" href="../../src/devela/sys/mem/pod.rs.html#141">Source</a><a href="#impl-MemPod-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T: <a class="trait" href="trait.MemPod.html" title="trait devela::all::MemPod">MemPod</a>&gt; <a class="trait" href="trait.MemPod.html" title="trait devela::all::MemPod">MemPod</a> for <a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h3><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>unsafe_layout</code></strong> only.</div></span></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.zeroed-2" class="method trait-impl"><a class="src rightside" href="../../src/devela/sys/mem/pod.rs.html#72-75">Source</a><a href="#method.zeroed-2" class="anchor">§</a><h4 class="code-header">fn <a href="trait.MemPod.html#method.zeroed" class="fn">zeroed</a>() -&gt; Self</h4></section></summary><div class='docblock'>Returns a new instance contrcuted from zeroes.</div></details><details class="toggle method-toggle" open><summary><section id="method.from_bytes" class="method trait-impl"><a class="src rightside" href="../../src/devela/sys/mem/pod.rs.html#81-105">Source</a><a href="#method.from_bytes" class="anchor">§</a><h4 class="code-header">fn <a href="trait.MemPod.html#method.from_bytes" class="fn">from_bytes</a>(bytes: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]) -&gt; Self</h4></section></summary><div class='docblock'>Returns a new instance constructed from the given bytes. <a href="trait.MemPod.html#method.from_bytes">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.as_bytes-1" class="method trait-impl"><a class="src rightside" href="../../src/devela/sys/mem/pod.rs.html#109-113">Source</a><a href="#method.as_bytes-1" class="anchor">§</a><h4 class="code-header">fn <a href="trait.MemPod.html#method.as_bytes" class="fn">as_bytes</a>(&amp;self) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a></h4></section></summary><div class='docblock'>Returns the instance’s data as a slice of bytes.</div></details><details class="toggle method-toggle" open><summary><section id="method.as_bytes_mut-1" class="method trait-impl"><a class="src rightside" href="../../src/devela/sys/mem/pod.rs.html#117-121">Source</a><a href="#method.as_bytes_mut-1" class="anchor">§</a><h4 class="code-header">fn <a href="trait.MemPod.html#method.as_bytes_mut" class="fn">as_bytes_mut</a>(&amp;mut self) -&gt; &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;mut [u8]">ⓘ</a></h4></section></summary><div class='docblock'>Returns the instance’s data as a mutable slice of bytes.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Zeroable-for-MaybeUninit%3CT%3E" class="impl"><a href="#impl-Zeroable-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../_dep/bytemuck/trait.Zeroable.html" title="trait devela::_dep::bytemuck::Zeroable">Zeroable</a> for <a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;T&gt;</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.zeroed-1" class="method trait-impl"><a href="#method.zeroed-1" class="anchor">§</a><h4 class="code-header">fn <a href="../_dep/bytemuck/trait.Zeroable.html#method.zeroed" class="fn">zeroed</a>() -&gt; Self</h4></section></summary><div class='docblock'>Calls <a href="../_core/mem/fn.zeroed.html" title="fn devela::_core::mem::zeroed"><code>zeroed</code></a>. <a href="../_dep/bytemuck/trait.Zeroable.html#method.zeroed">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Zeroize-for-MaybeUninit%3CZ%3E" class="impl"><a href="#impl-Zeroize-for-MaybeUninit%3CZ%3E" class="anchor">§</a><h3 class="code-header">impl&lt;Z&gt; Zeroize for <a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;Z&gt;</h3><div class="docblock"><p>Impl [<code>Zeroize</code>] on <a href="union.MaybeUninit.html" title="union devela::all::MaybeUninit"><code>MaybeUninit</code></a> types.</p>
</div></section></summary><div class="docblock"><p>This fills the memory with zeroes.
Note that this ignore invariants that <code>Z</code> might have, because
<a href="union.MaybeUninit.html" title="union devela::all::MaybeUninit"><code>MaybeUninit</code></a> removes all invariants.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.zeroize" class="method trait-impl"><a href="#method.zeroize" class="anchor">§</a><h4 class="code-header">fn <a class="fn">zeroize</a>(&amp;mut self)</h4></section></summary><div class='docblock'>Zero out this object from memory using Rust intrinsics which ensure the
zeroization operation is not “optimized away” by the compiler.</div></details></div></details><section id="impl-AnyBitPattern-for-MaybeUninit%3CT%3E" class="impl"><a href="#impl-AnyBitPattern-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../_dep/bytemuck/trait.AnyBitPattern.html" title="trait devela::_dep::bytemuck::AnyBitPattern">AnyBitPattern</a> for <a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="../_dep/bytemuck/trait.AnyBitPattern.html" title="trait devela::_dep::bytemuck::AnyBitPattern">AnyBitPattern</a>,</div></h3></section><section id="impl-Copy-for-MaybeUninit%3CT%3E" class="impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.36.0">1.36.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/mem/maybe_uninit.rs.html#258">Source</a></span><a href="#impl-Copy-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="trait.Copy.html" title="trait devela::all::Copy">Copy</a> for <a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="trait.Copy.html" title="trait devela::all::Copy">Copy</a>,</div></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-MaybeUninit%3CT%3E" class="impl"><a href="#impl-Freeze-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../_core/marker/trait.Freeze.html" title="trait devela::_core::marker::Freeze">Freeze</a> for <a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="../_core/marker/trait.Freeze.html" title="trait devela::_core::marker::Freeze">Freeze</a>,</div></h3></section><section id="impl-RefUnwindSafe-for-MaybeUninit%3CT%3E" class="impl"><a href="#impl-RefUnwindSafe-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="trait.PanicRefUnwindSafe.html" title="trait devela::all::PanicRefUnwindSafe">RefUnwindSafe</a> for <a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="trait.PanicRefUnwindSafe.html" title="trait devela::all::PanicRefUnwindSafe">RefUnwindSafe</a>,</div></h3></section><section id="impl-Send-for-MaybeUninit%3CT%3E" class="impl"><a href="#impl-Send-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="trait.Send.html" title="trait devela::all::Send">Send</a> for <a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="trait.Send.html" title="trait devela::all::Send">Send</a>,</div></h3></section><section id="impl-Sync-for-MaybeUninit%3CT%3E" class="impl"><a href="#impl-Sync-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="trait.Sync.html" title="trait devela::all::Sync">Sync</a> for <a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="trait.Sync.html" title="trait devela::all::Sync">Sync</a>,</div></h3></section><section id="impl-Unpin-for-MaybeUninit%3CT%3E" class="impl"><a href="#impl-Unpin-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="trait.Unpin.html" title="trait devela::all::Unpin">Unpin</a> for <a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="trait.Unpin.html" title="trait devela::all::Unpin">Unpin</a>,</div></h3></section><section id="impl-UnwindSafe-for-MaybeUninit%3CT%3E" class="impl"><a href="#impl-UnwindSafe-for-MaybeUninit%3CT%3E" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="trait.PanicUnwindSafe.html" title="trait devela::all::PanicUnwindSafe">UnwindSafe</a> for <a class="union" href="union.MaybeUninit.html" title="union devela::all::MaybeUninit">MaybeUninit</a>&lt;T&gt;<div class="where">where
    T: <a class="trait" href="trait.PanicUnwindSafe.html" title="trait devela::all::PanicUnwindSafe">UnwindSafe</a>,</div></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../code/trait.Any.html" title="trait devela::code::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#139">Source</a><a href="#method.type_id-1" class="anchor">§</a><h4 class="code-header">fn <a href="../code/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="../code/struct.TypeId.html" title="struct devela::code::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="../code/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="trait.Borrow.html" title="trait devela::all::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="trait.BorrowMut.html" title="trait devela::all::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ByteSized-for-T" class="impl"><a class="src rightside" href="../../src/devela/sys/mem/size/byte.rs.html#8">Source</a><a href="#impl-ByteSized-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="trait.ByteSized.html" title="trait devela::all::ByteSized">ByteSized</a> for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.BYTE_ALIGN" class="associatedconstant trait-impl"><a class="src rightside" href="../../src/devela/sys/mem/size/byte.rs.html#16">Source</a><a href="#associatedconstant.BYTE_ALIGN" class="anchor">§</a><h4 class="code-header">const <a href="trait.ByteSized.html#associatedconstant.BYTE_ALIGN" class="constant">BYTE_ALIGN</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a> = _</h4></section></summary><div class='docblock'>The alignment of this type in bytes.</div></details><details class="toggle" open><summary><section id="associatedconstant.BYTE_SIZE" class="associatedconstant trait-impl"><a class="src rightside" href="../../src/devela/sys/mem/size/byte.rs.html#18">Source</a><a href="#associatedconstant.BYTE_SIZE" class="anchor">§</a><h4 class="code-header">const <a href="trait.ByteSized.html#associatedconstant.BYTE_SIZE" class="constant">BYTE_SIZE</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a> = _</h4></section></summary><div class='docblock'>The size of this type in bytes.</div></details><details class="toggle method-toggle" open><summary><section id="method.byte_align" class="method trait-impl"><a class="src rightside" href="../../src/devela/sys/mem/size/byte.rs.html#21-23">Source</a><a href="#method.byte_align" class="anchor">§</a><h4 class="code-header">fn <a href="trait.ByteSized.html#method.byte_align" class="fn">byte_align</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the alignment of this type in bytes.</div></details><details class="toggle method-toggle" open><summary><section id="method.byte_size" class="method trait-impl"><a class="src rightside" href="../../src/devela/sys/mem/size/byte.rs.html#28-30">Source</a><a href="#method.byte_size" class="anchor">§</a><h4 class="code-header">fn <a href="trait.ByteSized.html#method.byte_size" class="fn">byte_size</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the size of this type in bytes. <a href="trait.ByteSized.html#method.byte_size">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ptr_size_ratio" class="method trait-impl"><a class="src rightside" href="../../src/devela/sys/mem/size/byte.rs.html#61-63">Source</a><a href="#method.ptr_size_ratio" class="anchor">§</a><h4 class="code-header">fn <a href="trait.ByteSized.html#method.ptr_size_ratio" class="fn">ptr_size_ratio</a>(&amp;self) -&gt; [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.array.html">2</a>]</h4></section></summary><div class='docblock'>Returns the size ratio between <a href="struct.Ptr.html#associatedconstant.BYTES" title="associated constant devela::all::Ptr::BYTES"><code>Ptr::BYTES</code></a>
and <a href="trait.ByteSized.html#associatedconstant.BYTE_SIZE" title="trait devela::all::ByteSized"><code>BYTE_SIZE</code></a>. <a href="trait.ByteSized.html#method.ptr_size_ratio">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Chain%3CR%3E-for-T" class="impl"><a class="src rightside" href="../../src/devela/code/result/chain_hook.rs.html#62">Source</a><a href="#impl-Chain%3CR%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, R&gt; <a class="trait" href="trait.Chain.html" title="trait devela::all::Chain">Chain</a>&lt;R&gt; for T<div class="where">where
    T: ?<a class="trait" href="trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.chain" class="method trait-impl"><a class="src rightside" href="../../src/devela/code/result/chain_hook.rs.html#36-42">Source</a><a href="#method.chain" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Chain.html#method.chain" class="fn">chain</a>&lt;F&gt;(self, f: F) -&gt; R<div class="where">where
    F: <a class="trait" href="trait.FnOnce.html" title="trait devela::all::FnOnce">FnOnce</a>(Self) -&gt; R,
    Self: <a class="trait" href="trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Chain a function which takes the parameter by value.</div></details><details class="toggle method-toggle" open><summary><section id="method.chain_ref" class="method trait-impl"><a class="src rightside" href="../../src/devela/code/result/chain_hook.rs.html#46-51">Source</a><a href="#method.chain_ref" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Chain.html#method.chain_ref" class="fn">chain_ref</a>&lt;F&gt;(&amp;self, f: F) -&gt; R<div class="where">where
    F: <a class="trait" href="trait.FnOnce.html" title="trait devela::all::FnOnce">FnOnce</a>(&amp;Self) -&gt; R,</div></h4></section></summary><div class='docblock'>Chain a function which takes the parameter by shared reference.</div></details><details class="toggle method-toggle" open><summary><section id="method.chain_mut" class="method trait-impl"><a class="src rightside" href="../../src/devela/code/result/chain_hook.rs.html#55-60">Source</a><a href="#method.chain_mut" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Chain.html#method.chain_mut" class="fn">chain_mut</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; R<div class="where">where
    F: <a class="trait" href="trait.FnOnce.html" title="trait devela::all::FnOnce">FnOnce</a>(&amp;mut Self) -&gt; R,</div></h4></section></summary><div class='docblock'>Chain a function which takes the parameter by exclusive reference.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CheckedBitPattern-for-T" class="impl"><a href="#impl-CheckedBitPattern-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../_dep/bytemuck/trait.CheckedBitPattern.html" title="trait devela::_dep::bytemuck::CheckedBitPattern">CheckedBitPattern</a> for T<div class="where">where
    T: <a class="trait" href="../_dep/bytemuck/trait.AnyBitPattern.html" title="trait devela::_dep::bytemuck::AnyBitPattern">AnyBitPattern</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Bits" class="associatedtype trait-impl"><a href="#associatedtype.Bits" class="anchor">§</a><h4 class="code-header">type <a href="../_dep/bytemuck/trait.CheckedBitPattern.html#associatedtype.Bits" class="associatedtype">Bits</a> = T</h4></section></summary><div class='docblock'><code>Self</code> <em>must</em> have the same layout as the specified <code>Bits</code> except for
the possible invalid bit patterns being checked during
<a href="../_dep/bytemuck/trait.CheckedBitPattern.html#tymethod.is_valid_bit_pattern" title="associated function devela::_dep::bytemuck::CheckedBitPattern::is_valid_bit_pattern"><code>is_valid_bit_pattern</code></a>.</div></details><details class="toggle method-toggle" open><summary><section id="method.is_valid_bit_pattern" class="method trait-impl"><a href="#method.is_valid_bit_pattern" class="anchor">§</a><h4 class="code-header">fn <a href="../_dep/bytemuck/trait.CheckedBitPattern.html#tymethod.is_valid_bit_pattern" class="fn">is_valid_bit_pattern</a>(_bits: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>If this function returns true, then it must be valid to reinterpret <code>bits</code>
as <code>&amp;Self</code>.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#516">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../_core/clone/trait.CloneToUninit.html" title="trait devela::_core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="../code/trait.Clone.html" title="trait devela::code::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#518">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="../_core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="../_core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ExtAny-for-T" class="impl"><a class="src rightside" href="../../src/devela/code/any/ext.rs.html#17">Source</a><a href="#impl-ExtAny-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../code/trait.ExtAny.html" title="trait devela::code::ExtAny">ExtAny</a> for T<div class="where">where
    T: <a class="trait" href="../code/trait.Any.html" title="trait devela::code::Any">Any</a> + ?<a class="trait" href="trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="../../src/devela/code/any/ext.rs.html#39">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="../code/trait.ExtAny.html#method.type_id" class="fn">type_id</a>() -&gt; <a class="struct" href="../code/struct.TypeId.html" title="struct devela::code::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Returns the <code>TypeId</code> of <code>Self</code>. <a href="../code/trait.ExtAny.html#method.type_id">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.type_of" class="method trait-impl"><a class="src rightside" href="../../src/devela/code/any/ext.rs.html#51">Source</a><a href="#method.type_of" class="anchor">§</a><h4 class="code-header">fn <a href="../code/trait.ExtAny.html#method.type_of" class="fn">type_of</a>(&amp;self) -&gt; <a class="struct" href="../code/struct.TypeId.html" title="struct devela::code::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Returns the <code>TypeId</code> of <code>self</code>. <a href="../code/trait.ExtAny.html#method.type_of">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.type_name" class="method trait-impl"><a class="src rightside" href="../../src/devela/code/any/ext.rs.html#65">Source</a><a href="#method.type_name" class="anchor">§</a><h4 class="code-header">fn <a href="../code/trait.ExtAny.html#method.type_name" class="fn">type_name</a>(&amp;self) -&gt; &amp;'static <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <a href="#" class="tooltip" data-notable-ty="&amp;&#39;static str">ⓘ</a></h4></section></summary><div class='docblock'>Returns the type name of <code>self</code>. <a href="../code/trait.ExtAny.html#method.type_name">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.type_is" class="method trait-impl"><a class="src rightside" href="../../src/devela/code/any/ext.rs.html#84">Source</a><a href="#method.type_is" class="anchor">§</a><h4 class="code-header">fn <a href="../code/trait.ExtAny.html#method.type_is" class="fn">type_is</a>&lt;T: 'static&gt;(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns <code>true</code> if <code>Self</code> is of type <code>T</code>. <a href="../code/trait.ExtAny.html#method.type_is">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.type_hash" class="method trait-impl"><a class="src rightside" href="../../src/devela/code/any/ext.rs.html#87-90">Source</a><a href="#method.type_hash" class="anchor">§</a><h4 class="code-header">fn <a href="../code/trait.ExtAny.html#method.type_hash" class="fn">type_hash</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a></h4></section></summary><div class='docblock'>Returns a deterministic hash of the <code>TypeId</code> of <code>Self</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.type_hash_with" class="method trait-impl"><a class="src rightside" href="../../src/devela/code/any/ext.rs.html#93-96">Source</a><a href="#method.type_hash_with" class="anchor">§</a><h4 class="code-header">fn <a href="../code/trait.ExtAny.html#method.type_hash_with" class="fn">type_hash_with</a>&lt;H: <a class="trait" href="trait.Hasher.html" title="trait devela::all::Hasher">Hasher</a>&gt;(&amp;self, hasher: H) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a></h4></section></summary><div class='docblock'>Returns a deterministic hash of the <code>TypeId</code> of <code>Self</code> using a custom hasher.</div></details><details class="toggle method-toggle" open><summary><section id="method.as_any_ref" class="method trait-impl"><a class="src rightside" href="../../src/devela/code/any/ext.rs.html#111">Source</a><a href="#method.as_any_ref" class="anchor">§</a><h4 class="code-header">fn <a href="../code/trait.ExtAny.html#method.as_any_ref" class="fn">as_any_ref</a>(&amp;self) -&gt; &amp;dyn <a class="trait" href="../code/trait.Any.html" title="trait devela::code::Any">Any</a><div class="where">where
    Self: <a class="trait" href="trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Upcasts <code>&amp;self</code> as <code>&amp;dyn Any</code>. <a href="../code/trait.ExtAny.html#method.as_any_ref">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.as_any_mut" class="method trait-impl"><a class="src rightside" href="../../src/devela/code/any/ext.rs.html#124">Source</a><a href="#method.as_any_mut" class="anchor">§</a><h4 class="code-header">fn <a href="../code/trait.ExtAny.html#method.as_any_mut" class="fn">as_any_mut</a>(&amp;mut self) -&gt; &amp;mut dyn <a class="trait" href="../code/trait.Any.html" title="trait devela::code::Any">Any</a><div class="where">where
    Self: <a class="trait" href="trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Upcasts <code>&amp;mut self</code> as <code>&amp;mut dyn Any</code>. <a href="../code/trait.ExtAny.html#method.as_any_mut">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.as_any_box" class="method trait-impl"><a class="src rightside" href="../../src/devela/code/any/ext.rs.html#138">Source</a><a href="#method.as_any_box" class="anchor">§</a><h4 class="code-header">fn <a href="../code/trait.ExtAny.html#method.as_any_box" class="fn">as_any_box</a>(self: <a class="struct" href="struct.Box.html" title="struct devela::all::Box">Box</a>&lt;Self&gt;) -&gt; <a class="struct" href="struct.Box.html" title="struct devela::all::Box">Box</a>&lt;dyn <a class="trait" href="../code/trait.Any.html" title="trait devela::code::Any">Any</a>&gt;<div class="where">where
    Self: <a class="trait" href="trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Upcasts <code>Box&lt;self&gt;</code> as <code>Box&lt;dyn Any&gt;</code>. <a href="../code/trait.ExtAny.html#method.as_any_box">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.downcast_ref" class="method trait-impl"><a class="src rightside" href="../../src/devela/code/any/ext.rs.html#196-199">Source</a><a href="#method.downcast_ref" class="anchor">§</a><h4 class="code-header">fn <a href="../code/trait.ExtAny.html#method.downcast_ref" class="fn">downcast_ref</a>&lt;T: 'static&gt;(&amp;self) -&gt; <a class="enum" href="enum.Option.html" title="enum devela::all::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a>&gt; <a href="#" class="tooltip" data-notable-ty="Option&lt;&amp;T&gt;">ⓘ</a></h4></section></summary><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>unsafe_layout</code> and non-crate feature <code>safe_code</code></strong> only.</div></span><div class='docblock'>Returns some shared reference to the inner value if it is of type <code>T</code>. <a href="../code/trait.ExtAny.html#method.downcast_ref">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.downcast_mut" class="method trait-impl"><a class="src rightside" href="../../src/devela/code/any/ext.rs.html#208-211">Source</a><a href="#method.downcast_mut" class="anchor">§</a><h4 class="code-header">fn <a href="../code/trait.ExtAny.html#method.downcast_mut" class="fn">downcast_mut</a>&lt;T: 'static&gt;(&amp;mut self) -&gt; <a class="enum" href="enum.Option.html" title="enum devela::all::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>&gt; <a href="#" class="tooltip" data-notable-ty="Option&lt;&amp;mut T&gt;">ⓘ</a></h4></section></summary><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>unsafe_layout</code> and non-crate feature <code>safe_code</code></strong> only.</div></span><div class='docblock'>Returns some exclusive reference to the inner value if it is of type <code>T</code>. <a href="../code/trait.ExtAny.html#method.downcast_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ExtMem-for-T" class="impl"><a class="src rightside" href="../../src/devela/sys/mem/ext.rs.html#8">Source</a><a href="#impl-ExtMem-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="trait.ExtMem.html" title="trait devela::all::ExtMem">ExtMem</a> for T<div class="where">where
    T: ?<a class="trait" href="trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.NEEDS_DROP" class="associatedconstant trait-impl"><a class="src rightside" href="../../src/devela/sys/mem/ext.rs.html#18">Source</a><a href="#associatedconstant.NEEDS_DROP" class="anchor">§</a><h4 class="code-header">const <a href="trait.ExtMem.html#associatedconstant.NEEDS_DROP" class="constant">NEEDS_DROP</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> = _</h4></section></summary><div class='docblock'>Know whether dropping values of this type matters, in compile-time.</div></details><details class="toggle method-toggle" open><summary><section id="method.mem_align_of" class="method trait-impl"><a class="src rightside" href="../../src/devela/sys/mem/ext.rs.html#24">Source</a><a href="#method.mem_align_of" class="anchor">§</a><h4 class="code-header">fn <a href="trait.ExtMem.html#method.mem_align_of" class="fn">mem_align_of</a>&lt;T&gt;() -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the minimum alignment of the type in bytes. <a href="trait.ExtMem.html#method.mem_align_of">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_align_of_val" class="method trait-impl"><a class="src rightside" href="../../src/devela/sys/mem/ext.rs.html#30">Source</a><a href="#method.mem_align_of_val" class="anchor">§</a><h4 class="code-header">fn <a href="trait.ExtMem.html#method.mem_align_of_val" class="fn">mem_align_of_val</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the alignment of the pointed-to value in bytes. <a href="trait.ExtMem.html#method.mem_align_of_val">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_size_of" class="method trait-impl"><a class="src rightside" href="../../src/devela/sys/mem/ext.rs.html#36">Source</a><a href="#method.mem_size_of" class="anchor">§</a><h4 class="code-header">fn <a href="trait.ExtMem.html#method.mem_size_of" class="fn">mem_size_of</a>&lt;T&gt;() -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the size of a type in bytes. <a href="trait.ExtMem.html#method.mem_size_of">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_size_of_val" class="method trait-impl"><a class="src rightside" href="../../src/devela/sys/mem/ext.rs.html#42">Source</a><a href="#method.mem_size_of_val" class="anchor">§</a><h4 class="code-header">fn <a href="trait.ExtMem.html#method.mem_size_of_val" class="fn">mem_size_of_val</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the size of the pointed-to value in bytes. <a href="trait.ExtMem.html#method.mem_size_of_val">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_copy" class="method trait-impl"><a class="src rightside" href="../../src/devela/sys/mem/ext.rs.html#51">Source</a><a href="#method.mem_copy" class="anchor">§</a><h4 class="code-header">fn <a href="trait.ExtMem.html#method.mem_copy" class="fn">mem_copy</a>(&amp;self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="trait.Copy.html" title="trait devela::all::Copy">Copy</a>,</div></h4></section></summary><div class='docblock'>Bitwise-copies a value. <a href="trait.ExtMem.html#method.mem_copy">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_needs_drop" class="method trait-impl"><a class="src rightside" href="../../src/devela/sys/mem/ext.rs.html#57">Source</a><a href="#method.mem_needs_drop" class="anchor">§</a><h4 class="code-header">fn <a href="trait.ExtMem.html#method.mem_needs_drop" class="fn">mem_needs_drop</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns <code>true</code> if dropping values of this type matters. <a href="trait.ExtMem.html#method.mem_needs_drop">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_drop" class="method trait-impl"><a class="src rightside" href="../../src/devela/sys/mem/ext.rs.html#62">Source</a><a href="#method.mem_drop" class="anchor">§</a><h4 class="code-header">fn <a href="trait.ExtMem.html#method.mem_drop" class="fn">mem_drop</a>(self)<div class="where">where
    Self: <a class="trait" href="trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Drops <code>self</code> by running its destructor. <a href="trait.ExtMem.html#method.mem_drop">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_forget" class="method trait-impl"><a class="src rightside" href="../../src/devela/sys/mem/ext.rs.html#67">Source</a><a href="#method.mem_forget" class="anchor">§</a><h4 class="code-header">fn <a href="trait.ExtMem.html#method.mem_forget" class="fn">mem_forget</a>(self)<div class="where">where
    Self: <a class="trait" href="trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Forgets about <code>self</code> <em>without running its destructor</em>. <a href="trait.ExtMem.html#method.mem_forget">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_replace" class="method trait-impl"><a class="src rightside" href="../../src/devela/sys/mem/ext.rs.html#73">Source</a><a href="#method.mem_replace" class="anchor">§</a><h4 class="code-header">fn <a href="trait.ExtMem.html#method.mem_replace" class="fn">mem_replace</a>(&amp;mut self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Replaces <code>self</code> with other, returning the previous value of <code>self</code>. <a href="trait.ExtMem.html#method.mem_replace">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_take" class="method trait-impl"><a class="src rightside" href="../../src/devela/sys/mem/ext.rs.html#79">Source</a><a href="#method.mem_take" class="anchor">§</a><h4 class="code-header">fn <a href="trait.ExtMem.html#method.mem_take" class="fn">mem_take</a>(&amp;mut self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="../code/trait.Default.html" title="trait devela::code::Default">Default</a>,</div></h4></section></summary><div class='docblock'>Replaces <code>self</code> with its default value, returning the previous value of <code>self</code>. <a href="trait.ExtMem.html#method.mem_take">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_swap" class="method trait-impl"><a class="src rightside" href="../../src/devela/sys/mem/ext.rs.html#84">Source</a><a href="#method.mem_swap" class="anchor">§</a><h4 class="code-header">fn <a href="trait.ExtMem.html#method.mem_swap" class="fn">mem_swap</a>(&amp;mut self, other: &amp;mut Self)<div class="where">where
    Self: <a class="trait" href="trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Swaps the value of <code>self</code> and <code>other</code> without deinitializing either one. <a href="trait.ExtMem.html#method.mem_swap">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_zeroed" class="method trait-impl"><a class="src rightside" href="../../src/devela/sys/mem/ext.rs.html#93">Source</a><a href="#method.mem_zeroed" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="trait.ExtMem.html#method.mem_zeroed" class="fn">mem_zeroed</a>&lt;T&gt;() -&gt; T</h4></section></summary><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>unsafe_layout</code></strong> only.</div></span><div class='docblock'>Returns the value of type <code>T</code> represented by the all-zero byte-pattern. <a href="trait.ExtMem.html#method.mem_zeroed">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_transmute_copy" class="method trait-impl"><a class="src rightside" href="../../src/devela/sys/mem/ext.rs.html#102-104">Source</a><a href="#method.mem_transmute_copy" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="trait.ExtMem.html#method.mem_transmute_copy" class="fn">mem_transmute_copy</a>&lt;Src, Dst&gt;(src: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Src</a>) -&gt; Dst</h4></section></summary><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>unsafe_layout</code></strong> only.</div></span><div class='docblock'>Returns the value of type <code>T</code> represented by the all-zero byte-pattern. <a href="trait.ExtMem.html#method.mem_transmute_copy">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_as_bytes" class="method trait-impl"><a class="src rightside" href="../../src/devela/sys/mem/ext.rs.html#113">Source</a><a href="#method.mem_as_bytes" class="anchor">§</a><h4 class="code-header">fn <a href="trait.ExtMem.html#method.mem_as_bytes" class="fn">mem_as_bytes</a>(&amp;self) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a><div class="where">where
    Self: <a class="trait" href="trait.Sync.html" title="trait devela::all::Sync">Sync</a> + <a class="trait" href="trait.Unpin.html" title="trait devela::all::Unpin">Unpin</a>,</div></h4></section></summary><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>unsafe_slice</code></strong> only.</div></span><div class='docblock'>View a <code>Sync + Unpin</code> <code>self</code> as <code>&amp;[u8]</code>. <a href="trait.ExtMem.html#method.mem_as_bytes">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_as_bytes_mut" class="method trait-impl"><a class="src rightside" href="../../src/devela/sys/mem/ext.rs.html#121">Source</a><a href="#method.mem_as_bytes_mut" class="anchor">§</a><h4 class="code-header">fn <a href="trait.ExtMem.html#method.mem_as_bytes_mut" class="fn">mem_as_bytes_mut</a>(&amp;mut self) -&gt; &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;mut [u8]">ⓘ</a><div class="where">where
    Self: <a class="trait" href="trait.Sync.html" title="trait devela::all::Sync">Sync</a> + <a class="trait" href="trait.Unpin.html" title="trait devela::all::Unpin">Unpin</a>,</div></h4></section></summary><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>unsafe_slice</code></strong> only.</div></span><div class='docblock'>View a <code>Sync + Unpin</code> <code>self</code> as <code>&amp;mut [u8]</code>. <a href="trait.ExtMem.html#method.mem_as_bytes_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#791">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../code/trait.From.html" title="trait devela::code::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#794">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="../code/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-FromSample%3CS%3E-for-S" class="impl"><a href="#impl-FromSample%3CS%3E-for-S" class="anchor">§</a><h3 class="code-header">impl&lt;S&gt; FromSample&lt;S&gt; for S</h3></section></summary><div class="impl-items"><section id="method.from_sample_" class="method trait-impl"><a href="#method.from_sample_" class="anchor">§</a><h4 class="code-header">fn <a class="fn">from_sample_</a>(s: S) -&gt; S</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Hook-for-T" class="impl"><a class="src rightside" href="../../src/devela/code/result/chain_hook.rs.html#121">Source</a><a href="#impl-Hook-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="trait.Hook.html" title="trait devela::all::Hook">Hook</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hook_ref" class="method trait-impl"><a class="src rightside" href="../../src/devela/code/result/chain_hook.rs.html#97-103">Source</a><a href="#method.hook_ref" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Hook.html#method.hook_ref" class="fn">hook_ref</a>&lt;F&gt;(self, f: F) -&gt; Self<div class="where">where
    F: <a class="trait" href="trait.FnOnce.html" title="trait devela::all::FnOnce">FnOnce</a>(&amp;Self),</div></h4></section></summary><div class='docblock'>Applies a function which takes the parameter by shared reference,
and then returns the (possibly) modified owned value. <a href="trait.Hook.html#method.hook_ref">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.hook_mut" class="method trait-impl"><a class="src rightside" href="../../src/devela/code/result/chain_hook.rs.html#113-119">Source</a><a href="#method.hook_mut" class="anchor">§</a><h4 class="code-header">fn <a href="trait.Hook.html#method.hook_mut" class="fn">hook_mut</a>&lt;F&gt;(self, f: F) -&gt; Self<div class="where">where
    F: <a class="trait" href="trait.FnOnce.html" title="trait devela::all::FnOnce">FnOnce</a>(&amp;mut Self),</div></h4></section></summary><div class='docblock'>Applies a function which takes the parameter by exclusive reference,
and then returns the (possibly) modified owned value. <a href="trait.Hook.html#method.hook_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#773-775">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../code/trait.Into.html" title="trait devela::code::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="../code/trait.From.html" title="trait devela::code::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#783">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="../code/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="../code/trait.From.html" title="trait devela::code::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-IntoEither-for-T" class="impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#64">Source</a><a href="#impl-IntoEither-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html" title="trait either::into_either::IntoEither">IntoEither</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_either" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#29">Source</a><a href="#method.into_either" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either" class="fn">into_either</a>(self, into_left: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="enum" href="../_dep/itertools/enum.Either.html" title="enum devela::_dep::itertools::Either">Either</a>&lt;Self, Self&gt; <a href="#" class="tooltip" data-notable-ty="Either&lt;Self, Self&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="../_dep/itertools/enum.Either.html#variant.Left" title="variant devela::_dep::itertools::Either::Left"><code>Left</code></a> variant of <a href="../_dep/itertools/enum.Either.html" title="enum devela::_dep::itertools::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left</code> is <code>true</code>.
Converts <code>self</code> into a <a href="../_dep/itertools/enum.Either.html#variant.Right" title="variant devela::_dep::itertools::Either::Right"><code>Right</code></a> variant of <a href="../_dep/itertools/enum.Either.html" title="enum devela::_dep::itertools::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.into_either_with" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#55-57">Source</a><a href="#method.into_either_with" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with" class="fn">into_either_with</a>&lt;F&gt;(self, into_left: F) -&gt; <a class="enum" href="../_dep/itertools/enum.Either.html" title="enum devela::_dep::itertools::Either">Either</a>&lt;Self, Self&gt; <a href="#" class="tooltip" data-notable-ty="Either&lt;Self, Self&gt;">ⓘ</a><div class="where">where
    F: <a class="trait" href="trait.FnOnce.html" title="trait devela::all::FnOnce">FnOnce</a>(&amp;Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="../_dep/itertools/enum.Either.html#variant.Left" title="variant devela::_dep::itertools::Either::Left"><code>Left</code></a> variant of <a href="../_dep/itertools/enum.Either.html" title="enum devela::_dep::itertools::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left(&amp;self)</code> returns <code>true</code>.
Converts <code>self</code> into a <a href="../_dep/itertools/enum.Either.html#variant.Right" title="variant devela::_dep::itertools::Either::Right"><code>Right</code></a> variant of <a href="../_dep/itertools/enum.Either.html" title="enum devela::_dep::itertools::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-IntoSample%3CT%3E-for-F" class="impl"><a href="#impl-IntoSample%3CT%3E-for-F" class="anchor">§</a><h3 class="code-header">impl&lt;F, T&gt; <a class="trait" href="../_dep/symphonia/core/conv/trait.IntoSample.html" title="trait devela::_dep::symphonia::core::conv::IntoSample">IntoSample</a>&lt;T&gt; for F<div class="where">where
    T: <a class="trait" href="../_dep/symphonia/core/conv/trait.FromSample.html" title="trait devela::_dep::symphonia::core::conv::FromSample">FromSample</a>&lt;F&gt;,</div></h3></section></summary><div class="impl-items"><section id="method.into_sample" class="method trait-impl"><a href="#method.into_sample" class="anchor">§</a><h4 class="code-header">fn <a href="../_dep/symphonia/core/conv/trait.IntoSample.html#tymethod.into_sample" class="fn">into_sample</a>(self) -&gt; T</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Pointable-for-T" class="impl"><a href="#impl-Pointable-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Pointable for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.ALIGN" class="associatedconstant trait-impl"><a href="#associatedconstant.ALIGN" class="anchor">§</a><h4 class="code-header">const <a class="constant">ALIGN</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>The alignment of pointer.</div></details><details class="toggle" open><summary><section id="associatedtype.Init" class="associatedtype trait-impl"><a href="#associatedtype.Init" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Init</a> = T</h4></section></summary><div class='docblock'>The type for initializers.</div></details><details class="toggle method-toggle" open><summary><section id="method.init" class="method trait-impl"><a href="#method.init" class="anchor">§</a><h4 class="code-header">unsafe fn <a class="fn">init</a>(init: &lt;T as Pointable&gt;::Init) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Initializes a with the given initializer. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl"><a href="#method.deref" class="anchor">§</a><h4 class="code-header">unsafe fn <a class="fn">deref</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a T</a></h4></section></summary><div class='docblock'>Dereferences the given pointer. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.deref_mut" class="method trait-impl"><a href="#method.deref_mut" class="anchor">§</a><h4 class="code-header">unsafe fn <a class="fn">deref_mut</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a mut T</a></h4></section></summary><div class='docblock'>Mutably dereferences the given pointer. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.drop" class="method trait-impl"><a href="#method.drop" class="anchor">§</a><h4 class="code-header">unsafe fn <a class="fn">drop</a>(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></section></summary><div class='docblock'>Drops the object pointed to by the given pointer. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#82-84">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="trait.ToOwned.html" title="trait devela::all::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="../code/trait.Clone.html" title="trait devela::code::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#86">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#87">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#91">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToSample%3CU%3E-for-T" class="impl"><a href="#impl-ToSample%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; ToSample&lt;U&gt; for T<div class="where">where
    U: FromSample&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><section id="method.to_sample_" class="method trait-impl"><a href="#method.to_sample_" class="anchor">§</a><h4 class="code-header">fn <a class="fn">to_sample_</a>(self) -&gt; U</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#833-835">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../code/trait.TryFrom.html" title="trait devela::code::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="../code/trait.Into.html" title="trait devela::code::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#837">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="../code/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="../code/enum.Infallible.html" title="enum devela::code::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#840">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="../code/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="enum.Result.html" title="enum devela::all::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="../code/trait.TryFrom.html" title="trait devela::code::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="../code/trait.TryFrom.html#associatedtype.Error" title="type devela::code::TryFrom::Error">Error</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#817-819">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../code/trait.TryInto.html" title="trait devela::code::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="../code/trait.TryFrom.html" title="trait devela::code::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#821">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="../code/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="../code/trait.TryFrom.html" title="trait devela::code::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="../code/trait.TryFrom.html#associatedtype.Error" title="type devela::code::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#824">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="../code/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="enum.Result.html" title="enum devela::all::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="../code/trait.TryFrom.html" title="trait devela::code::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="../code/trait.TryFrom.html#associatedtype.Error" title="type devela::code::TryFrom::Error">Error</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><section id="impl-Duplex%3CS%3E-for-T" class="impl"><a href="#impl-Duplex%3CS%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;S, T&gt; Duplex&lt;S&gt; for T<div class="where">where
    T: FromSample&lt;S&gt; + ToSample&lt;S&gt;,</div></h3></section><section id="impl-Ungil-for-T" class="impl"><a href="#impl-Ungil-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../_dep/pyo3/marker/trait.Ungil.html" title="trait devela::_dep::pyo3::marker::Ungil">Ungil</a> for T<div class="where">where
    T: <a class="trait" href="trait.Send.html" title="trait devela::all::Send">Send</a>,</div></h3></section></div><script type="text/json" id="notable-traits-data">{"&'static str":"<h3>Notable traits for <code><a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a></code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"trait.ExtStr.html\" title=\"trait devela::all::ExtStr\">ExtStr</a> for <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a></div>","&[MaybeUninit<u8>]":"<h3>Notable traits for <code><a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></code></h3><pre><code><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"trait.ExtSlice.html\" title=\"trait devela::all::ExtSlice\">ExtSlice</a>&lt;T&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"trait.ExtSliceMut.html\" title=\"trait devela::all::ExtSliceMut\">ExtSliceMut</a>&lt;T&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"trait.ExtSlice.html\" title=\"trait devela::all::ExtSlice\">ExtSlice</a>&lt;T&gt; for &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div>","&[u8]":"<h3>Notable traits for <code>&amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"trait.IoRead.html\" title=\"trait devela::all::IoRead\">Read</a> for &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>]</div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"trait.ExtSlice.html\" title=\"trait devela::all::ExtSlice\">ExtSlice</a>&lt;T&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"trait.ExtSliceMut.html\" title=\"trait devela::all::ExtSliceMut\">ExtSliceMut</a>&lt;T&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"trait.ExtSlice.html\" title=\"trait devela::all::ExtSlice\">ExtSlice</a>&lt;T&gt; for &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div>","&mut [MaybeUninit<u8>]":"<h3>Notable traits for <code><a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></code></h3><pre><code><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"trait.ExtSlice.html\" title=\"trait devela::all::ExtSlice\">ExtSlice</a>&lt;T&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"trait.ExtSliceMut.html\" title=\"trait devela::all::ExtSliceMut\">ExtSliceMut</a>&lt;T&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"trait.ExtSlice.html\" title=\"trait devela::all::ExtSlice\">ExtSlice</a>&lt;T&gt; for &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"trait.ExtSliceMut.html\" title=\"trait devela::all::ExtSliceMut\">ExtSliceMut</a>&lt;T&gt; for &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div>","&mut [u8]":"<h3>Notable traits for <code>&amp;mut [<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"trait.IoWrite.html\" title=\"trait devela::all::IoWrite\">Write</a> for &amp;mut [<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>]</div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"trait.ExtSlice.html\" title=\"trait devela::all::ExtSlice\">ExtSlice</a>&lt;T&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"trait.ExtSliceMut.html\" title=\"trait devela::all::ExtSliceMut\">ExtSliceMut</a>&lt;T&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"trait.ExtSlice.html\" title=\"trait devela::all::ExtSlice\">ExtSlice</a>&lt;T&gt; for &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"trait.ExtSliceMut.html\" title=\"trait devela::all::ExtSliceMut\">ExtSliceMut</a>&lt;T&gt; for &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div>","Either<Self, Self>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../_dep/itertools/enum.Either.html\" title=\"enum devela::_dep::itertools::Either\">Either</a>&lt;L, R&gt;</code></h3><pre><code><div class=\"where\">impl&lt;L, R&gt; <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"enum\" href=\"../_dep/itertools/enum.Either.html\" title=\"enum devela::_dep::itertools::Either\">Either</a>&lt;L, R&gt;<div class=\"where\">where\n    L: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a>,\n    R: <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a>&lt;Item = &lt;L as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type devela::all::Iterator::Item\">Item</a>&gt;,</div></div><div class=\"where\">    type <a href=\"trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;L as <a class=\"trait\" href=\"trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"trait.Iterator.html#associatedtype.Item\" title=\"type devela::all::Iterator::Item\">Item</a>;</div><div class=\"where\">impl&lt;L, R&gt; <a class=\"trait\" href=\"trait.Future.html\" title=\"trait devela::all::Future\">Future</a> for <a class=\"enum\" href=\"../_dep/itertools/enum.Either.html\" title=\"enum devela::_dep::itertools::Either\">Either</a>&lt;L, R&gt;<div class=\"where\">where\n    L: <a class=\"trait\" href=\"trait.Future.html\" title=\"trait devela::all::Future\">Future</a>,\n    R: <a class=\"trait\" href=\"trait.Future.html\" title=\"trait devela::all::Future\">Future</a>&lt;Output = &lt;L as <a class=\"trait\" href=\"trait.Future.html\" title=\"trait devela::all::Future\">Future</a>&gt;::<a class=\"associatedtype\" href=\"trait.Future.html#associatedtype.Output\" title=\"type devela::all::Future::Output\">Output</a>&gt;,</div></div><div class=\"where\">    type <a href=\"trait.Future.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = &lt;L as <a class=\"trait\" href=\"trait.Future.html\" title=\"trait devela::all::Future\">Future</a>&gt;::<a class=\"associatedtype\" href=\"trait.Future.html#associatedtype.Output\" title=\"type devela::all::Future::Output\">Output</a>;</div><div class=\"where\">impl&lt;L, R&gt; <a class=\"trait\" href=\"trait.IoRead.html\" title=\"trait devela::all::IoRead\">Read</a> for <a class=\"enum\" href=\"../_dep/itertools/enum.Either.html\" title=\"enum devela::_dep::itertools::Either\">Either</a>&lt;L, R&gt;<div class=\"where\">where\n    L: <a class=\"trait\" href=\"trait.IoRead.html\" title=\"trait devela::all::IoRead\">Read</a>,\n    R: <a class=\"trait\" href=\"trait.IoRead.html\" title=\"trait devela::all::IoRead\">Read</a>,</div></div><div class=\"where\">impl&lt;L, R&gt; <a class=\"trait\" href=\"trait.IoWrite.html\" title=\"trait devela::all::IoWrite\">Write</a> for <a class=\"enum\" href=\"../_dep/itertools/enum.Either.html\" title=\"enum devela::_dep::itertools::Either\">Either</a>&lt;L, R&gt;<div class=\"where\">where\n    L: <a class=\"trait\" href=\"trait.IoWrite.html\" title=\"trait devela::all::IoWrite\">Write</a>,\n    R: <a class=\"trait\" href=\"trait.IoWrite.html\" title=\"trait devela::all::IoWrite\">Write</a>,</div></div>","Option<&T>":"<h3>Notable traits for <code><a class=\"enum\" href=\"enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"trait.ExtOption.html\" title=\"trait devela::all::ExtOption\">ExtOption</a>&lt;T&gt; for <a class=\"enum\" href=\"enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</div>","Option<&mut T>":"<h3>Notable traits for <code><a class=\"enum\" href=\"enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"trait.ExtOption.html\" title=\"trait devela::all::ExtOption\">ExtOption</a>&lt;T&gt; for <a class=\"enum\" href=\"enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</div>","Result<(), Error>":"<h3>Notable traits for <code><a class=\"enum\" href=\"enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>","Result<T, <T as TryFrom<U>>::Error>":"<h3>Notable traits for <code><a class=\"enum\" href=\"enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>","Result<U, <U as TryFrom<T>>::Error>":"<h3>Notable traits for <code><a class=\"enum\" href=\"enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>"}</script></section></div></main></body></html>