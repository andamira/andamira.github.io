<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="`core` Parses a file as an expression or an item according to the context."><title>include in devela::code::util - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="devela" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-nightly (f2824da98 2025-08-28)" data-channel="nightly" data-search-js="search-03d23683.js" data-stringdex-js="stringdex-0e748618.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"><script>
  document.addEventListener("DOMContentLoaded", async function() {
    // Ensure this script runs only once per page load
    if (window.scriptLoaderInitialized) return;
    window.scriptLoaderInitialized = true;

    /* settings */

    const crateName = "devela";
    const allowedKatex = ["/all", "/media/color", "/num/", "/phys/"];
    const allowedKatexChem = ["/all/", "/phys/"];

    // Find the LAST occurrence of `/devela/` in the path
    const path = window.location.pathname;
    const lastCrateIndex = path.lastIndexOf(`/${crateName}/`);
    if (lastCrateIndex === -1) return;
    // Extract everything after the last `/devela/`
    const relativePath = path.slice(lastCrateIndex + crateName.length + 1);

    /* load resources */

    try {
      if (allowedKatex.some(prefix => relativePath.startsWith(prefix))) {
        await loadKatex().catch(handleMathError);
      }
      if (allowedKatexChem.some(prefix => relativePath.startsWith(prefix))) {
        await loadKatexChem().catch(handleMathError);
      }
    } catch (error) {
      handleMathError(error);
    }

    /* resource loading functions */

    // INFO: https://katex.org/docs/browser.html#starter-template
    // INFO: https://github.com/KaTeX/KaTeX/tree/main/contrib/copy-tex
    async function loadKatex() {
      console.log("Loading KaTeX for:", relativePath);

      // Load CSS, and scripts sequentially
      const katexCSS = document.createElement("link");
      katexCSS.rel = "stylesheet";
      katexCSS.href = "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css";
      katexCSS.integrity = "sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib";
      katexCSS.crossOrigin = "anonymous";
      document.head.appendChild(katexCSS);

      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js",
        integrity: "sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh"
      });
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js",
        integrity: "sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh"
      });
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/copy-tex.min.js",
        integrity: "sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi"
      });

      // Initialize KaTeX
      renderMathInElement(document.body, {
        delimiters: [
          {left: "$$", right: "$$", display: true},
          {left: "$", right: "$", display: false},
          {left: "\\(", right: "\\)", display: false},
          {left: "\\[", right: "\\]", display: true}
        ],
        trust: (context) => context.command === "\\href"
      });
      // Add custom styles: https://katex.org/docs/issues.html#css-customization
      const katexStyle = document.createElement("style");
      katexStyle.textContent = `
        .katex-display { overflow: hidden; }
        .docblock p { overflow-y: hidden; }
      `;
      document.head.appendChild(katexStyle);
    }

    // INFO: https://github.com/KaTeX/KaTeX/blob/main/contrib/mhchem/README.md
    async function loadKatexChem() {
      console.log("Loading KaTeX MhChem plugin for:", relativePath);
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/mhchem.min.js",
        integrity: "sha384-F2ptQFZqNJuqfGGl28mIXyQ5kXH48spn7rcoS0Y9psqIKAcZPLd1NzwFlm/bl1mH"
      });
    }

    /* helper functions */

    function loadScript(config) {
      return new Promise((resolve, reject) => {
        const script = document.createElement("script");
        script.src = config.src;
        if (config.integrity) {
          script.integrity = config.integrity;
          script.crossOrigin = "anonymous";
        }
        script.onload = resolve;
        script.onerror = () => reject(new Error(`Failed to load script: ${config.src}`));
        document.head.appendChild(script);
      });
    }
    function handleMathError(error) {
      console.error("Math rendering error:", error);
    }
  });
</script>

</head><body class="rustdoc macro"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">include</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../devela/index.html">devela</a><span class="version">0.25.0-wip</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">include</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#uses" title="Uses">Uses</a></li><li><a href="#examples" title="Examples">Examples</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In devela::<wbr>code::<wbr>util</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">devela</a>::<wbr><a href="../index.html">code</a>::<wbr><a href="index.html">util</a></div><h1>Macro <span class="macro">include</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/macros/mod.rs.html#1481">Source</a> </span></div><pre class="rust item-decl"><code>macro_rules! include {
    ($file:expr $(,)?) =&gt; { ... };
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><span class='stab portability' title='re-exported from rust&#39;s `core`'><code>core</code></span>
Parses a file as an expression or an item according to the context.</p>
<p><em>Re-exported from <a href="https://doc.rust-lang.org/core/"><code>core</code></a></em>
.</p>
<hr />
<p>Parses a file as an expression or an item according to the context.</p>
<p><strong>Warning</strong>: For multi-file Rust projects, the <code>include!</code> macro is probably not what you
are looking for. Usually, multi-file Rust projects use
<a href="https://doc.rust-lang.org/reference/items/modules.html">modules</a>. Multi-file projects and
modules are explained in the Rust-by-Example book
<a href="https://doc.rust-lang.org/rust-by-example/mod/split.html">here</a> and the module system is
explained in the Rust Book
<a href="https://doc.rust-lang.org/book/ch07-02-defining-modules-to-control-scope-and-privacy.html">here</a>.</p>
<p>The included file is placed in the surrounding code
<a href="https://doc.rust-lang.org/reference/macros-by-example.html#hygiene">unhygienically</a>. If
the included file is parsed as an expression and variables or functions share names across
both files, it could result in variables or functions being different from what the
included file expected.</p>
<p>The included file is located relative to the current file (similarly to how modules are
found). The provided path is interpreted in a platform-specific way at compile time. So,
for instance, an invocation with a Windows path containing backslashes <code>\</code> would not
compile correctly on Unix.</p>
<h2 id="uses"><a class="doc-anchor" href="#uses">Â§</a>Uses</h2>
<p>The <code>include!</code> macro is primarily used for two purposes. It is used to include
documentation that is written in a separate file and it is used to include <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html#outputs-of-the-build-script">build artifacts
usually as a result from the <code>build.rs</code>
script</a>.</p>
<p>When using the <code>include</code> macro to include stretches of documentation, remember that the
included file still needs to be a valid Rust syntax. It is also possible to
use the <a href="../../all/macro.include_str.html" title="macro devela::all::include_str"><code>include_str</code></a> macro as <code>#![doc = include_str!("...")]</code> (at the module level) or
<code>#[doc = include_str!("...")]</code> (at the item level) to include documentation from a plain
text or markdown file.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">Â§</a>Examples</h2>
<p>Assume there are two files in the same directory with the following contents:</p>
<p>File â€˜monkeys.inâ€™:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">â“˜</a><pre class="rust rust-example-rendered"><code>[<span class="string">'ğŸ™ˆ'</span>, <span class="string">'ğŸ™Š'</span>, <span class="string">'ğŸ™‰'</span>]
    .iter()
    .cycle()
    .take(<span class="number">6</span>)
    .collect::&lt;String&gt;()</code></pre></div>
<p>File â€˜main.rsâ€™:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">â“˜</a><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>main() {
    <span class="kw">let </span>my_string = <span class="macro">include!</span>(<span class="string">"monkeys.in"</span>);
    <span class="macro">assert_eq!</span>(<span class="string">"ğŸ™ˆğŸ™ŠğŸ™‰ğŸ™ˆğŸ™ŠğŸ™‰"</span>, my_string);
    <span class="macro">println!</span>(<span class="string">"{my_string}"</span>);
}</code></pre></div>
<p>Compiling â€˜main.rsâ€™ and running the resulting binary will print
â€œğŸ™ˆğŸ™ŠğŸ™‰ğŸ™ˆğŸ™ŠğŸ™‰â€.</p>
</div></details></section></div></main></body></html>