<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A wrapper around `str` where the storage is owned by a Python `bytes` or `str` object."><title>PyBackedStr in devela::_dep::pyo3::pybacked - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="devela" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-nightly (fe5536432 2025-08-29)" data-channel="nightly" data-search-js="search-03d23683.js" data-stringdex-js="stringdex-0e748618.js" data-settings-js="settings-c38705f0.js" ><script src="../../../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-044be391.svg"><script>
  document.addEventListener("DOMContentLoaded", async function() {
    // Ensure this script runs only once per page load
    if (window.scriptLoaderInitialized) return;
    window.scriptLoaderInitialized = true;

    /* settings */

    const crateName = "devela";
    const allowedKatex = ["/all", "/media/color", "/num/", "/phys/"];
    const allowedKatexChem = ["/all/", "/phys/"];

    // Find the LAST occurrence of `/devela/` in the path
    const path = window.location.pathname;
    const lastCrateIndex = path.lastIndexOf(`/${crateName}/`);
    if (lastCrateIndex === -1) return;
    // Extract everything after the last `/devela/`
    const relativePath = path.slice(lastCrateIndex + crateName.length + 1);

    /* load resources */

    try {
      if (allowedKatex.some(prefix => relativePath.startsWith(prefix))) {
        await loadKatex().catch(handleMathError);
      }
      if (allowedKatexChem.some(prefix => relativePath.startsWith(prefix))) {
        await loadKatexChem().catch(handleMathError);
      }
    } catch (error) {
      handleMathError(error);
    }

    /* resource loading functions */

    // INFO: https://katex.org/docs/browser.html#starter-template
    // INFO: https://github.com/KaTeX/KaTeX/tree/main/contrib/copy-tex
    async function loadKatex() {
      console.log("Loading KaTeX for:", relativePath);

      // Load CSS, and scripts sequentially
      const katexCSS = document.createElement("link");
      katexCSS.rel = "stylesheet";
      katexCSS.href = "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css";
      katexCSS.integrity = "sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib";
      katexCSS.crossOrigin = "anonymous";
      document.head.appendChild(katexCSS);

      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js",
        integrity: "sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh"
      });
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js",
        integrity: "sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh"
      });
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/copy-tex.min.js",
        integrity: "sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi"
      });

      // Initialize KaTeX
      renderMathInElement(document.body, {
        delimiters: [
          {left: "$$", right: "$$", display: true},
          {left: "$", right: "$", display: false},
          {left: "\\(", right: "\\)", display: false},
          {left: "\\[", right: "\\]", display: true}
        ],
        trust: (context) => context.command === "\\href"
      });
      // Add custom styles: https://katex.org/docs/issues.html#css-customization
      const katexStyle = document.createElement("style");
      katexStyle.textContent = `
        .katex-display { overflow: hidden; }
        .docblock p { overflow-y: hidden; }
      `;
      document.head.appendChild(katexStyle);
    }

    // INFO: https://github.com/KaTeX/KaTeX/blob/main/contrib/mhchem/README.md
    async function loadKatexChem() {
      console.log("Loading KaTeX MhChem plugin for:", relativePath);
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/mhchem.min.js",
        integrity: "sha384-F2ptQFZqNJuqfGGl28mIXyQ5kXH48spn7rcoS0Y9psqIKAcZPLd1NzwFlm/bl1mH"
      });
    }

    /* helper functions */

    function loadScript(config) {
      return new Promise((resolve, reject) => {
        const script = document.createElement("script");
        script.src = config.src;
        if (config.integrity) {
          script.integrity = config.integrity;
          script.crossOrigin = "anonymous";
        }
        script.onload = resolve;
        script.onerror = () => reject(new Error(`Failed to load script: ${config.src}`));
        document.head.appendChild(script);
      });
    }
    function handleMathError(error) {
      console.error("Math rendering error:", error);
    }
  });
</script>

</head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">PyBackedStr</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../devela/index.html">devela</a><span class="version">0.25.0-wip</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">PyBacked<wbr>Str</a></h2><h3><a href="#deref-methods-str">Methods from Deref&lt;<wbr>Target=str&gt;</a></h3><ul class="block deref-methods"><li><a href="#method.as_ascii" title="as_ascii">as_ascii</a></li><li><a href="#method.as_ascii_unchecked" title="as_ascii_unchecked">as_ascii_unchecked</a></li><li><a href="#method.as_bytes" title="as_bytes">as_bytes</a></li><li><a href="#method.as_ptr" title="as_ptr">as_ptr</a></li><li><a href="#method.as_str" title="as_str">as_str</a></li><li><a href="#method.bytes" title="bytes">bytes</a></li><li><a href="#method.ceil_char_boundary" title="ceil_char_boundary">ceil_char_boundary</a></li><li><a href="#method.char_indices" title="char_indices">char_indices</a></li><li><a href="#method.chars" title="chars">chars</a></li><li><a href="#method.contains" title="contains">contains</a></li><li><a href="#method.encode_utf16" title="encode_utf16">encode_utf16</a></li><li><a href="#method.ends_with" title="ends_with">ends_with</a></li><li><a href="#method.eq_ignore_ascii_case" title="eq_ignore_ascii_case">eq_ignore_ascii_case</a></li><li><a href="#method.escape_debug" title="escape_debug">escape_debug</a></li><li><a href="#method.escape_default" title="escape_default">escape_default</a></li><li><a href="#method.escape_unicode" title="escape_unicode">escape_unicode</a></li><li><a href="#method.find" title="find">find</a></li><li><a href="#method.floor_char_boundary" title="floor_char_boundary">floor_char_boundary</a></li><li><a href="#method.get" title="get">get</a></li><li><a href="#method.get_unchecked" title="get_unchecked">get_unchecked</a></li><li><a href="#method.is_ascii" title="is_ascii">is_ascii</a></li><li><a href="#method.is_char_boundary" title="is_char_boundary">is_char_boundary</a></li><li><a href="#method.is_empty" title="is_empty">is_empty</a></li><li><a href="#method.len" title="len">len</a></li><li><a href="#method.lines" title="lines">lines</a></li><li><a href="#method.lines_any" title="lines_any">lines_any</a></li><li><a href="#method.match_indices" title="match_indices">match_indices</a></li><li><a href="#method.matches" title="matches">matches</a></li><li><a href="#method.parse" title="parse">parse</a></li><li><a href="#method.repeat" title="repeat">repeat</a></li><li><a href="#method.replace" title="replace">replace</a></li><li><a href="#method.replacen" title="replacen">replacen</a></li><li><a href="#method.rfind" title="rfind">rfind</a></li><li><a href="#method.rmatch_indices" title="rmatch_indices">rmatch_indices</a></li><li><a href="#method.rmatches" title="rmatches">rmatches</a></li><li><a href="#method.rsplit" title="rsplit">rsplit</a></li><li><a href="#method.rsplit_once" title="rsplit_once">rsplit_once</a></li><li><a href="#method.rsplit_terminator" title="rsplit_terminator">rsplit_terminator</a></li><li><a href="#method.rsplitn" title="rsplitn">rsplitn</a></li><li><a href="#method.slice_unchecked" title="slice_unchecked">slice_unchecked</a></li><li><a href="#method.split" title="split">split</a></li><li><a href="#method.split_ascii_whitespace" title="split_ascii_whitespace">split_ascii_whitespace</a></li><li><a href="#method.split_at" title="split_at">split_at</a></li><li><a href="#method.split_at_checked" title="split_at_checked">split_at_checked</a></li><li><a href="#method.split_inclusive" title="split_inclusive">split_inclusive</a></li><li><a href="#method.split_once" title="split_once">split_once</a></li><li><a href="#method.split_terminator" title="split_terminator">split_terminator</a></li><li><a href="#method.split_whitespace" title="split_whitespace">split_whitespace</a></li><li><a href="#method.splitn" title="splitn">splitn</a></li><li><a href="#method.starts_with" title="starts_with">starts_with</a></li><li><a href="#method.strip_prefix" title="strip_prefix">strip_prefix</a></li><li><a href="#method.strip_suffix" title="strip_suffix">strip_suffix</a></li><li><a href="#method.substr_range" title="substr_range">substr_range</a></li><li><a href="#method.to_ascii_lowercase" title="to_ascii_lowercase">to_ascii_lowercase</a></li><li><a href="#method.to_ascii_uppercase" title="to_ascii_uppercase">to_ascii_uppercase</a></li><li><a href="#method.to_lowercase" title="to_lowercase">to_lowercase</a></li><li><a href="#method.to_uppercase" title="to_uppercase">to_uppercase</a></li><li><a href="#method.trim" title="trim">trim</a></li><li><a href="#method.trim_ascii" title="trim_ascii">trim_ascii</a></li><li><a href="#method.trim_ascii_end" title="trim_ascii_end">trim_ascii_end</a></li><li><a href="#method.trim_ascii_start" title="trim_ascii_start">trim_ascii_start</a></li><li><a href="#method.trim_end" title="trim_end">trim_end</a></li><li><a href="#method.trim_end_matches" title="trim_end_matches">trim_end_matches</a></li><li><a href="#method.trim_left" title="trim_left">trim_left</a></li><li><a href="#method.trim_left_matches" title="trim_left_matches">trim_left_matches</a></li><li><a href="#method.trim_matches" title="trim_matches">trim_matches</a></li><li><a href="#method.trim_prefix" title="trim_prefix">trim_prefix</a></li><li><a href="#method.trim_right" title="trim_right">trim_right</a></li><li><a href="#method.trim_right_matches" title="trim_right_matches">trim_right_matches</a></li><li><a href="#method.trim_start" title="trim_start">trim_start</a></li><li><a href="#method.trim_start_matches" title="trim_start_matches">trim_start_matches</a></li><li><a href="#method.trim_suffix" title="trim_suffix">trim_suffix</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-AsRef%3C%5Bu8%5D%3E-for-PyBackedStr" title="AsRef&#60;[u8]&#62;">AsRef&#60;[u8]&#62;</a></li><li><a href="#impl-AsRef%3Cstr%3E-for-PyBackedStr" title="AsRef&#60;str&#62;">AsRef&#60;str&#62;</a></li><li><a href="#impl-Debug-for-PyBackedStr" title="Debug">Debug</a></li><li><a href="#impl-Deref-for-PyBackedStr" title="Deref">Deref</a></li><li><a href="#impl-Display-for-PyBackedStr" title="Display">Display</a></li><li><a href="#impl-Eq-for-PyBackedStr" title="Eq">Eq</a></li><li><a href="#impl-FromPyObject%3C'_%3E-for-PyBackedStr" title="FromPyObject&#60;&#39;_&#62;">FromPyObject&#60;&#39;_&#62;</a></li><li><a href="#impl-Hash-for-PyBackedStr" title="Hash">Hash</a></li><li><a href="#impl-IntoPyObject%3C'py%3E-for-%26PyBackedStr" title="IntoPyObject&#60;&#39;py&#62;">IntoPyObject&#60;&#39;py&#62;</a></li><li><a href="#impl-IntoPyObject%3C'py%3E-for-PyBackedStr" title="IntoPyObject&#60;&#39;py&#62;">IntoPyObject&#60;&#39;py&#62;</a></li><li><a href="#impl-Ord-for-PyBackedStr" title="Ord">Ord</a></li><li><a href="#impl-PartialEq-for-PyBackedStr" title="PartialEq">PartialEq</a></li><li><a href="#impl-PartialEq%3C%26str%3E-for-PyBackedStr" title="PartialEq&#60;&#38;str&#62;">PartialEq&#60;&#38;str&#62;</a></li><li><a href="#impl-PartialEq%3CPyBackedStr%3E-for-%26str" title="PartialEq&#60;PyBackedStr&#62;">PartialEq&#60;PyBackedStr&#62;</a></li><li><a href="#impl-PartialEq%3CPyBackedStr%3E-for-str" title="PartialEq&#60;PyBackedStr&#62;">PartialEq&#60;PyBackedStr&#62;</a></li><li><a href="#impl-PartialEq%3Cstr%3E-for-PyBackedStr" title="PartialEq&#60;str&#62;">PartialEq&#60;str&#62;</a></li><li><a href="#impl-PartialOrd-for-PyBackedStr" title="PartialOrd">PartialOrd</a></li><li><a href="#impl-PartialOrd%3CPyBackedStr%3E-for-str" title="PartialOrd&#60;PyBackedStr&#62;">PartialOrd&#60;PyBackedStr&#62;</a></li><li><a href="#impl-PartialOrd%3Cstr%3E-for-PyBackedStr" title="PartialOrd&#60;str&#62;">PartialOrd&#60;str&#62;</a></li><li><a href="#impl-Send-for-PyBackedStr" title="Send">Send</a></li><li><a href="#impl-Sync-for-PyBackedStr" title="Sync">Sync</a></li><li><a href="#impl-TryFrom%3CBound%3C'_,+PyString%3E%3E-for-PyBackedStr" title="TryFrom&#60;Bound&#60;&#39;_, PyString&#62;&#62;">TryFrom&#60;Bound&#60;&#39;_, PyString&#62;&#62;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-RefUnwindSafe-for-PyBackedStr" title="!RefUnwindSafe">!RefUnwindSafe</a></li><li><a href="#impl-Freeze-for-PyBackedStr" title="Freeze">Freeze</a></li><li><a href="#impl-Unpin-for-PyBackedStr" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-PyBackedStr" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-ByteSized-for-T" title="ByteSized">ByteSized</a></li><li><a href="#impl-Chain%3CR%3E-for-T" title="Chain&#60;R&#62;">Chain&#60;R&#62;</a></li><li><a href="#impl-Comparable%3CK%3E-for-Q" title="Comparable&#60;K&#62;">Comparable&#60;K&#62;</a></li><li><a href="#impl-Duplex%3CS%3E-for-T" title="Duplex&#60;S&#62;">Duplex&#60;S&#62;</a></li><li><a href="#impl-Equivalent%3CK%3E-for-Q" title="Equivalent&#60;K&#62;">Equivalent&#60;K&#62;</a></li><li><a href="#impl-Equivalent%3CK%3E-for-Q-1" title="Equivalent&#60;K&#62;">Equivalent&#60;K&#62;</a></li><li><a href="#impl-ExtAny-for-T" title="ExtAny">ExtAny</a></li><li><a href="#impl-ExtMem-for-T" title="ExtMem">ExtMem</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-FromPyObjectBound%3C'_,+'py%3E-for-T" title="FromPyObjectBound&#60;&#39;_, &#39;py&#62;">FromPyObjectBound&#60;&#39;_, &#39;py&#62;</a></li><li><a href="#impl-FromSample%3CS%3E-for-S" title="FromSample&#60;S&#62;">FromSample&#60;S&#62;</a></li><li><a href="#impl-Hook-for-T" title="Hook">Hook</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-IntoEither-for-T" title="IntoEither">IntoEither</a></li><li><a href="#impl-IntoPyObjectExt%3C'py%3E-for-T" title="IntoPyObjectExt&#60;&#39;py&#62;">IntoPyObjectExt&#60;&#39;py&#62;</a></li><li><a href="#impl-IntoSample%3CT%3E-for-F" title="IntoSample&#60;T&#62;">IntoSample&#60;T&#62;</a></li><li><a href="#impl-Pointable-for-T" title="Pointable">Pointable</a></li><li><a href="#impl-PyErrArguments-for-T" title="PyErrArguments">PyErrArguments</a></li><li><a href="#impl-Receiver-for-P" title="Receiver">Receiver</a></li><li><a href="#impl-StringZilla%3C'a,+N%3E-for-T" title="StringZilla&#60;&#39;a, N&#62;">StringZilla&#60;&#39;a, N&#62;</a></li><li><a href="#impl-ToSample%3CU%3E-for-T" title="ToSample&#60;U&#62;">ToSample&#60;U&#62;</a></li><li><a href="#impl-ToString-for-T" title="ToString">ToString</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li><li><a href="#impl-Ungil-for-T" title="Ungil">Ungil</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In devela::<wbr>_<wbr>dep::<wbr>pyo3::<wbr>pybacked</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../../index.html">devela</a>::<wbr><a href="../../index.html">_dep</a>::<wbr><a href="../index.html">pyo3</a>::<wbr><a href="index.html">pybacked</a></div><h1>Struct <span class="struct">PyBacked<wbr>Str</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"></span></div><pre class="rust item-decl"><code>pub struct PyBackedStr { <span class="comment">/* private fields */</span> }</code></pre><span class="item-info"><div class="stab portability">Available on <strong>crate features <code>dep_pyo3</code> and <code>std</code></strong> only.</div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A wrapper around <code>str</code> where the storage is owned by a Python <code>bytes</code> or <code>str</code> object.</p>
<p>This type gives access to the underlying data via a <code>Deref</code> implementation.</p>
</div></details><details class="toggle big-toggle" open><summary><h2 id="deref-methods-str" class="section-header"><span>Methods from <a class="trait" href="../../../all/trait.Deref.html" title="trait devela::all::Deref">Deref</a>&lt;Target = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;</span><a href="#deref-methods-str" class="anchor">Â§</a></h2></summary><div id="deref-methods-str-1" class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.len" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#141">Source</a></span><h4 class="code-header">pub fn <a href="#method.len" class="fn">len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the length of <code>self</code>.</p>
<p>This length is in bytes, not <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s or graphemes. In other words,
it might not be what a human considers the length of the string.</p>
<h5 id="examples"><a class="doc-anchor" href="#examples">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>len = <span class="string">"foo"</span>.len();
<span class="macro">assert_eq!</span>(<span class="number">3</span>, len);

<span class="macro">assert_eq!</span>(<span class="string">"Æ’oo"</span>.len(), <span class="number">4</span>); <span class="comment">// fancy f!
</span><span class="macro">assert_eq!</span>(<span class="string">"Æ’oo"</span>.chars().count(), <span class="number">3</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_empty" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#161">Source</a></span><h4 class="code-header">pub fn <a href="#method.is_empty" class="fn">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if <code>self</code> has a length of zero bytes.</p>
<h5 id="examples-1"><a class="doc-anchor" href="#examples-1">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">""</span>;
<span class="macro">assert!</span>(s.is_empty());

<span class="kw">let </span>s = <span class="string">"not empty"</span>;
<span class="macro">assert!</span>(!s.is_empty());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_char_boundary" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.9.0">1.9.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#361">Source</a></span><h4 class="code-header">pub fn <a href="#method.is_char_boundary" class="fn">is_char_boundary</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks that <code>index</code>-th byte is the first byte in a UTF-8 code point
sequence or the end of the string.</p>
<p>The start and end of the string (when <code>index == self.len()</code>) are
considered to be boundaries.</p>
<p>Returns <code>false</code> if <code>index</code> is greater than <code>self.len()</code>.</p>
<h5 id="examples-2"><a class="doc-anchor" href="#examples-2">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"LÃ¶we è€è™ LÃ©opard"</span>;
<span class="macro">assert!</span>(s.is_char_boundary(<span class="number">0</span>));
<span class="comment">// start of `è€`
</span><span class="macro">assert!</span>(s.is_char_boundary(<span class="number">6</span>));
<span class="macro">assert!</span>(s.is_char_boundary(s.len()));

<span class="comment">// second byte of `Ã¶`
</span><span class="macro">assert!</span>(!s.is_char_boundary(<span class="number">2</span>));

<span class="comment">// third byte of `è€`
</span><span class="macro">assert!</span>(!s.is_char_boundary(<span class="number">8</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.floor_char_boundary" class="method"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#410">Source</a><h4 class="code-header">pub fn <a href="#method.floor_char_boundary" class="fn">floor_char_boundary</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>round_char_boundary</code>)</span></div></span></summary><div class="docblock"><p>Finds the closest <code>x</code> not exceeding <code>index</code> where <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.is_char_boundary" title="method str::is_char_boundary"><code>is_char_boundary(x)</code></a> is <code>true</code>.</p>
<p>This method can help you truncate a string so that itâ€™s still valid UTF-8, but doesnâ€™t
exceed a given number of bytes. Note that this is done purely at the character level
and can still visually split graphemes, even though the underlying characters arenâ€™t
split. For example, the emoji ğŸ§‘â€ğŸ”¬ (scientist) could be split so that the string only
includes ğŸ§‘ (person) instead.</p>
<h5 id="examples-3"><a class="doc-anchor" href="#examples-3">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(round_char_boundary)]
</span><span class="kw">let </span>s = <span class="string">"â¤ï¸ğŸ§¡ğŸ’›ğŸ’šğŸ’™ğŸ’œ"</span>;
<span class="macro">assert_eq!</span>(s.len(), <span class="number">26</span>);
<span class="macro">assert!</span>(!s.is_char_boundary(<span class="number">13</span>));

<span class="kw">let </span>closest = s.floor_char_boundary(<span class="number">13</span>);
<span class="macro">assert_eq!</span>(closest, <span class="number">10</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>s[..closest], <span class="string">"â¤ï¸ğŸ§¡"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.ceil_char_boundary" class="method"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#453">Source</a><h4 class="code-header">pub fn <a href="#method.ceil_char_boundary" class="fn">ceil_char_boundary</a>(&amp;self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>round_char_boundary</code>)</span></div></span></summary><div class="docblock"><p>Finds the closest <code>x</code> not below <code>index</code> where <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.is_char_boundary" title="method str::is_char_boundary"><code>is_char_boundary(x)</code></a> is <code>true</code>.</p>
<p>If <code>index</code> is greater than the length of the string, this returns the length of the string.</p>
<p>This method is the natural complement to <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.floor_char_boundary" title="method str::floor_char_boundary"><code>floor_char_boundary</code></a>. See that method
for more details.</p>
<h5 id="examples-4"><a class="doc-anchor" href="#examples-4">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(round_char_boundary)]
</span><span class="kw">let </span>s = <span class="string">"â¤ï¸ğŸ§¡ğŸ’›ğŸ’šğŸ’™ğŸ’œ"</span>;
<span class="macro">assert_eq!</span>(s.len(), <span class="number">26</span>);
<span class="macro">assert!</span>(!s.is_char_boundary(<span class="number">13</span>));

<span class="kw">let </span>closest = s.ceil_char_boundary(<span class="number">13</span>);
<span class="macro">assert_eq!</span>(closest, <span class="number">14</span>);
<span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>s[..closest], <span class="string">"â¤ï¸ğŸ§¡ğŸ’›"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#486">Source</a></span><h4 class="code-header">pub fn <a href="#method.as_bytes" class="fn">as_bytes</a>(&amp;self) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">â“˜</a></h4></section></summary><div class="docblock"><p>Converts a string slice to a byte slice. To convert the byte slice back
into a string slice, use the <a href="../../../_core/str/fn.from_utf8.html" title="fn devela::_core::str::from_utf8"><code>from_utf8</code></a> function.</p>
<h5 id="examples-5"><a class="doc-anchor" href="#examples-5">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bytes = <span class="string">"bors"</span>.as_bytes();
<span class="macro">assert_eq!</span>(<span class="string">b"bors"</span>, bytes);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_ptr" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#562">Source</a></span><h4 class="code-header">pub fn <a href="#method.as_ptr" class="fn">as_ptr</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*const </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a></h4></section></summary><div class="docblock"><p>Converts a string slice to a raw pointer.</p>
<p>As string slices are a slice of bytes, the raw pointer points to a
<a href="https://doc.rust-lang.org/nightly/std/primitive.u8.html" title="primitive u8"><code>u8</code></a>. This pointer will be pointing to the first byte of the string
slice.</p>
<p>The caller must ensure that the returned pointer is never written to.
If you need to mutate the contents of the string slice, use <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.as_mut_ptr" title="method str::as_mut_ptr"><code>as_mut_ptr</code></a>.</p>
<h5 id="examples-6"><a class="doc-anchor" href="#examples-6">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"Hello"</span>;
<span class="kw">let </span>ptr = s.as_ptr();</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#606">Source</a></span><h4 class="code-header">pub fn <a href="#method.get" class="fn">get</a>&lt;I&gt;(&amp;self, i: I) -&gt; <a class="enum" href="../../../all/enum.Option.html" title="enum devela::all::Option">Option</a>&lt;&amp;&lt;I as <a class="trait" href="../../../_core/slice/trait.SliceIndex.html" title="trait devela::_core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="../../../_core/slice/trait.SliceIndex.html#associatedtype.Output" title="type devela::_core::slice::SliceIndex::Output">Output</a>&gt; <a href="#" class="tooltip" data-notable-ty="Option&lt;&amp;&lt;I as SliceIndex&lt;str&gt;&gt;::Output&gt;">â“˜</a><div class="where">where
    I: <a class="trait" href="../../../_core/slice/trait.SliceIndex.html" title="trait devela::_core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a subslice of <code>str</code>.</p>
<p>This is the non-panicking alternative to indexing the <code>str</code>. Returns
<a href="../../../all/enum.Option.html#variant.None" title="variant devela::all::Option::None"><code>None</code></a> whenever equivalent indexing operation would panic.</p>
<h5 id="examples-7"><a class="doc-anchor" href="#examples-7">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v = String::from(<span class="string">"ğŸ—»âˆˆğŸŒ"</span>);

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"ğŸ—»"</span>), v.get(<span class="number">0</span>..<span class="number">4</span>));

<span class="comment">// indices not on UTF-8 sequence boundaries
</span><span class="macro">assert!</span>(v.get(<span class="number">1</span>..).is_none());
<span class="macro">assert!</span>(v.get(..<span class="number">8</span>).is_none());

<span class="comment">// out of bounds
</span><span class="macro">assert!</span>(v.get(..<span class="number">42</span>).is_none());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_unchecked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.20.0">1.20.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#671">Source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.get_unchecked" class="fn">get_unchecked</a>&lt;I&gt;(&amp;self, i: I) -&gt; &amp;&lt;I as <a class="trait" href="../../../_core/slice/trait.SliceIndex.html" title="trait devela::_core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;&gt;::<a class="associatedtype" href="../../../_core/slice/trait.SliceIndex.html#associatedtype.Output" title="type devela::_core::slice::SliceIndex::Output">Output</a><div class="where">where
    I: <a class="trait" href="../../../_core/slice/trait.SliceIndex.html" title="trait devela::_core::slice::SliceIndex">SliceIndex</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Returns an unchecked subslice of <code>str</code>.</p>
<p>This is the unchecked alternative to indexing the <code>str</code>.</p>
<h5 id="safety"><a class="doc-anchor" href="#safety">Â§</a>Safety</h5>
<p>Callers of this function are responsible that these preconditions are
satisfied:</p>
<ul>
<li>The starting index must not exceed the ending index;</li>
<li>Indexes must be within bounds of the original slice;</li>
<li>Indexes must lie on UTF-8 sequence boundaries.</li>
</ul>
<p>Failing that, the returned string slice may reference invalid memory or
violate the invariants communicated by the <code>str</code> type.</p>
<h5 id="examples-8"><a class="doc-anchor" href="#examples-8">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v = <span class="string">"ğŸ—»âˆˆğŸŒ"</span>;
<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(<span class="string">"ğŸ—»"</span>, v.get_unchecked(<span class="number">0</span>..<span class="number">4</span>));
    <span class="macro">assert_eq!</span>(<span class="string">"âˆˆ"</span>, v.get_unchecked(<span class="number">4</span>..<span class="number">7</span>));
    <span class="macro">assert_eq!</span>(<span class="string">"ğŸŒ"</span>, v.get_unchecked(<span class="number">7</span>..<span class="number">11</span>));
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.slice_unchecked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#757">Source</a></span><h4 class="code-header">pub unsafe fn <a href="#method.slice_unchecked" class="fn">slice_unchecked</a>(&amp;self, begin: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, end: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <a href="#" class="tooltip" data-notable-ty="&amp;str">â“˜</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.29.0: use <code>get_unchecked(begin..end)</code> instead</span></div></span></summary><div class="docblock"><p>Creates a string slice from another string slice, bypassing safety
checks.</p>
<p>This is generally not recommended, use with caution! For a safe
alternative see <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html" title="primitive str"><code>str</code></a> and <a href="../../../all/trait.Index.html" title="trait devela::all::Index"><code>Index</code></a>.</p>
<p>This new slice goes from <code>begin</code> to <code>end</code>, including <code>begin</code> but
excluding <code>end</code>.</p>
<p>To get a mutable string slice instead, see the
<a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.slice_mut_unchecked" title="method str::slice_mut_unchecked"><code>slice_mut_unchecked</code></a> method.</p>
<h5 id="safety-1"><a class="doc-anchor" href="#safety-1">Â§</a>Safety</h5>
<p>Callers of this function are responsible that three preconditions are
satisfied:</p>
<ul>
<li><code>begin</code> must not exceed <code>end</code>.</li>
<li><code>begin</code> and <code>end</code> must be byte positions within the string slice.</li>
<li><code>begin</code> and <code>end</code> must lie on UTF-8 sequence boundaries.</li>
</ul>
<h5 id="examples-9"><a class="doc-anchor" href="#examples-9">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"LÃ¶we è€è™ LÃ©opard"</span>;

<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(<span class="string">"LÃ¶we è€è™ LÃ©opard"</span>, s.slice_unchecked(<span class="number">0</span>, <span class="number">21</span>));
}

<span class="kw">let </span>s = <span class="string">"Hello, world!"</span>;

<span class="kw">unsafe </span>{
    <span class="macro">assert_eq!</span>(<span class="string">"world"</span>, s.slice_unchecked(<span class="number">7</span>, <span class="number">12</span>));
}</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_at" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.4.0">1.4.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#831">Source</a></span><h4 class="code-header">pub fn <a href="#method.split_at" class="fn">split_at</a>(&amp;self, mid: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; (&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) <a href="#" class="tooltip" data-notable-ty="(&amp;str, &amp;str)">â“˜</a></h4></section></summary><div class="docblock"><p>Divides one string slice into two at an index.</p>
<p>The argument, <code>mid</code>, should be a byte offset from the start of the
string. It must also be on the boundary of a UTF-8 code point.</p>
<p>The two slices returned go from the start of the string slice to <code>mid</code>,
and from <code>mid</code> to the end of the string slice.</p>
<p>To get mutable string slices instead, see the <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.split_at_mut" title="method str::split_at_mut"><code>split_at_mut</code></a>
method.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">Â§</a>Panics</h5>
<p>Panics if <code>mid</code> is not on a UTF-8 code point boundary, or if it is past
the end of the last code point of the string slice.  For a non-panicking
alternative see <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.split_at_checked" title="method str::split_at_checked"><code>split_at_checked</code></a>.</p>
<h5 id="examples-10"><a class="doc-anchor" href="#examples-10">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"Per Martin-LÃ¶f"</span>;

<span class="kw">let </span>(first, last) = s.split_at(<span class="number">3</span>);

<span class="macro">assert_eq!</span>(<span class="string">"Per"</span>, first);
<span class="macro">assert_eq!</span>(<span class="string">" Martin-LÃ¶f"</span>, last);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_at_checked" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#912">Source</a></span><h4 class="code-header">pub fn <a href="#method.split_at_checked" class="fn">split_at_checked</a>(&amp;self, mid: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="../../../all/enum.Option.html" title="enum devela::all::Option">Option</a>&lt;(&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>)&gt; <a href="#" class="tooltip" data-notable-ty="Option&lt;(&amp;str, &amp;str)&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Divides one string slice into two at an index.</p>
<p>The argument, <code>mid</code>, should be a valid byte offset from the start of the
string. It must also be on the boundary of a UTF-8 code point. The
method returns <code>None</code> if thatâ€™s not the case.</p>
<p>The two slices returned go from the start of the string slice to <code>mid</code>,
and from <code>mid</code> to the end of the string slice.</p>
<p>To get mutable string slices instead, see the <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.split_at_mut_checked" title="method str::split_at_mut_checked"><code>split_at_mut_checked</code></a>
method.</p>
<h5 id="examples-11"><a class="doc-anchor" href="#examples-11">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"Per Martin-LÃ¶f"</span>;

<span class="kw">let </span>(first, last) = s.split_at_checked(<span class="number">3</span>).unwrap();
<span class="macro">assert_eq!</span>(<span class="string">"Per"</span>, first);
<span class="macro">assert_eq!</span>(<span class="string">" Martin-LÃ¶f"</span>, last);

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, s.split_at_checked(<span class="number">13</span>));  <span class="comment">// Inside â€œÃ¶â€
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, s.split_at_checked(<span class="number">16</span>));  <span class="comment">// Beyond the string length</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.chars" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1050">Source</a></span><h4 class="code-header">pub fn <a href="#method.chars" class="fn">chars</a>(&amp;self) -&gt; <a class="struct" href="../../../text/struct.IterChars.html" title="struct devela::text::IterChars">Chars</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Chars&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s of a string slice.</p>
<p>As a string slice consists of valid UTF-8, we can iterate through a
string slice by <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>. This method returns such an iterator.</p>
<p>Itâ€™s important to remember that <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a> represents a Unicode Scalar
Value, and might not match your idea of what a â€˜characterâ€™ is. Iteration
over grapheme clusters may be what you actually want. This functionality
is not provided by Rustâ€™s standard library, check crates.io instead.</p>
<h5 id="examples-12"><a class="doc-anchor" href="#examples-12">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>word = <span class="string">"goodbye"</span>;

<span class="kw">let </span>count = word.chars().count();
<span class="macro">assert_eq!</span>(<span class="number">7</span>, count);

<span class="kw">let </span><span class="kw-2">mut </span>chars = word.chars();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'g'</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'o'</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'o'</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'d'</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'b'</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'y'</span>), chars.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'e'</span>), chars.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, chars.next());</code></pre></div>
<p>Remember, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s might not match your intuition about characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>y = <span class="string">"yÌ†"</span>;

<span class="kw">let </span><span class="kw-2">mut </span>chars = y.chars();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'y'</span>), chars.next()); <span class="comment">// not 'yÌ†'
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">'\u{0306}'</span>), chars.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, chars.next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.char_indices" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1107">Source</a></span><h4 class="code-header">pub fn <a href="#method.char_indices" class="fn">char_indices</a>(&amp;self) -&gt; <a class="struct" href="../../../_core/str/struct.CharIndices.html" title="struct devela::_core::str::CharIndices">CharIndices</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="CharIndices&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s of a string slice, and their
positions.</p>
<p>As a string slice consists of valid UTF-8, we can iterate through a
string slice by <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>. This method returns an iterator of both
these <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, as well as their byte positions.</p>
<p>The iterator yields tuples. The position is first, the <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a> is
second.</p>
<h5 id="examples-13"><a class="doc-anchor" href="#examples-13">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>word = <span class="string">"goodbye"</span>;

<span class="kw">let </span>count = word.char_indices().count();
<span class="macro">assert_eq!</span>(<span class="number">7</span>, count);

<span class="kw">let </span><span class="kw-2">mut </span>char_indices = word.char_indices();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">0</span>, <span class="string">'g'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">1</span>, <span class="string">'o'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">2</span>, <span class="string">'o'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">3</span>, <span class="string">'d'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">4</span>, <span class="string">'b'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">5</span>, <span class="string">'y'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">6</span>, <span class="string">'e'</span>)), char_indices.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, char_indices.next());</code></pre></div>
<p>Remember, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s might not match your intuition about characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>yes = <span class="string">"yÌ†es"</span>;

<span class="kw">let </span><span class="kw-2">mut </span>char_indices = yes.char_indices();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">0</span>, <span class="string">'y'</span>)), char_indices.next()); <span class="comment">// not (0, 'yÌ†')
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">1</span>, <span class="string">'\u{0306}'</span>)), char_indices.next());

<span class="comment">// note the 3 here - the previous character took up two bytes
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">3</span>, <span class="string">'e'</span>)), char_indices.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>((<span class="number">4</span>, <span class="string">'s'</span>)), char_indices.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, char_indices.next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.bytes" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1130">Source</a></span><h4 class="code-header">pub fn <a href="#method.bytes" class="fn">bytes</a>(&amp;self) -&gt; <a class="struct" href="../../../_core/str/struct.Bytes.html" title="struct devela::_core::str::Bytes">Bytes</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Bytes&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the bytes of a string slice.</p>
<p>As a string slice consists of a sequence of bytes, we can iterate
through a string slice by byte. This method returns such an iterator.</p>
<h5 id="examples-14"><a class="doc-anchor" href="#examples-14">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>bytes = <span class="string">"bors"</span>.bytes();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b'b'</span>), bytes.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b'o'</span>), bytes.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b'r'</span>), bytes.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">b's'</span>), bytes.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, bytes.next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_whitespace" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.1.0">1.1.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1182">Source</a></span><h4 class="code-header">pub fn <a href="#method.split_whitespace" class="fn">split_whitespace</a>(&amp;self) -&gt; <a class="struct" href="../../../_core/str/struct.SplitWhitespace.html" title="struct devela::_core::str::SplitWhitespace">SplitWhitespace</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="SplitWhitespace&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Splits a string slice by whitespace.</p>
<p>The iterator returned will return string slices that are sub-slices of
the original string slice, separated by any amount of whitespace.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>. If you only want to split on ASCII whitespace
instead, use <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.split_ascii_whitespace" title="method str::split_ascii_whitespace"><code>split_ascii_whitespace</code></a>.</p>
<h5 id="examples-15"><a class="doc-anchor" href="#examples-15">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>iter = <span class="string">"A few words"</span>.split_whitespace();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"A"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"few"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"words"</span>), iter.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, iter.next());</code></pre></div>
<p>All kinds of whitespace are considered:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>iter = <span class="string">" Mary   had\ta\u{2009}little  \n\t lamb"</span>.split_whitespace();
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"Mary"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"had"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"a"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"little"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"lamb"</span>), iter.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, iter.next());</code></pre></div>
<p>If the string is empty or all whitespace, the iterator yields no string slices:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">""</span>.split_whitespace().next(), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">"   "</span>.split_whitespace().next(), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_ascii_whitespace" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1233">Source</a></span><h4 class="code-header">pub fn <a href="#method.split_ascii_whitespace" class="fn">split_ascii_whitespace</a>(&amp;self) -&gt; <a class="struct" href="../../../_core/str/struct.SplitAsciiWhitespace.html" title="struct devela::_core::str::SplitAsciiWhitespace">SplitAsciiWhitespace</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="SplitAsciiWhitespace&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Splits a string slice by ASCII whitespace.</p>
<p>The iterator returned will return string slices that are sub-slices of
the original string slice, separated by any amount of ASCII whitespace.</p>
<p>This uses the same definition as <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html#method.is_ascii_whitespace" title="method char::is_ascii_whitespace"><code>char::is_ascii_whitespace</code></a>.
To split by Unicode <code>Whitespace</code> instead, use <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.split_whitespace" title="method str::split_whitespace"><code>split_whitespace</code></a>.</p>
<h5 id="examples-16"><a class="doc-anchor" href="#examples-16">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>iter = <span class="string">"A few words"</span>.split_ascii_whitespace();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"A"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"few"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"words"</span>), iter.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, iter.next());</code></pre></div>
<p>Various kinds of ASCII whitespace are considered
(see <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html#method.is_ascii_whitespace" title="method char::is_ascii_whitespace"><code>char::is_ascii_whitespace</code></a>):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>iter = <span class="string">" Mary   had\ta little  \n\t lamb"</span>.split_ascii_whitespace();
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"Mary"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"had"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"a"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"little"</span>), iter.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"lamb"</span>), iter.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, iter.next());</code></pre></div>
<p>If the string is empty or all ASCII whitespace, the iterator yields no string slices:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">""</span>.split_ascii_whitespace().next(), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">"   "</span>.split_ascii_whitespace().next(), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.lines" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1286">Source</a></span><h4 class="code-header">pub fn <a href="#method.lines" class="fn">lines</a>(&amp;self) -&gt; <a class="struct" href="../../../_core/str/struct.Lines.html" title="struct devela::_core::str::Lines">Lines</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="Lines&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Returns an iterator over the lines of a string, as string slices.</p>
<p>Lines are split at line endings that are either newlines (<code>\n</code>) or
sequences of a carriage return followed by a line feed (<code>\r\n</code>).</p>
<p>Line terminators are not included in the lines returned by the iterator.</p>
<p>Note that any carriage return (<code>\r</code>) not immediately followed by a
line feed (<code>\n</code>) does not split a line. These carriage returns are
thereby included in the produced lines.</p>
<p>The final line ending is optional. A string that ends with a final line
ending will return the same lines as an otherwise identical string
without a final line ending.</p>
<h5 id="examples-17"><a class="doc-anchor" href="#examples-17">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">"foo\r\nbar\n\nbaz\r"</span>;
<span class="kw">let </span><span class="kw-2">mut </span>lines = text.lines();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"foo"</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"bar"</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">""</span>), lines.next());
<span class="comment">// Trailing carriage return is included in the last line
</span><span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"baz\r"</span>), lines.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, lines.next());</code></pre></div>
<p>The final line does not require any ending:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">"foo\nbar\n\r\nbaz"</span>;
<span class="kw">let </span><span class="kw-2">mut </span>lines = text.lines();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"foo"</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"bar"</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">""</span>), lines.next());
<span class="macro">assert_eq!</span>(<span class="prelude-val">Some</span>(<span class="string">"baz"</span>), lines.next());

<span class="macro">assert_eq!</span>(<span class="prelude-val">None</span>, lines.next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.lines_any" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1295">Source</a></span><h4 class="code-header">pub fn <a href="#method.lines_any" class="fn">lines_any</a>(&amp;self) -&gt; <a class="struct" href="../../../_core/str/struct.LinesAny.html" title="struct devela::_core::str::LinesAny">LinesAny</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="LinesAny&lt;&#39;_&gt;">â“˜</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.4.0: use lines() instead now</span></div></span></summary><div class="docblock"><p>Returns an iterator over the lines of a string.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.encode_utf16" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.8.0">1.8.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1315">Source</a></span><h4 class="code-header">pub fn <a href="#method.encode_utf16" class="fn">encode_utf16</a>(&amp;self) -&gt; <a class="struct" href="../../../_core/str/struct.EncodeUtf16.html" title="struct devela::_core::str::EncodeUtf16">EncodeUtf16</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="EncodeUtf16&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Returns an iterator of <code>u16</code> over the string encoded
as native endian UTF-16 (without byte-order mark).</p>
<h5 id="examples-18"><a class="doc-anchor" href="#examples-18">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>text = <span class="string">"ZaÅ¼Ã³Å‚Ä‡ gÄ™Å›lÄ… jaÅºÅ„"</span>;

<span class="kw">let </span>utf8_len = text.len();
<span class="kw">let </span>utf16_len = text.encode_utf16().count();

<span class="macro">assert!</span>(utf16_len &lt;= utf8_len);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.contains" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1340">Source</a></span><h4 class="code-header">pub fn <a href="#method.contains" class="fn">contains</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the given pattern matches a sub-slice of
this string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<p>The <a href="../../../_core/str/pattern/index.html" title="mod devela::_core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-19"><a class="doc-anchor" href="#examples-19">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bananas = <span class="string">"bananas"</span>;

<span class="macro">assert!</span>(bananas.contains(<span class="string">"nana"</span>));
<span class="macro">assert!</span>(!bananas.contains(<span class="string">"apples"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.starts_with" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1378">Source</a></span><h4 class="code-header">pub fn <a href="#method.starts_with" class="fn">starts_with</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the given pattern matches a prefix of this
string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<p>The <a href="../../../_core/str/pattern/index.html" title="mod devela::_core::str::pattern">pattern</a> can be a <code>&amp;str</code>, in which case this function will return true if
the <code>&amp;str</code> is a prefix of this string slice.</p>
<p>The <a href="../../../_core/str/pattern/index.html" title="mod devela::_core::str::pattern">pattern</a> can also be a <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.
These will only be checked against the first character of this string slice.
Look at the second example below regarding behavior for slices of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s.</p>
<h5 id="examples-20"><a class="doc-anchor" href="#examples-20">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bananas = <span class="string">"bananas"</span>;

<span class="macro">assert!</span>(bananas.starts_with(<span class="string">"bana"</span>));
<span class="macro">assert!</span>(!bananas.starts_with(<span class="string">"nana"</span>));</code></pre></div>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bananas = <span class="string">"bananas"</span>;

<span class="comment">// Note that both of these assert successfully.
</span><span class="macro">assert!</span>(bananas.starts_with(<span class="kw-2">&amp;</span>[<span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'n'</span>, <span class="string">'a'</span>]));
<span class="macro">assert!</span>(bananas.starts_with(<span class="kw-2">&amp;</span>[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.ends_with" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1403-1405">Source</a></span><h4 class="code-header">pub fn <a href="#method.ends_with" class="fn">ends_with</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,
    &lt;P as <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>&gt;::<a class="associatedtype" href="../../../_core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type devela::_core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: for&lt;'a&gt; <a class="trait" href="../../../_core/str/pattern/trait.ReverseSearcher.html" title="trait devela::_core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns <code>true</code> if the given pattern matches a suffix of this
string slice.</p>
<p>Returns <code>false</code> if it does not.</p>
<p>The <a href="../../../_core/str/pattern/index.html" title="mod devela::_core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-21"><a class="doc-anchor" href="#examples-21">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bananas = <span class="string">"bananas"</span>;

<span class="macro">assert!</span>(bananas.ends_with(<span class="string">"anas"</span>));
<span class="macro">assert!</span>(!bananas.ends_with(<span class="string">"nana"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.find" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1454">Source</a></span><h4 class="code-header">pub fn <a href="#method.find" class="fn">find</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="enum" href="../../../all/enum.Option.html" title="enum devela::all::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a href="#" class="tooltip" data-notable-ty="Option&lt;usize&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Returns the byte index of the first character of this string slice that
matches the pattern.</p>
<p>Returns <a href="../../../all/enum.Option.html#variant.None" title="variant devela::all::Option::None"><code>None</code></a> if the pattern doesnâ€™t match.</p>
<p>The <a href="../../../_core/str/pattern/index.html" title="mod devela::_core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-22"><a class="doc-anchor" href="#examples-22">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"LÃ¶we è€è™ LÃ©opard Gepardi"</span>;

<span class="macro">assert_eq!</span>(s.find(<span class="string">'L'</span>), <span class="prelude-val">Some</span>(<span class="number">0</span>));
<span class="macro">assert_eq!</span>(s.find(<span class="string">'Ã©'</span>), <span class="prelude-val">Some</span>(<span class="number">14</span>));
<span class="macro">assert_eq!</span>(s.find(<span class="string">"pard"</span>), <span class="prelude-val">Some</span>(<span class="number">17</span>));</code></pre></div>
<p>More complex patterns using point-free style and closures:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"LÃ¶we è€è™ LÃ©opard"</span>;

<span class="macro">assert_eq!</span>(s.find(char::is_whitespace), <span class="prelude-val">Some</span>(<span class="number">5</span>));
<span class="macro">assert_eq!</span>(s.find(char::is_lowercase), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(s.find(|c: char| c.is_whitespace() || c.is_lowercase()), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(s.find(|c: char| (c &lt; <span class="string">'o'</span>) &amp;&amp; (c &gt; <span class="string">'a'</span>)), <span class="prelude-val">Some</span>(<span class="number">4</span>));</code></pre></div>
<p>Not finding the pattern:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"LÃ¶we è€è™ LÃ©opard"</span>;
<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];

<span class="macro">assert_eq!</span>(s.find(x), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rfind" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1500-1502">Source</a></span><h4 class="code-header">pub fn <a href="#method.rfind" class="fn">rfind</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="enum" href="../../../all/enum.Option.html" title="enum devela::all::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a href="#" class="tooltip" data-notable-ty="Option&lt;usize&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,
    &lt;P as <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>&gt;::<a class="associatedtype" href="../../../_core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type devela::_core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: for&lt;'a&gt; <a class="trait" href="../../../_core/str/pattern/trait.ReverseSearcher.html" title="trait devela::_core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns the byte index for the first character of the last match of the pattern in
this string slice.</p>
<p>Returns <a href="../../../all/enum.Option.html#variant.None" title="variant devela::all::Option::None"><code>None</code></a> if the pattern doesnâ€™t match.</p>
<p>The <a href="../../../_core/str/pattern/index.html" title="mod devela::_core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-23"><a class="doc-anchor" href="#examples-23">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"LÃ¶we è€è™ LÃ©opard Gepardi"</span>;

<span class="macro">assert_eq!</span>(s.rfind(<span class="string">'L'</span>), <span class="prelude-val">Some</span>(<span class="number">13</span>));
<span class="macro">assert_eq!</span>(s.rfind(<span class="string">'Ã©'</span>), <span class="prelude-val">Some</span>(<span class="number">14</span>));
<span class="macro">assert_eq!</span>(s.rfind(<span class="string">"pard"</span>), <span class="prelude-val">Some</span>(<span class="number">24</span>));</code></pre></div>
<p>More complex patterns with closures:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"LÃ¶we è€è™ LÃ©opard"</span>;

<span class="macro">assert_eq!</span>(s.rfind(char::is_whitespace), <span class="prelude-val">Some</span>(<span class="number">12</span>));
<span class="macro">assert_eq!</span>(s.rfind(char::is_lowercase), <span class="prelude-val">Some</span>(<span class="number">20</span>));</code></pre></div>
<p>Not finding the pattern:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"LÃ¶we è€è™ LÃ©opard"</span>;
<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];

<span class="macro">assert_eq!</span>(s.rfind(x), <span class="prelude-val">None</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1628">Source</a></span><h4 class="code-header">pub fn <a href="#method.split" class="fn">split</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="../../../_core/str/struct.Split.html" title="struct devela::_core::str::Split">Split</a>&lt;'_, P&gt; <a href="#" class="tooltip" data-notable-ty="Split&lt;&#39;_, P&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over substrings of this string slice, separated by
characters matched by a pattern.</p>
<p>The <a href="../../../_core/str/pattern/index.html" title="mod devela::_core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<p>If there are no matches the full string slice is returned as the only
item in the iterator.</p>
<h5 id="iterator-behavior"><a class="doc-anchor" href="#iterator-behavior">Â§</a>Iterator behavior</h5>
<p>The returned iterator will be a <a href="../../../all/trait.IteratorDoubleEnded.html" title="trait devela::all::IteratorDoubleEnded"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.rsplit" title="method str::rsplit"><code>rsplit</code></a> method can be used.</p>
<h5 id="examples-24"><a class="doc-anchor" href="#examples-24">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"Mary had a little lamb"</span>.split(<span class="string">' '</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"Mary"</span>, <span class="string">"had"</span>, <span class="string">"a"</span>, <span class="string">"little"</span>, <span class="string">"lamb"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">""</span>.split(<span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">""</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lionXXtigerXleopard"</span>.split(<span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"lion"</span>, <span class="string">""</span>, <span class="string">"tiger"</span>, <span class="string">"leopard"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lion::tiger::leopard"</span>.split(<span class="string">"::"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"lion"</span>, <span class="string">"tiger"</span>, <span class="string">"leopard"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"AABBCC"</span>.split(<span class="string">"DD"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"AABBCC"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abc1def2ghi"</span>.split(char::is_numeric).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lionXtigerXleopard"</span>.split(char::is_uppercase).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"lion"</span>, <span class="string">"tiger"</span>, <span class="string">"leopard"</span>]);</code></pre></div>
<p>If the pattern is a slice of chars, split on each occurrence of any of the characters:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"2020-11-03 23:59"</span>.split(<span class="kw-2">&amp;</span>[<span class="string">'-'</span>, <span class="string">' '</span>, <span class="string">':'</span>, <span class="string">'@'</span>][..]).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"2020"</span>, <span class="string">"11"</span>, <span class="string">"03"</span>, <span class="string">"23"</span>, <span class="string">"59"</span>]);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abc1defXghi"</span>.split(|c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"abc"</span>, <span class="string">"def"</span>, <span class="string">"ghi"</span>]);</code></pre></div>
<p>If a string contains multiple contiguous separators, you will end up
with empty strings in the output:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="string">"||||a||b|c"</span>.to_string();
<span class="kw">let </span>d: Vec&lt;<span class="kw">_</span>&gt; = x.split(<span class="string">'|'</span>).collect();

<span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">"a"</span>, <span class="string">""</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]);</code></pre></div>
<p>Contiguous separators are separated by the empty string.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="string">"(///)"</span>.to_string();
<span class="kw">let </span>d: Vec&lt;<span class="kw">_</span>&gt; = x.split(<span class="string">'/'</span>).collect();

<span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">"("</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">")"</span>]);</code></pre></div>
<p>Separators at the start or end of a string are neighbored
by empty strings.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>d: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"010"</span>.split(<span class="string">"0"</span>).collect();
<span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">""</span>, <span class="string">"1"</span>, <span class="string">""</span>]);</code></pre></div>
<p>When the empty string is used as a separator, it separates
every character in the string, along with the beginning
and end of the string.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>f: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"rust"</span>.split(<span class="string">""</span>).collect();
<span class="macro">assert_eq!</span>(f, <span class="kw-2">&amp;</span>[<span class="string">""</span>, <span class="string">"r"</span>, <span class="string">"u"</span>, <span class="string">"s"</span>, <span class="string">"t"</span>, <span class="string">""</span>]);</code></pre></div>
<p>Contiguous separators can lead to possibly surprising behavior
when whitespace is used as the separator. This code is correct:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>x = <span class="string">"    a  b c"</span>.to_string();
<span class="kw">let </span>d: Vec&lt;<span class="kw">_</span>&gt; = x.split(<span class="string">' '</span>).collect();

<span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">""</span>, <span class="string">"a"</span>, <span class="string">""</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]);</code></pre></div>
<p>It does <em>not</em> give you:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">â“˜</a><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(d, <span class="kw-2">&amp;</span>[<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>]);</code></pre></div>
<p>Use <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.split_whitespace" title="method str::split_whitespace"><code>split_whitespace</code></a> for this behavior.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_inclusive" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.51.0">1.51.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1669">Source</a></span><h4 class="code-header">pub fn <a href="#method.split_inclusive" class="fn">split_inclusive</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="../../../_core/str/struct.SplitInclusive.html" title="struct devela::_core::str::SplitInclusive">SplitInclusive</a>&lt;'_, P&gt; <a href="#" class="tooltip" data-notable-ty="SplitInclusive&lt;&#39;_, P&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over substrings of this string slice, separated by
characters matched by a pattern.</p>
<p>Differs from the iterator produced by <code>split</code> in that <code>split_inclusive</code>
leaves the matched part as the terminator of the substring.</p>
<p>The <a href="../../../_core/str/pattern/index.html" title="mod devela::_core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-25"><a class="doc-anchor" href="#examples-25">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"Mary had a little lamb\nlittle lamb\nlittle lamb."
    </span>.split_inclusive(<span class="string">'\n'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"Mary had a little lamb\n"</span>, <span class="string">"little lamb\n"</span>, <span class="string">"little lamb."</span>]);</code></pre></div>
<p>If the last element of the string is matched,
that element will be considered the terminator of the preceding substring.
That substring will be the last item returned by the iterator.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"Mary had a little lamb\nlittle lamb\nlittle lamb.\n"
    </span>.split_inclusive(<span class="string">'\n'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"Mary had a little lamb\n"</span>, <span class="string">"little lamb\n"</span>, <span class="string">"little lamb.\n"</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplit" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1724-1726">Source</a></span><h4 class="code-header">pub fn <a href="#method.rsplit" class="fn">rsplit</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="../../../_core/str/struct.RSplit.html" title="struct devela::_core::str::RSplit">RSplit</a>&lt;'_, P&gt; <a href="#" class="tooltip" data-notable-ty="RSplit&lt;&#39;_, P&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,
    &lt;P as <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>&gt;::<a class="associatedtype" href="../../../_core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type devela::_core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: for&lt;'a&gt; <a class="trait" href="../../../_core/str/pattern/trait.ReverseSearcher.html" title="trait devela::_core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over substrings of the given string slice, separated
by characters matched by a pattern and yielded in reverse order.</p>
<p>The <a href="../../../_core/str/pattern/index.html" title="mod devela::_core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-1"><a class="doc-anchor" href="#iterator-behavior-1">Â§</a>Iterator behavior</h5>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="../../../all/trait.IteratorDoubleEnded.html" title="trait devela::all::IteratorDoubleEnded"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.split" title="method str::split"><code>split</code></a> method can be used.</p>
<h5 id="examples-26"><a class="doc-anchor" href="#examples-26">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"Mary had a little lamb"</span>.rsplit(<span class="string">' '</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"lamb"</span>, <span class="string">"little"</span>, <span class="string">"a"</span>, <span class="string">"had"</span>, <span class="string">"Mary"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">""</span>.rsplit(<span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">""</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lionXXtigerXleopard"</span>.rsplit(<span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"leopard"</span>, <span class="string">"tiger"</span>, <span class="string">""</span>, <span class="string">"lion"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lion::tiger::leopard"</span>.rsplit(<span class="string">"::"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"leopard"</span>, <span class="string">"tiger"</span>, <span class="string">"lion"</span>]);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abc1defXghi"</span>.rsplit(|c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"ghi"</span>, <span class="string">"def"</span>, <span class="string">"abc"</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_terminator" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1773">Source</a></span><h4 class="code-header">pub fn <a href="#method.split_terminator" class="fn">split_terminator</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="../../../_core/str/struct.SplitTerminator.html" title="struct devela::_core::str::SplitTerminator">SplitTerminator</a>&lt;'_, P&gt; <a href="#" class="tooltip" data-notable-ty="SplitTerminator&lt;&#39;_, P&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over substrings of the given string slice, separated
by characters matched by a pattern.</p>
<p>The <a href="../../../_core/str/pattern/index.html" title="mod devela::_core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<p>Equivalent to <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.split" title="method str::split"><code>split</code></a>, except that the trailing substring
is skipped if empty.</p>
<p>This method can be used for string data that is <em>terminated</em>,
rather than <em>separated</em> by a pattern.</p>
<h5 id="iterator-behavior-2"><a class="doc-anchor" href="#iterator-behavior-2">Â§</a>Iterator behavior</h5>
<p>The returned iterator will be a <a href="../../../all/trait.IteratorDoubleEnded.html" title="trait devela::all::IteratorDoubleEnded"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.rsplit_terminator" title="method str::rsplit_terminator"><code>rsplit_terminator</code></a> method can be used.</p>
<h5 id="examples-27"><a class="doc-anchor" href="#examples-27">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"A.B."</span>.split_terminator(<span class="string">'.'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"A"</span>, <span class="string">"B"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"A..B.."</span>.split_terminator(<span class="string">"."</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"A"</span>, <span class="string">""</span>, <span class="string">"B"</span>, <span class="string">""</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"A.B:C.D"</span>.split_terminator(<span class="kw-2">&amp;</span>[<span class="string">'.'</span>, <span class="string">':'</span>][..]).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplit_terminator" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1819-1821">Source</a></span><h4 class="code-header">pub fn <a href="#method.rsplit_terminator" class="fn">rsplit_terminator</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="../../../_core/str/struct.RSplitTerminator.html" title="struct devela::_core::str::RSplitTerminator">RSplitTerminator</a>&lt;'_, P&gt; <a href="#" class="tooltip" data-notable-ty="RSplitTerminator&lt;&#39;_, P&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,
    &lt;P as <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>&gt;::<a class="associatedtype" href="../../../_core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type devela::_core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: for&lt;'a&gt; <a class="trait" href="../../../_core/str/pattern/trait.ReverseSearcher.html" title="trait devela::_core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over substrings of <code>self</code>, separated by characters
matched by a pattern and yielded in reverse order.</p>
<p>The <a href="../../../_core/str/pattern/index.html" title="mod devela::_core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<p>Equivalent to <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.split" title="method str::split"><code>split</code></a>, except that the trailing substring is
skipped if empty.</p>
<p>This method can be used for string data that is <em>terminated</em>,
rather than <em>separated</em> by a pattern.</p>
<h5 id="iterator-behavior-3"><a class="doc-anchor" href="#iterator-behavior-3">Â§</a>Iterator behavior</h5>
<p>The returned iterator requires that the pattern supports a
reverse search, and it will be double ended if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.split_terminator" title="method str::split_terminator"><code>split_terminator</code></a> method can be
used.</p>
<h5 id="examples-28"><a class="doc-anchor" href="#examples-28">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"A.B."</span>.rsplit_terminator(<span class="string">'.'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"B"</span>, <span class="string">"A"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"A..B.."</span>.rsplit_terminator(<span class="string">"."</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">""</span>, <span class="string">"B"</span>, <span class="string">""</span>, <span class="string">"A"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"A.B:C.D"</span>.rsplit_terminator(<span class="kw-2">&amp;</span>[<span class="string">'.'</span>, <span class="string">':'</span>][..]).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"D"</span>, <span class="string">"C"</span>, <span class="string">"B"</span>, <span class="string">"A"</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.splitn" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1874">Source</a></span><h4 class="code-header">pub fn <a href="#method.splitn" class="fn">splitn</a>&lt;P&gt;(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, pat: P) -&gt; <a class="struct" href="../../../_core/str/struct.SplitN.html" title="struct devela::_core::str::SplitN">SplitN</a>&lt;'_, P&gt; <a href="#" class="tooltip" data-notable-ty="SplitN&lt;&#39;_, P&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over substrings of the given string slice, separated
by a pattern, restricted to returning at most <code>n</code> items.</p>
<p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring)
will contain the remainder of the string.</p>
<p>The <a href="../../../_core/str/pattern/index.html" title="mod devela::_core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-4"><a class="doc-anchor" href="#iterator-behavior-4">Â§</a>Iterator behavior</h5>
<p>The returned iterator will not be double ended, because it is
not efficient to support.</p>
<p>If the pattern allows a reverse search, the <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.rsplitn" title="method str::rsplitn"><code>rsplitn</code></a> method can be
used.</p>
<h5 id="examples-29"><a class="doc-anchor" href="#examples-29">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"Mary had a little lambda"</span>.splitn(<span class="number">3</span>, <span class="string">' '</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"Mary"</span>, <span class="string">"had"</span>, <span class="string">"a little lambda"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lionXXtigerXleopard"</span>.splitn(<span class="number">3</span>, <span class="string">"X"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"lion"</span>, <span class="string">""</span>, <span class="string">"tigerXleopard"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abcXdef"</span>.splitn(<span class="number">1</span>, <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"abcXdef"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">""</span>.splitn(<span class="number">1</span>, <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">""</span>]);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abc1defXghi"</span>.splitn(<span class="number">2</span>, |c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"abc"</span>, <span class="string">"defXghi"</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplitn" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1923-1925">Source</a></span><h4 class="code-header">pub fn <a href="#method.rsplitn" class="fn">rsplitn</a>&lt;P&gt;(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>, pat: P) -&gt; <a class="struct" href="../../../_core/str/struct.RSplitN.html" title="struct devela::_core::str::RSplitN">RSplitN</a>&lt;'_, P&gt; <a href="#" class="tooltip" data-notable-ty="RSplitN&lt;&#39;_, P&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,
    &lt;P as <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>&gt;::<a class="associatedtype" href="../../../_core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type devela::_core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: for&lt;'a&gt; <a class="trait" href="../../../_core/str/pattern/trait.ReverseSearcher.html" title="trait devela::_core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over substrings of this string slice, separated by a
pattern, starting from the end of the string, restricted to returning at
most <code>n</code> items.</p>
<p>If <code>n</code> substrings are returned, the last substring (the <code>n</code>th substring)
will contain the remainder of the string.</p>
<p>The <a href="../../../_core/str/pattern/index.html" title="mod devela::_core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-5"><a class="doc-anchor" href="#iterator-behavior-5">Â§</a>Iterator behavior</h5>
<p>The returned iterator will not be double ended, because it is not
efficient to support.</p>
<p>For splitting from the front, the <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.splitn" title="method str::splitn"><code>splitn</code></a> method can be used.</p>
<h5 id="examples-30"><a class="doc-anchor" href="#examples-30">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"Mary had a little lamb"</span>.rsplitn(<span class="number">3</span>, <span class="string">' '</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"lamb"</span>, <span class="string">"little"</span>, <span class="string">"Mary had a"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lionXXtigerXleopard"</span>.rsplitn(<span class="number">3</span>, <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"leopard"</span>, <span class="string">"tiger"</span>, <span class="string">"lionX"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"lion::tiger::leopard"</span>.rsplitn(<span class="number">2</span>, <span class="string">"::"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"leopard"</span>, <span class="string">"lion::tiger"</span>]);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abc1defXghi"</span>.rsplitn(<span class="number">2</span>, |c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"ghi"</span>, <span class="string">"abc1def"</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.split_once" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.52.0">1.52.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1943">Source</a></span><h4 class="code-header">pub fn <a href="#method.split_once" class="fn">split_once</a>&lt;P&gt;(&amp;self, delimiter: P) -&gt; <a class="enum" href="../../../all/enum.Option.html" title="enum devela::all::Option">Option</a>&lt;(&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>)&gt; <a href="#" class="tooltip" data-notable-ty="Option&lt;(&amp;str, &amp;str)&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Splits the string on the first occurrence of the specified delimiter and
returns prefix before delimiter and suffix after delimiter.</p>
<h5 id="examples-31"><a class="doc-anchor" href="#examples-31">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"cfg"</span>.split_once(<span class="string">'='</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">"cfg="</span>.split_once(<span class="string">'='</span>), <span class="prelude-val">Some</span>((<span class="string">"cfg"</span>, <span class="string">""</span>)));
<span class="macro">assert_eq!</span>(<span class="string">"cfg=foo"</span>.split_once(<span class="string">'='</span>), <span class="prelude-val">Some</span>((<span class="string">"cfg"</span>, <span class="string">"foo"</span>)));
<span class="macro">assert_eq!</span>(<span class="string">"cfg=foo=bar"</span>.split_once(<span class="string">'='</span>), <span class="prelude-val">Some</span>((<span class="string">"cfg"</span>, <span class="string">"foo=bar"</span>)));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rsplit_once" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.52.0">1.52.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#1961-1963">Source</a></span><h4 class="code-header">pub fn <a href="#method.rsplit_once" class="fn">rsplit_once</a>&lt;P&gt;(&amp;self, delimiter: P) -&gt; <a class="enum" href="../../../all/enum.Option.html" title="enum devela::all::Option">Option</a>&lt;(&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>)&gt; <a href="#" class="tooltip" data-notable-ty="Option&lt;(&amp;str, &amp;str)&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,
    &lt;P as <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>&gt;::<a class="associatedtype" href="../../../_core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type devela::_core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: for&lt;'a&gt; <a class="trait" href="../../../_core/str/pattern/trait.ReverseSearcher.html" title="trait devela::_core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Splits the string on the last occurrence of the specified delimiter and
returns prefix before delimiter and suffix after delimiter.</p>
<h5 id="examples-32"><a class="doc-anchor" href="#examples-32">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"cfg"</span>.rsplit_once(<span class="string">'='</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">"cfg=foo"</span>.rsplit_once(<span class="string">'='</span>), <span class="prelude-val">Some</span>((<span class="string">"cfg"</span>, <span class="string">"foo"</span>)));
<span class="macro">assert_eq!</span>(<span class="string">"cfg=foo=bar"</span>.rsplit_once(<span class="string">'='</span>), <span class="prelude-val">Some</span>((<span class="string">"cfg=foo"</span>, <span class="string">"bar"</span>)));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2001">Source</a></span><h4 class="code-header">pub fn <a href="#method.matches" class="fn">matches</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="../../../_core/str/struct.Matches.html" title="struct devela::_core::str::Matches">Matches</a>&lt;'_, P&gt; <a href="#" class="tooltip" data-notable-ty="Matches&lt;&#39;_, P&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over the disjoint matches of a pattern within the
given string slice.</p>
<p>The <a href="../../../_core/str/pattern/index.html" title="mod devela::_core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-6"><a class="doc-anchor" href="#iterator-behavior-6">Â§</a>Iterator behavior</h5>
<p>The returned iterator will be a <a href="../../../all/trait.IteratorDoubleEnded.html" title="trait devela::all::IteratorDoubleEnded"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.rmatches" title="method str::rmatches"><code>rmatches</code></a> method can be used.</p>
<h5 id="examples-33"><a class="doc-anchor" href="#examples-33">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abcXXXabcYYYabc"</span>.matches(<span class="string">"abc"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"abc"</span>, <span class="string">"abc"</span>, <span class="string">"abc"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"1abc2abc3"</span>.matches(char::is_numeric).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rmatches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2035-2037">Source</a></span><h4 class="code-header">pub fn <a href="#method.rmatches" class="fn">rmatches</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="../../../_core/str/struct.RMatches.html" title="struct devela::_core::str::RMatches">RMatches</a>&lt;'_, P&gt; <a href="#" class="tooltip" data-notable-ty="RMatches&lt;&#39;_, P&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,
    &lt;P as <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>&gt;::<a class="associatedtype" href="../../../_core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type devela::_core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: for&lt;'a&gt; <a class="trait" href="../../../_core/str/pattern/trait.ReverseSearcher.html" title="trait devela::_core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over the disjoint matches of a pattern within this
string slice, yielded in reverse order.</p>
<p>The <a href="../../../_core/str/pattern/index.html" title="mod devela::_core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-7"><a class="doc-anchor" href="#iterator-behavior-7">Â§</a>Iterator behavior</h5>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="../../../all/trait.IteratorDoubleEnded.html" title="trait devela::all::IteratorDoubleEnded"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.matches" title="method str::matches"><code>matches</code></a> method can be used.</p>
<h5 id="examples-34"><a class="doc-anchor" href="#examples-34">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"abcXXXabcYYYabc"</span>.rmatches(<span class="string">"abc"</span>).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"abc"</span>, <span class="string">"abc"</span>, <span class="string">"abc"</span>]);

<span class="kw">let </span>v: Vec&lt;<span class="kw-2">&amp;</span>str&gt; = <span class="string">"1abc2abc3"</span>.rmatches(char::is_numeric).collect();
<span class="macro">assert_eq!</span>(v, [<span class="string">"3"</span>, <span class="string">"2"</span>, <span class="string">"1"</span>]);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.match_indices" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2079">Source</a></span><h4 class="code-header">pub fn <a href="#method.match_indices" class="fn">match_indices</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="../../../_core/str/struct.MatchIndices.html" title="struct devela::_core::str::MatchIndices">MatchIndices</a>&lt;'_, P&gt; <a href="#" class="tooltip" data-notable-ty="MatchIndices&lt;&#39;_, P&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over the disjoint matches of a pattern within this string
slice as well as the index that the match starts at.</p>
<p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices
corresponding to the first match are returned.</p>
<p>The <a href="../../../_core/str/pattern/index.html" title="mod devela::_core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-8"><a class="doc-anchor" href="#iterator-behavior-8">Â§</a>Iterator behavior</h5>
<p>The returned iterator will be a <a href="../../../all/trait.IteratorDoubleEnded.html" title="trait devela::all::IteratorDoubleEnded"><code>DoubleEndedIterator</code></a> if the pattern
allows a reverse search and forward/reverse search yields the same
elements. This is true for, e.g., <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, but not for <code>&amp;str</code>.</p>
<p>If the pattern allows a reverse search but its results might differ
from a forward search, the <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.rmatch_indices" title="method str::rmatch_indices"><code>rmatch_indices</code></a> method can be used.</p>
<h5 id="examples-35"><a class="doc-anchor" href="#examples-35">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"abcXXXabcYYYabc"</span>.match_indices(<span class="string">"abc"</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">0</span>, <span class="string">"abc"</span>), (<span class="number">6</span>, <span class="string">"abc"</span>), (<span class="number">12</span>, <span class="string">"abc"</span>)]);

<span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"1abcabc2"</span>.match_indices(<span class="string">"abc"</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">1</span>, <span class="string">"abc"</span>), (<span class="number">4</span>, <span class="string">"abc"</span>)]);

<span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"ababa"</span>.match_indices(<span class="string">"aba"</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">0</span>, <span class="string">"aba"</span>)]); <span class="comment">// only the first `aba`</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.rmatch_indices" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.5.0">1.5.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2119-2121">Source</a></span><h4 class="code-header">pub fn <a href="#method.rmatch_indices" class="fn">rmatch_indices</a>&lt;P&gt;(&amp;self, pat: P) -&gt; <a class="struct" href="../../../_core/str/struct.RMatchIndices.html" title="struct devela::_core::str::RMatchIndices">RMatchIndices</a>&lt;'_, P&gt; <a href="#" class="tooltip" data-notable-ty="RMatchIndices&lt;&#39;_, P&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,
    &lt;P as <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>&gt;::<a class="associatedtype" href="../../../_core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type devela::_core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: for&lt;'a&gt; <a class="trait" href="../../../_core/str/pattern/trait.ReverseSearcher.html" title="trait devela::_core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns an iterator over the disjoint matches of a pattern within <code>self</code>,
yielded in reverse order along with the index of the match.</p>
<p>For matches of <code>pat</code> within <code>self</code> that overlap, only the indices
corresponding to the last match are returned.</p>
<p>The <a href="../../../_core/str/pattern/index.html" title="mod devela::_core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="iterator-behavior-9"><a class="doc-anchor" href="#iterator-behavior-9">Â§</a>Iterator behavior</h5>
<p>The returned iterator requires that the pattern supports a reverse
search, and it will be a <a href="../../../all/trait.IteratorDoubleEnded.html" title="trait devela::all::IteratorDoubleEnded"><code>DoubleEndedIterator</code></a> if a forward/reverse
search yields the same elements.</p>
<p>For iterating from the front, the <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.match_indices" title="method str::match_indices"><code>match_indices</code></a> method can be used.</p>
<h5 id="examples-36"><a class="doc-anchor" href="#examples-36">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"abcXXXabcYYYabc"</span>.rmatch_indices(<span class="string">"abc"</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">12</span>, <span class="string">"abc"</span>), (<span class="number">6</span>, <span class="string">"abc"</span>), (<span class="number">0</span>, <span class="string">"abc"</span>)]);

<span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"1abcabc2"</span>.rmatch_indices(<span class="string">"abc"</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">4</span>, <span class="string">"abc"</span>), (<span class="number">1</span>, <span class="string">"abc"</span>)]);

<span class="kw">let </span>v: Vec&lt;<span class="kw">_</span>&gt; = <span class="string">"ababa"</span>.rmatch_indices(<span class="string">"aba"</span>).collect();
<span class="macro">assert_eq!</span>(v, [(<span class="number">2</span>, <span class="string">"aba"</span>)]); <span class="comment">// only the last `aba`</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2143">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim" class="fn">trim</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <a href="#" class="tooltip" data-notable-ty="&amp;str">â“˜</a></h4></section></summary><div class="docblock"><p>Returns a string slice with leading and trailing whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>, which includes newlines.</p>
<h5 id="examples-37"><a class="doc-anchor" href="#examples-37">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"\n Hello\tworld\t\n"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"Hello\tworld"</span>, s.trim());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_start" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2182">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_start" class="fn">trim_start</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <a href="#" class="tooltip" data-notable-ty="&amp;str">â“˜</a></h4></section></summary><div class="docblock"><p>Returns a string slice with leading whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>, which includes newlines.</p>
<h5 id="text-directionality"><a class="doc-anchor" href="#text-directionality">Â§</a>Text directionality</h5>
<p>A string is a sequence of bytes. <code>start</code> in this context means the first
position of that byte string; for a left-to-right language like English or
Russian, this will be left side, and for right-to-left languages like
Arabic or Hebrew, this will be the right side.</p>
<h5 id="examples-38"><a class="doc-anchor" href="#examples-38">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"\n Hello\tworld\t\n"</span>;
<span class="macro">assert_eq!</span>(<span class="string">"Hello\tworld\t\n"</span>, s.trim_start());</code></pre></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"  English  "</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'E'</span>) == s.trim_start().chars().next());

<span class="kw">let </span>s = <span class="string">"  ×¢×‘×¨×™×ª  "</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'×¢'</span>) == s.trim_start().chars().next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_end" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2221">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_end" class="fn">trim_end</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <a href="#" class="tooltip" data-notable-ty="&amp;str">â“˜</a></h4></section></summary><div class="docblock"><p>Returns a string slice with trailing whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>, which includes newlines.</p>
<h5 id="text-directionality-1"><a class="doc-anchor" href="#text-directionality-1">Â§</a>Text directionality</h5>
<p>A string is a sequence of bytes. <code>end</code> in this context means the last
position of that byte string; for a left-to-right language like English or
Russian, this will be right side, and for right-to-left languages like
Arabic or Hebrew, this will be the left side.</p>
<h5 id="examples-39"><a class="doc-anchor" href="#examples-39">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"\n Hello\tworld\t\n"</span>;
<span class="macro">assert_eq!</span>(<span class="string">"\n Hello\tworld"</span>, s.trim_end());</code></pre></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"  English  "</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'h'</span>) == s.trim_end().chars().rev().next());

<span class="kw">let </span>s = <span class="string">"  ×¢×‘×¨×™×ª  "</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'×ª'</span>) == s.trim_end().chars().rev().next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_left" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2261">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_left" class="fn">trim_left</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <a href="#" class="tooltip" data-notable-ty="&amp;str">â“˜</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.33.0: superseded by <code>trim_start</code></span></div></span></summary><div class="docblock"><p>Returns a string slice with leading whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h5 id="text-directionality-2"><a class="doc-anchor" href="#text-directionality-2">Â§</a>Text directionality</h5>
<p>A string is a sequence of bytes. â€˜Leftâ€™ in this context means the first
position of that byte string; for a language like Arabic or Hebrew
which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be
the <em>right</em> side, not the left.</p>
<h5 id="examples-40"><a class="doc-anchor" href="#examples-40">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">" Hello\tworld\t"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"Hello\tworld\t"</span>, s.trim_left());</code></pre></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"  English"</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'E'</span>) == s.trim_left().chars().next());

<span class="kw">let </span>s = <span class="string">"  ×¢×‘×¨×™×ª"</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'×¢'</span>) == s.trim_left().chars().next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_right" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2301">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_right" class="fn">trim_right</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <a href="#" class="tooltip" data-notable-ty="&amp;str">â“˜</a></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.33.0: superseded by <code>trim_end</code></span></div></span></summary><div class="docblock"><p>Returns a string slice with trailing whitespace removed.</p>
<p>â€˜Whitespaceâ€™ is defined according to the terms of the Unicode Derived
Core Property <code>White_Space</code>.</p>
<h5 id="text-directionality-3"><a class="doc-anchor" href="#text-directionality-3">Â§</a>Text directionality</h5>
<p>A string is a sequence of bytes. â€˜Rightâ€™ in this context means the last
position of that byte string; for a language like Arabic or Hebrew
which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be
the <em>left</em> side, not the right.</p>
<h5 id="examples-41"><a class="doc-anchor" href="#examples-41">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">" Hello\tworld\t"</span>;

<span class="macro">assert_eq!</span>(<span class="string">" Hello\tworld"</span>, s.trim_right());</code></pre></div>
<p>Directionality:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"English  "</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'h'</span>) == s.trim_right().chars().rev().next());

<span class="kw">let </span>s = <span class="string">"×¢×‘×¨×™×ª  "</span>;
<span class="macro">assert!</span>(<span class="prelude-val">Some</span>(<span class="string">'×ª'</span>) == s.trim_right().chars().rev().next());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2334-2336">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_matches" class="fn">trim_matches</a>&lt;P&gt;(&amp;self, pat: P) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <a href="#" class="tooltip" data-notable-ty="&amp;str">â“˜</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,
    &lt;P as <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>&gt;::<a class="associatedtype" href="../../../_core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type devela::_core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: for&lt;'a&gt; <a class="trait" href="../../../_core/str/pattern/trait.DoubleEndedSearcher.html" title="trait devela::_core::str::pattern::DoubleEndedSearcher">DoubleEndedSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a string slice with all prefixes and suffixes that match a
pattern repeatedly removed.</p>
<p>The <a href="../../../_core/str/pattern/index.html" title="mod devela::_core::str::pattern">pattern</a> can be a <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a function
or closure that determines if a character matches.</p>
<h5 id="examples-42"><a class="doc-anchor" href="#examples-42">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"11foo1bar11"</span>.trim_matches(<span class="string">'1'</span>), <span class="string">"foo1bar"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"123foo1bar123"</span>.trim_matches(char::is_numeric), <span class="string">"foo1bar"</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];
<span class="macro">assert_eq!</span>(<span class="string">"12foo1bar12"</span>.trim_matches(x), <span class="string">"foo1bar"</span>);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"1foo1barXX"</span>.trim_matches(|c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>), <span class="string">"foo1bar"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_start_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2381">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_start_matches" class="fn">trim_start_matches</a>&lt;P&gt;(&amp;self, pat: P) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <a href="#" class="tooltip" data-notable-ty="&amp;str">â“˜</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Returns a string slice with all prefixes that match a pattern
repeatedly removed.</p>
<p>The <a href="../../../_core/str/pattern/index.html" title="mod devela::_core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-4"><a class="doc-anchor" href="#text-directionality-4">Â§</a>Text directionality</h5>
<p>A string is a sequence of bytes. <code>start</code> in this context means the first
position of that byte string; for a left-to-right language like English or
Russian, this will be left side, and for right-to-left languages like
Arabic or Hebrew, this will be the right side.</p>
<h5 id="examples-43"><a class="doc-anchor" href="#examples-43">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"11foo1bar11"</span>.trim_start_matches(<span class="string">'1'</span>), <span class="string">"foo1bar11"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"123foo1bar123"</span>.trim_start_matches(char::is_numeric), <span class="string">"foo1bar123"</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];
<span class="macro">assert_eq!</span>(<span class="string">"12foo1bar12"</span>.trim_start_matches(x), <span class="string">"foo1bar12"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.strip_prefix" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2415">Source</a></span><h4 class="code-header">pub fn <a href="#method.strip_prefix" class="fn">strip_prefix</a>&lt;P&gt;(&amp;self, prefix: P) -&gt; <a class="enum" href="../../../all/enum.Option.html" title="enum devela::all::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt; <a href="#" class="tooltip" data-notable-ty="Option&lt;&amp;str&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Returns a string slice with the prefix removed.</p>
<p>If the string starts with the pattern <code>prefix</code>, returns the substring after the prefix,
wrapped in <code>Some</code>. Unlike <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.trim_start_matches" title="method str::trim_start_matches"><code>trim_start_matches</code></a>, this method removes the prefix exactly once.</p>
<p>If the string does not start with <code>prefix</code>, returns <code>None</code>.</p>
<p>The <a href="../../../_core/str/pattern/index.html" title="mod devela::_core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-44"><a class="doc-anchor" href="#examples-44">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"foo:bar"</span>.strip_prefix(<span class="string">"foo:"</span>), <span class="prelude-val">Some</span>(<span class="string">"bar"</span>));
<span class="macro">assert_eq!</span>(<span class="string">"foo:bar"</span>.strip_prefix(<span class="string">"bar"</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">"foofoo"</span>.strip_prefix(<span class="string">"foo"</span>), <span class="prelude-val">Some</span>(<span class="string">"foo"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.strip_suffix" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.45.0">1.45.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2443-2445">Source</a></span><h4 class="code-header">pub fn <a href="#method.strip_suffix" class="fn">strip_suffix</a>&lt;P&gt;(&amp;self, suffix: P) -&gt; <a class="enum" href="../../../all/enum.Option.html" title="enum devela::all::Option">Option</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt; <a href="#" class="tooltip" data-notable-ty="Option&lt;&amp;str&gt;">â“˜</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,
    &lt;P as <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>&gt;::<a class="associatedtype" href="../../../_core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type devela::_core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: for&lt;'a&gt; <a class="trait" href="../../../_core/str/pattern/trait.ReverseSearcher.html" title="trait devela::_core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a string slice with the suffix removed.</p>
<p>If the string ends with the pattern <code>suffix</code>, returns the substring before the suffix,
wrapped in <code>Some</code>.  Unlike <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.trim_end_matches" title="method str::trim_end_matches"><code>trim_end_matches</code></a>, this method removes the suffix exactly once.</p>
<p>If the string does not end with <code>suffix</code>, returns <code>None</code>.</p>
<p>The <a href="../../../_core/str/pattern/index.html" title="mod devela::_core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-45"><a class="doc-anchor" href="#examples-45">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"bar:foo"</span>.strip_suffix(<span class="string">":foo"</span>), <span class="prelude-val">Some</span>(<span class="string">"bar"</span>));
<span class="macro">assert_eq!</span>(<span class="string">"bar:foo"</span>.strip_suffix(<span class="string">"bar"</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq!</span>(<span class="string">"foofoo"</span>.strip_suffix(<span class="string">"foo"</span>), <span class="prelude-val">Some</span>(<span class="string">"foo"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_prefix" class="method"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2483">Source</a><h4 class="code-header">pub fn <a href="#method.trim_prefix" class="fn">trim_prefix</a>&lt;P&gt;(&amp;self, prefix: P) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <a href="#" class="tooltip" data-notable-ty="&amp;str">â“˜</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,</div></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>trim_prefix_suffix</code>)</span></div></span></summary><div class="docblock"><p>Returns a string slice with the optional prefix removed.</p>
<p>If the string starts with the pattern <code>prefix</code>, returns the substring after the prefix.
Unlike <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.strip_prefix" title="method str::strip_prefix"><code>strip_prefix</code></a>, this method always returns <code>&amp;str</code> for easy method chaining,
instead of returning <a href="../../../all/enum.Option.html" title="enum devela::all::Option"><code>Option&lt;&amp;str&gt;</code></a>.</p>
<p>If the string does not start with <code>prefix</code>, returns the original string unchanged.</p>
<p>The <a href="../../../_core/str/pattern/index.html" title="mod devela::_core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-46"><a class="doc-anchor" href="#examples-46">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(trim_prefix_suffix)]

</span><span class="comment">// Prefix present - removes it
</span><span class="macro">assert_eq!</span>(<span class="string">"foo:bar"</span>.trim_prefix(<span class="string">"foo:"</span>), <span class="string">"bar"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"foofoo"</span>.trim_prefix(<span class="string">"foo"</span>), <span class="string">"foo"</span>);

<span class="comment">// Prefix absent - returns original string
</span><span class="macro">assert_eq!</span>(<span class="string">"foo:bar"</span>.trim_prefix(<span class="string">"bar"</span>), <span class="string">"foo:bar"</span>);

<span class="comment">// Method chaining example
</span><span class="macro">assert_eq!</span>(<span class="string">"&lt;https://example.com/&gt;"</span>.trim_prefix(<span class="string">'&lt;'</span>).trim_suffix(<span class="string">'&gt;'</span>), <span class="string">"https://example.com/"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_suffix" class="method"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2520-2522">Source</a><h4 class="code-header">pub fn <a href="#method.trim_suffix" class="fn">trim_suffix</a>&lt;P&gt;(&amp;self, suffix: P) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <a href="#" class="tooltip" data-notable-ty="&amp;str">â“˜</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,
    &lt;P as <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>&gt;::<a class="associatedtype" href="../../../_core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type devela::_core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: for&lt;'a&gt; <a class="trait" href="../../../_core/str/pattern/trait.ReverseSearcher.html" title="trait devela::_core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>trim_prefix_suffix</code>)</span></div></span></summary><div class="docblock"><p>Returns a string slice with the optional suffix removed.</p>
<p>If the string ends with the pattern <code>suffix</code>, returns the substring before the suffix.
Unlike <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.strip_suffix" title="method str::strip_suffix"><code>strip_suffix</code></a>, this method always returns <code>&amp;str</code> for easy method chaining,
instead of returning <a href="../../../all/enum.Option.html" title="enum devela::all::Option"><code>Option&lt;&amp;str&gt;</code></a>.</p>
<p>If the string does not end with <code>suffix</code>, returns the original string unchanged.</p>
<p>The <a href="../../../_core/str/pattern/index.html" title="mod devela::_core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="examples-47"><a class="doc-anchor" href="#examples-47">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(trim_prefix_suffix)]

</span><span class="comment">// Suffix present - removes it
</span><span class="macro">assert_eq!</span>(<span class="string">"bar:foo"</span>.trim_suffix(<span class="string">":foo"</span>), <span class="string">"bar"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"foofoo"</span>.trim_suffix(<span class="string">"foo"</span>), <span class="string">"foo"</span>);

<span class="comment">// Suffix absent - returns original string
</span><span class="macro">assert_eq!</span>(<span class="string">"bar:foo"</span>.trim_suffix(<span class="string">"bar"</span>), <span class="string">"bar:foo"</span>);

<span class="comment">// Method chaining example
</span><span class="macro">assert_eq!</span>(<span class="string">"&lt;https://example.com/&gt;"</span>.trim_prefix(<span class="string">'&lt;'</span>).trim_suffix(<span class="string">'&gt;'</span>), <span class="string">"https://example.com/"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_end_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.30.0">1.30.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2563-2565">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_end_matches" class="fn">trim_end_matches</a>&lt;P&gt;(&amp;self, pat: P) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <a href="#" class="tooltip" data-notable-ty="&amp;str">â“˜</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,
    &lt;P as <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>&gt;::<a class="associatedtype" href="../../../_core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type devela::_core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: for&lt;'a&gt; <a class="trait" href="../../../_core/str/pattern/trait.ReverseSearcher.html" title="trait devela::_core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a string slice with all suffixes that match a pattern
repeatedly removed.</p>
<p>The <a href="../../../_core/str/pattern/index.html" title="mod devela::_core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-5"><a class="doc-anchor" href="#text-directionality-5">Â§</a>Text directionality</h5>
<p>A string is a sequence of bytes. <code>end</code> in this context means the last
position of that byte string; for a left-to-right language like English or
Russian, this will be right side, and for right-to-left languages like
Arabic or Hebrew, this will be the left side.</p>
<h5 id="examples-48"><a class="doc-anchor" href="#examples-48">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"11foo1bar11"</span>.trim_end_matches(<span class="string">'1'</span>), <span class="string">"11foo1bar"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"123foo1bar123"</span>.trim_end_matches(char::is_numeric), <span class="string">"123foo1bar"</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];
<span class="macro">assert_eq!</span>(<span class="string">"12foo1bar12"</span>.trim_end_matches(x), <span class="string">"12foo1bar"</span>);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"1fooX"</span>.trim_end_matches(|c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>), <span class="string">"1foo"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_left_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2607">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_left_matches" class="fn">trim_left_matches</a>&lt;P&gt;(&amp;self, pat: P) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <a href="#" class="tooltip" data-notable-ty="&amp;str">â“˜</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,</div></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.33.0: superseded by <code>trim_start_matches</code></span></div></span></summary><div class="docblock"><p>Returns a string slice with all prefixes that match a pattern
repeatedly removed.</p>
<p>The <a href="../../../_core/str/pattern/index.html" title="mod devela::_core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-6"><a class="doc-anchor" href="#text-directionality-6">Â§</a>Text directionality</h5>
<p>A string is a sequence of bytes. â€˜Leftâ€™ in this context means the first
position of that byte string; for a language like Arabic or Hebrew
which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be
the <em>right</em> side, not the left.</p>
<h5 id="examples-49"><a class="doc-anchor" href="#examples-49">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"11foo1bar11"</span>.trim_left_matches(<span class="string">'1'</span>), <span class="string">"foo1bar11"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"123foo1bar123"</span>.trim_left_matches(char::is_numeric), <span class="string">"foo1bar123"</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];
<span class="macro">assert_eq!</span>(<span class="string">"12foo1bar12"</span>.trim_left_matches(x), <span class="string">"foo1bar12"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_right_matches" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2650-2652">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_right_matches" class="fn">trim_right_matches</a>&lt;P&gt;(&amp;self, pat: P) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <a href="#" class="tooltip" data-notable-ty="&amp;str">â“˜</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,
    &lt;P as <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>&gt;::<a class="associatedtype" href="../../../_core/str/pattern/trait.Pattern.html#associatedtype.Searcher" title="type devela::_core::str::pattern::Pattern::Searcher">Searcher</a>&lt;'a&gt;: for&lt;'a&gt; <a class="trait" href="../../../_core/str/pattern/trait.ReverseSearcher.html" title="trait devela::_core::str::pattern::ReverseSearcher">ReverseSearcher</a>&lt;'a&gt;,</div></h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">ğŸ‘</span><span>Deprecated since 1.33.0: superseded by <code>trim_end_matches</code></span></div></span></summary><div class="docblock"><p>Returns a string slice with all suffixes that match a pattern
repeatedly removed.</p>
<p>The <a href="../../../_core/str/pattern/index.html" title="mod devela::_core::str::pattern">pattern</a> can be a <code>&amp;str</code>, <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>, a slice of <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html" title="primitive char"><code>char</code></a>s, or a
function or closure that determines if a character matches.</p>
<h5 id="text-directionality-7"><a class="doc-anchor" href="#text-directionality-7">Â§</a>Text directionality</h5>
<p>A string is a sequence of bytes. â€˜Rightâ€™ in this context means the last
position of that byte string; for a language like Arabic or Hebrew
which are â€˜right to leftâ€™ rather than â€˜left to rightâ€™, this will be
the <em>left</em> side, not the right.</p>
<h5 id="examples-50"><a class="doc-anchor" href="#examples-50">Â§</a>Examples</h5>
<p>Simple patterns:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"11foo1bar11"</span>.trim_right_matches(<span class="string">'1'</span>), <span class="string">"11foo1bar"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"123foo1bar123"</span>.trim_right_matches(char::is_numeric), <span class="string">"123foo1bar"</span>);

<span class="kw">let </span>x: <span class="kw-2">&amp;</span>[<span class="kw">_</span>] = <span class="kw-2">&amp;</span>[<span class="string">'1'</span>, <span class="string">'2'</span>];
<span class="macro">assert_eq!</span>(<span class="string">"12foo1bar12"</span>.trim_right_matches(x), <span class="string">"12foo1bar"</span>);</code></pre></div>
<p>A more complex pattern, using a closure:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"1fooX"</span>.trim_right_matches(|c| c == <span class="string">'1' </span>|| c == <span class="string">'X'</span>), <span class="string">"1foo"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.parse" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2701">Source</a></span><h4 class="code-header">pub fn <a href="#method.parse" class="fn">parse</a>&lt;F&gt;(&amp;self) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;F, &lt;F as <a class="trait" href="../../../all/trait.FromStr.html" title="trait devela::all::FromStr">FromStr</a>&gt;::<a class="associatedtype" href="../../../all/trait.FromStr.html#associatedtype.Err" title="type devela::all::FromStr::Err">Err</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;F, &lt;F as FromStr&gt;::Err&gt;">â“˜</a><div class="where">where
    F: <a class="trait" href="../../../all/trait.FromStr.html" title="trait devela::all::FromStr">FromStr</a>,</div></h4></section></summary><div class="docblock"><p>Parses this string slice into another type.</p>
<p>Because <code>parse</code> is so general, it can cause problems with type
inference. As such, <code>parse</code> is one of the few times youâ€™ll see
the syntax affectionately known as the â€˜turbofishâ€™: <code>::&lt;&gt;</code>. This
helps the inference algorithm understand specifically which type
youâ€™re trying to parse into.</p>
<p><code>parse</code> can parse into any type that implements the <a href="../../../all/trait.FromStr.html" title="trait devela::all::FromStr"><code>FromStr</code></a> trait.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">Â§</a>Errors</h5>
<p>Will return <a href="../../../all/trait.FromStr.html#associatedtype.Err" title="associated type devela::all::FromStr::Err"><code>Err</code></a> if itâ€™s not possible to parse this string slice into
the desired type.</p>
<h5 id="examples-51"><a class="doc-anchor" href="#examples-51">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>four: u32 = <span class="string">"4"</span>.parse().unwrap();

<span class="macro">assert_eq!</span>(<span class="number">4</span>, four);</code></pre></div>
<p>Using the â€˜turbofishâ€™ instead of annotating <code>four</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>four = <span class="string">"4"</span>.parse::&lt;u32&gt;();

<span class="macro">assert_eq!</span>(<span class="prelude-val">Ok</span>(<span class="number">4</span>), four);</code></pre></div>
<p>Failing to parse:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>nope = <span class="string">"j"</span>.parse::&lt;u32&gt;();

<span class="macro">assert!</span>(nope.is_err());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.is_ascii" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2720">Source</a></span><h4 class="code-header">pub fn <a href="#method.is_ascii" class="fn">is_ascii</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if all characters in this string are within the ASCII range.</p>
<h5 id="examples-52"><a class="doc-anchor" href="#examples-52">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>ascii = <span class="string">"hello!\n"</span>;
<span class="kw">let </span>non_ascii = <span class="string">"GrÃ¼ÃŸe, JÃ¼rgen â¤"</span>;

<span class="macro">assert!</span>(ascii.is_ascii());
<span class="macro">assert!</span>(!non_ascii.is_ascii());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_ascii" class="method"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2732">Source</a><h4 class="code-header">pub fn <a href="#method.as_ascii" class="fn">as_ascii</a>(&amp;self) -&gt; <a class="enum" href="../../../all/enum.Option.html" title="enum devela::all::Option">Option</a>&lt;&amp;[<a class="enum" href="../../../_core/ascii/enum.Char.html" title="enum devela::_core::ascii::Char">AsciiChar</a>]&gt; <a href="#" class="tooltip" data-notable-ty="Option&lt;&amp;[AsciiChar]&gt;">â“˜</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>ascii_char</code>)</span></div></span></summary><div class="docblock"><p>If this string slice <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.is_ascii" title="method str::is_ascii"><code>is_ascii</code></a>, returns it as a slice
of <a href="../../../_core/ascii/enum.Char.html" title="enum devela::_core::ascii::Char">ASCII characters</a>, otherwise returns <code>None</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_ascii_unchecked" class="method"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2746">Source</a><h4 class="code-header">pub unsafe fn <a href="#method.as_ascii_unchecked" class="fn">as_ascii_unchecked</a>(&amp;self) -&gt; &amp;[<a class="enum" href="../../../_core/ascii/enum.Char.html" title="enum devela::_core::ascii::Char">AsciiChar</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[AsciiChar]">â“˜</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>ascii_char</code>)</span></div></span></summary><div class="docblock"><p>Converts this string slice into a slice of <a href="../../../_core/ascii/enum.Char.html" title="enum devela::_core::ascii::Char">ASCII characters</a>,
without checking whether they are valid.</p>
<h5 id="safety-2"><a class="doc-anchor" href="#safety-2">Â§</a>Safety</h5>
<p>Every character in this string must be ASCII, or else this is UB.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.eq_ignore_ascii_case" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2774">Source</a></span><h4 class="code-header">pub fn <a href="#method.eq_ignore_ascii_case" class="fn">eq_ignore_ascii_case</a>(&amp;self, other: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks that two strings are an ASCII case-insensitive match.</p>
<p>Same as <code>to_ascii_lowercase(a) == to_ascii_lowercase(b)</code>,
but without allocating and copying temporaries.</p>
<h5 id="examples-53"><a class="doc-anchor" href="#examples-53">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert!</span>(<span class="string">"Ferris"</span>.eq_ignore_ascii_case(<span class="string">"FERRIS"</span>));
<span class="macro">assert!</span>(<span class="string">"FerrÃ¶s"</span>.eq_ignore_ascii_case(<span class="string">"FERRÃ¶S"</span>));
<span class="macro">assert!</span>(!<span class="string">"FerrÃ¶s"</span>.eq_ignore_ascii_case(<span class="string">"FERRÃ–S"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_ascii_start" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2853">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_ascii_start" class="fn">trim_ascii_start</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <a href="#" class="tooltip" data-notable-ty="&amp;str">â“˜</a></h4></section></summary><div class="docblock"><p>Returns a string slice with leading ASCII whitespace removed.</p>
<p>â€˜Whitespaceâ€™ refers to the definition used by
<a href="https://doc.rust-lang.org/nightly/std/primitive.u8.html#method.is_ascii_whitespace" title="method u8::is_ascii_whitespace"><code>u8::is_ascii_whitespace</code></a>.</p>
<h5 id="examples-54"><a class="doc-anchor" href="#examples-54">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">" \t \u{3000}hello world\n"</span>.trim_ascii_start(), <span class="string">"\u{3000}hello world\n"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"  "</span>.trim_ascii_start(), <span class="string">""</span>);
<span class="macro">assert_eq!</span>(<span class="string">""</span>.trim_ascii_start(), <span class="string">""</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_ascii_end" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2878">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_ascii_end" class="fn">trim_ascii_end</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <a href="#" class="tooltip" data-notable-ty="&amp;str">â“˜</a></h4></section></summary><div class="docblock"><p>Returns a string slice with trailing ASCII whitespace removed.</p>
<p>â€˜Whitespaceâ€™ refers to the definition used by
<a href="https://doc.rust-lang.org/nightly/std/primitive.u8.html#method.is_ascii_whitespace" title="method u8::is_ascii_whitespace"><code>u8::is_ascii_whitespace</code></a>.</p>
<h5 id="examples-55"><a class="doc-anchor" href="#examples-55">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"\r hello world\u{3000}\n "</span>.trim_ascii_end(), <span class="string">"\r hello world\u{3000}"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"  "</span>.trim_ascii_end(), <span class="string">""</span>);
<span class="macro">assert_eq!</span>(<span class="string">""</span>.trim_ascii_end(), <span class="string">""</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.trim_ascii" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.80.0">1.80.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2904">Source</a></span><h4 class="code-header">pub fn <a href="#method.trim_ascii" class="fn">trim_ascii</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <a href="#" class="tooltip" data-notable-ty="&amp;str">â“˜</a></h4></section></summary><div class="docblock"><p>Returns a string slice with leading and trailing ASCII whitespace
removed.</p>
<p>â€˜Whitespaceâ€™ refers to the definition used by
<a href="https://doc.rust-lang.org/nightly/std/primitive.u8.html#method.is_ascii_whitespace" title="method u8::is_ascii_whitespace"><code>u8::is_ascii_whitespace</code></a>.</p>
<h5 id="examples-56"><a class="doc-anchor" href="#examples-56">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"\r hello world\n "</span>.trim_ascii(), <span class="string">"hello world"</span>);
<span class="macro">assert_eq!</span>(<span class="string">"  "</span>.trim_ascii(), <span class="string">""</span>);
<span class="macro">assert_eq!</span>(<span class="string">""</span>.trim_ascii(), <span class="string">""</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.escape_debug" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2947">Source</a></span><h4 class="code-header">pub fn <a href="#method.escape_debug" class="fn">escape_debug</a>(&amp;self) -&gt; <a class="struct" href="../../../_core/str/struct.EscapeDebug.html" title="struct devela::_core::str::EscapeDebug">EscapeDebug</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="EscapeDebug&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Returns an iterator that escapes each char in <code>self</code> with <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html#method.escape_debug" title="method char::escape_debug"><code>char::escape_debug</code></a>.</p>
<p>Note: only extended grapheme codepoints that begin the string will be
escaped.</p>
<h5 id="examples-57"><a class="doc-anchor" href="#examples-57">Â§</a>Examples</h5>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for </span>c <span class="kw">in </span><span class="string">"â¤\n!"</span>.escape_debug() {
    <span class="macro">print!</span>(<span class="string">"{c}"</span>);
}
<span class="macro">println!</span>();</code></pre></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, <span class="string">"â¤\n!"</span>.escape_debug());</code></pre></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"â¤\\n!"</span>);</code></pre></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"â¤\n!"</span>.escape_debug().to_string(), <span class="string">"â¤\\n!"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.escape_default" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#2993">Source</a></span><h4 class="code-header">pub fn <a href="#method.escape_default" class="fn">escape_default</a>(&amp;self) -&gt; <a class="struct" href="../../../_core/str/struct.EscapeDefault.html" title="struct devela::_core::str::EscapeDefault">EscapeDefault</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="EscapeDefault&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Returns an iterator that escapes each char in <code>self</code> with <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html#method.escape_default" title="method char::escape_default"><code>char::escape_default</code></a>.</p>
<h5 id="examples-58"><a class="doc-anchor" href="#examples-58">Â§</a>Examples</h5>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for </span>c <span class="kw">in </span><span class="string">"â¤\n!"</span>.escape_default() {
    <span class="macro">print!</span>(<span class="string">"{c}"</span>);
}
<span class="macro">println!</span>();</code></pre></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, <span class="string">"â¤\n!"</span>.escape_default());</code></pre></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"\\u{{2764}}\\n!"</span>);</code></pre></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"â¤\n!"</span>.escape_default().to_string(), <span class="string">"\\u{2764}\\n!"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.escape_unicode" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.34.0">1.34.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3031">Source</a></span><h4 class="code-header">pub fn <a href="#method.escape_unicode" class="fn">escape_unicode</a>(&amp;self) -&gt; <a class="struct" href="../../../_core/str/struct.EscapeUnicode.html" title="struct devela::_core::str::EscapeUnicode">EscapeUnicode</a>&lt;'_&gt; <a href="#" class="tooltip" data-notable-ty="EscapeUnicode&lt;&#39;_&gt;">â“˜</a></h4></section></summary><div class="docblock"><p>Returns an iterator that escapes each char in <code>self</code> with <a href="https://doc.rust-lang.org/nightly/std/primitive.char.html#method.escape_unicode" title="method char::escape_unicode"><code>char::escape_unicode</code></a>.</p>
<h5 id="examples-59"><a class="doc-anchor" href="#examples-59">Â§</a>Examples</h5>
<p>As an iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for </span>c <span class="kw">in </span><span class="string">"â¤\n!"</span>.escape_unicode() {
    <span class="macro">print!</span>(<span class="string">"{c}"</span>);
}
<span class="macro">println!</span>();</code></pre></div>
<p>Using <code>println!</code> directly:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"{}"</span>, <span class="string">"â¤\n!"</span>.escape_unicode());</code></pre></div>
<p>Both are equivalent to:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">println!</span>(<span class="string">"\\u{{2764}}\\u{{a}}\\u{{21}}"</span>);</code></pre></div>
<p>Using <code>to_string</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"â¤\n!"</span>.escape_unicode().to_string(), <span class="string">"\\u{2764}\\u{a}\\u{21}"</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.substr_range" class="method"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3064">Source</a><h4 class="code-header">pub fn <a href="#method.substr_range" class="fn">substr_range</a>(&amp;self, substr: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="../../../all/enum.Option.html" title="enum devela::all::Option">Option</a>&lt;<a class="struct" href="../../../all/struct.Range.html" title="struct devela::all::Range">Range</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;&gt; <a href="#" class="tooltip" data-notable-ty="Option&lt;Range&lt;usize&gt;&gt;">â“˜</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>substr_range</code>)</span></div></span></summary><div class="docblock"><p>Returns the range that a substring points to.</p>
<p>Returns <code>None</code> if <code>substr</code> does not point within <code>self</code>.</p>
<p>Unlike <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.find" title="method str::find"><code>str::find</code></a>, <strong>this does not search through the string</strong>.
Instead, it uses pointer arithmetic to find where in the string
<code>substr</code> is derived from.</p>
<p>This is useful for extending <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.split" title="method str::split"><code>str::split</code></a> and similar methods.</p>
<p>Note that this method may return false positives (typically either
<code>Some(0..0)</code> or <code>Some(self.len()..self.len())</code>) if <code>substr</code> is a
zero-length <code>str</code> that points at the beginning or end of another,
independent, <code>str</code>.</p>
<h5 id="examples-60"><a class="doc-anchor" href="#examples-60">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(substr_range)]

</span><span class="kw">let </span>data = <span class="string">"a, b, b, a"</span>;
<span class="kw">let </span><span class="kw-2">mut </span>iter = data.split(<span class="string">", "</span>).map(|s| data.substr_range(s).unwrap());

<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="number">0</span>..<span class="number">1</span>));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="number">3</span>..<span class="number">4</span>));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="number">6</span>..<span class="number">7</span>));
<span class="macro">assert_eq!</span>(iter.next(), <span class="prelude-val">Some</span>(<span class="number">9</span>..<span class="number">10</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.as_str" class="method"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/str/mod.rs.html#3075">Source</a><h4 class="code-header">pub fn <a href="#method.as_str" class="fn">as_str</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <a href="#" class="tooltip" data-notable-ty="&amp;str">â“˜</a></h4></section><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>str_as_str</code>)</span></div></span></summary><div class="docblock"><p>Returns the same string as a string slice <code>&amp;str</code>.</p>
<p>This method is redundant when used directly on <code>&amp;str</code>, but
it helps dereferencing other string-like types to string slices,
for example references to <code>Box&lt;str&gt;</code> or <code>Arc&lt;str&gt;</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.replace" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#268">Source</a></span><h4 class="code-header">pub fn <a href="#method.replace" class="fn">replace</a>&lt;P&gt;(&amp;self, from: P, to: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="struct" href="../../../all/struct.String.html" title="struct devela::all::String">String</a> <a href="#" class="tooltip" data-notable-ty="String">â“˜</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Replaces all matches of a pattern with another string.</p>
<p><code>replace</code> creates a new <a href="../../../all/struct.String.html" title="struct devela::all::String"><code>String</code></a>, and copies the data from this string slice into it.
While doing so, it attempts to find matches of a pattern. If it finds any, it
replaces them with the replacement string slice.</p>
<h5 id="examples-61"><a class="doc-anchor" href="#examples-61">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"this is old"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"this is new"</span>, s.replace(<span class="string">"old"</span>, <span class="string">"new"</span>));
<span class="macro">assert_eq!</span>(<span class="string">"than an old"</span>, s.replace(<span class="string">"is"</span>, <span class="string">"an"</span>));</code></pre></div>
<p>When the pattern doesnâ€™t match, it returns this string slice as <a href="../../../all/struct.String.html" title="struct devela::all::String"><code>String</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"this is old"</span>;
<span class="macro">assert_eq!</span>(s, s.replace(<span class="string">"cookie monster"</span>, <span class="string">"little lamb"</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.replacen" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#323">Source</a></span><h4 class="code-header">pub fn <a href="#method.replacen" class="fn">replacen</a>&lt;P&gt;(&amp;self, pat: P, to: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>, count: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../../../all/struct.String.html" title="struct devela::all::String">String</a> <a href="#" class="tooltip" data-notable-ty="String">â“˜</a><div class="where">where
    P: <a class="trait" href="../../../_core/str/pattern/trait.Pattern.html" title="trait devela::_core::str::pattern::Pattern">Pattern</a>,</div></h4></section></summary><div class="docblock"><p>Replaces first N matches of a pattern with another string.</p>
<p><code>replacen</code> creates a new <a href="../../../all/struct.String.html" title="struct devela::all::String"><code>String</code></a>, and copies the data from this string slice into it.
While doing so, it attempts to find matches of a pattern. If it finds any, it
replaces them with the replacement string slice at most <code>count</code> times.</p>
<h5 id="examples-62"><a class="doc-anchor" href="#examples-62">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"foo foo 123 foo"</span>;
<span class="macro">assert_eq!</span>(<span class="string">"new new 123 foo"</span>, s.replacen(<span class="string">"foo"</span>, <span class="string">"new"</span>, <span class="number">2</span>));
<span class="macro">assert_eq!</span>(<span class="string">"faa fao 123 foo"</span>, s.replacen(<span class="string">'o'</span>, <span class="string">"a"</span>, <span class="number">3</span>));
<span class="macro">assert_eq!</span>(<span class="string">"foo foo new23 foo"</span>, s.replacen(char::is_numeric, <span class="string">"new"</span>, <span class="number">1</span>));</code></pre></div>
<p>When the pattern doesnâ€™t match, it returns this string slice as <a href="../../../all/struct.String.html" title="struct devela::all::String"><code>String</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"this is old"</span>;
<span class="macro">assert_eq!</span>(s, s.replacen(<span class="string">"cookie monster"</span>, <span class="string">"little lamb"</span>, <span class="number">10</span>));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_lowercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#380">Source</a></span><h4 class="code-header">pub fn <a href="#method.to_lowercase" class="fn">to_lowercase</a>(&amp;self) -&gt; <a class="struct" href="../../../all/struct.String.html" title="struct devela::all::String">String</a> <a href="#" class="tooltip" data-notable-ty="String">â“˜</a></h4></section></summary><div class="docblock"><p>Returns the lowercase equivalent of this string slice, as a new <a href="../../../all/struct.String.html" title="struct devela::all::String"><code>String</code></a>.</p>
<p>â€˜Lowercaseâ€™ is defined according to the terms of the Unicode Derived Core Property
<code>Lowercase</code>.</p>
<p>Since some characters can expand into multiple characters when changing
the case, this function returns a <a href="../../../all/struct.String.html" title="struct devela::all::String"><code>String</code></a> instead of modifying the
parameter in-place.</p>
<h5 id="examples-63"><a class="doc-anchor" href="#examples-63">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"HELLO"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"hello"</span>, s.to_lowercase());</code></pre></div>
<p>A tricky example, with sigma:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>sigma = <span class="string">"Î£"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"Ïƒ"</span>, sigma.to_lowercase());

<span class="comment">// but at the end of a word, it's Ï‚, not Ïƒ:
</span><span class="kw">let </span>odysseus = <span class="string">"á½ˆÎ”Î¥Î£Î£Î•ÎÎ£"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"á½€Î´Ï…ÏƒÏƒÎµÏÏ‚"</span>, odysseus.to_lowercase());</code></pre></div>
<p>Languages without case are not changed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>new_year = <span class="string">"å†œå†æ–°å¹´"</span>;

<span class="macro">assert_eq!</span>(new_year, new_year.to_lowercase());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_uppercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.2.0">1.2.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#467">Source</a></span><h4 class="code-header">pub fn <a href="#method.to_uppercase" class="fn">to_uppercase</a>(&amp;self) -&gt; <a class="struct" href="../../../all/struct.String.html" title="struct devela::all::String">String</a> <a href="#" class="tooltip" data-notable-ty="String">â“˜</a></h4></section></summary><div class="docblock"><p>Returns the uppercase equivalent of this string slice, as a new <a href="../../../all/struct.String.html" title="struct devela::all::String"><code>String</code></a>.</p>
<p>â€˜Uppercaseâ€™ is defined according to the terms of the Unicode Derived Core Property
<code>Uppercase</code>.</p>
<p>Since some characters can expand into multiple characters when changing
the case, this function returns a <a href="../../../all/struct.String.html" title="struct devela::all::String"><code>String</code></a> instead of modifying the
parameter in-place.</p>
<h5 id="examples-64"><a class="doc-anchor" href="#examples-64">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"hello"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"HELLO"</span>, s.to_uppercase());</code></pre></div>
<p>Scripts without case are not changed:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>new_year = <span class="string">"å†œå†æ–°å¹´"</span>;

<span class="macro">assert_eq!</span>(new_year, new_year.to_uppercase());</code></pre></div>
<p>One character can become multiple:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"tschÃ¼ÃŸ"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"TSCHÃœSS"</span>, s.to_uppercase());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.repeat" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.16.0">1.16.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#531">Source</a></span><h4 class="code-header">pub fn <a href="#method.repeat" class="fn">repeat</a>(&amp;self, n: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../../../all/struct.String.html" title="struct devela::all::String">String</a> <a href="#" class="tooltip" data-notable-ty="String">â“˜</a></h4></section></summary><div class="docblock"><p>Creates a new <a href="../../../all/struct.String.html" title="struct devela::all::String"><code>String</code></a> by repeating a string <code>n</code> times.</p>
<h5 id="panics-1"><a class="doc-anchor" href="#panics-1">Â§</a>Panics</h5>
<p>This function will panic if the capacity would overflow.</p>
<h5 id="examples-65"><a class="doc-anchor" href="#examples-65">Â§</a>Examples</h5>
<p>Basic usage:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="macro">assert_eq!</span>(<span class="string">"abc"</span>.repeat(<span class="number">4</span>), String::from(<span class="string">"abcabcabcabc"</span>));</code></pre></div>
<p>A panic upon overflow:</p>

<div class="example-wrap should_panic"><a href="#" class="tooltip" title="This example panics">â“˜</a><pre class="rust rust-example-rendered"><code><span class="comment">// this will panic at runtime
</span><span class="kw">let </span>huge = <span class="string">"0123456789abcdef"</span>.repeat(usize::MAX);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_ascii_uppercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#561">Source</a></span><h4 class="code-header">pub fn <a href="#method.to_ascii_uppercase" class="fn">to_ascii_uppercase</a>(&amp;self) -&gt; <a class="struct" href="../../../all/struct.String.html" title="struct devela::all::String">String</a> <a href="#" class="tooltip" data-notable-ty="String">â“˜</a></h4></section></summary><div class="docblock"><p>Returns a copy of this string where each character is mapped to its
ASCII upper case equivalent.</p>
<p>ASCII letters â€˜aâ€™ to â€˜zâ€™ are mapped to â€˜Aâ€™ to â€˜Zâ€™,
but non-ASCII letters are unchanged.</p>
<p>To uppercase the value in-place, use <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.make_ascii_uppercase" title="method str::make_ascii_uppercase"><code>make_ascii_uppercase</code></a>.</p>
<p>To uppercase ASCII characters in addition to non-ASCII characters, use
<a href="#method.to_uppercase"><code>to_uppercase</code></a>.</p>
<h5 id="examples-66"><a class="doc-anchor" href="#examples-66">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"GrÃ¼ÃŸe, JÃ¼rgen â¤"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"GRÃ¼ÃŸE, JÃ¼RGEN â¤"</span>, s.to_ascii_uppercase());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_ascii_lowercase" class="method"><span class="rightside"><span class="since" title="Stable since Rust version 1.23.0">1.23.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/alloc/str.rs.html#593">Source</a></span><h4 class="code-header">pub fn <a href="#method.to_ascii_lowercase" class="fn">to_ascii_lowercase</a>(&amp;self) -&gt; <a class="struct" href="../../../all/struct.String.html" title="struct devela::all::String">String</a> <a href="#" class="tooltip" data-notable-ty="String">â“˜</a></h4></section></summary><div class="docblock"><p>Returns a copy of this string where each character is mapped to its
ASCII lower case equivalent.</p>
<p>ASCII letters â€˜Aâ€™ to â€˜Zâ€™ are mapped to â€˜aâ€™ to â€˜zâ€™,
but non-ASCII letters are unchanged.</p>
<p>To lowercase the value in-place, use <a href="https://doc.rust-lang.org/nightly/std/primitive.str.html#method.make_ascii_lowercase" title="method str::make_ascii_lowercase"><code>make_ascii_lowercase</code></a>.</p>
<p>To lowercase ASCII characters in addition to non-ASCII characters, use
<a href="#method.to_lowercase"><code>to_lowercase</code></a>.</p>
<h5 id="examples-67"><a class="doc-anchor" href="#examples-67">Â§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>s = <span class="string">"GrÃ¼ÃŸe, JÃ¼rgen â¤"</span>;

<span class="macro">assert_eq!</span>(<span class="string">"grÃ¼ÃŸe, jÃ¼rgen â¤"</span>, s.to_ascii_lowercase());</code></pre></div>
</div></details></div></details><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">Â§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-AsRef%3C%5Bu8%5D%3E-for-PyBackedStr" class="impl"><a href="#impl-AsRef%3C%5Bu8%5D%3E-for-PyBackedStr" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="../../../code/trait.AsRef.html" title="trait devela::code::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt; for <a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_ref-1" class="method trait-impl"><a href="#method.as_ref-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../code/trait.AsRef.html#tymethod.as_ref" class="fn">as_ref</a>(&amp;self) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">â“˜</a></h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AsRef%3Cstr%3E-for-PyBackedStr" class="impl"><a href="#impl-AsRef%3Cstr%3E-for-PyBackedStr" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="../../../code/trait.AsRef.html" title="trait devela::code::AsRef">AsRef</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt; for <a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.as_ref" class="method trait-impl"><a href="#method.as_ref" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../code/trait.AsRef.html#tymethod.as_ref" class="fn">as_ref</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <a href="#" class="tooltip" data-notable-ty="&amp;str">â“˜</a></h4></section></summary><div class='docblock'>Converts this type into a shared reference of the (usually inferred) input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-PyBackedStr" class="impl"><a href="#impl-Debug-for-PyBackedStr" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.Debug.html" title="trait devela::all::Debug">Debug</a> for <a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a href="#method.fmt" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../../../all/struct.Formatter.html" title="struct devela::all::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="../../../all/struct.FmtError.html" title="struct devela::all::FmtError">Error</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;(), Error&gt;">â“˜</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="../../../all/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Deref-for-PyBackedStr" class="impl"><a href="#impl-Deref-for-PyBackedStr" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.Deref.html" title="trait devela::all::Deref">Deref</a> for <a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Target" class="associatedtype trait-impl"><a href="#associatedtype.Target" class="anchor">Â§</a><h4 class="code-header">type <a href="../../../all/trait.Deref.html#associatedtype.Target" class="associatedtype">Target</a> = <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></h4></section></summary><div class='docblock'>The resulting type after dereferencing.</div></details><details class="toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl"><a href="#method.deref" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.Deref.html#tymethod.deref" class="fn">deref</a>(&amp;self) -&gt; &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <a href="#" class="tooltip" data-notable-ty="&amp;str">â“˜</a></h4></section></summary><div class='docblock'>Dereferences the value.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Display-for-PyBackedStr" class="impl"><a href="#impl-Display-for-PyBackedStr" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.Display.html" title="trait devela::all::Display">Display</a> for <a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl"><a href="#method.fmt-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.Display.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../../../all/struct.Formatter.html" title="struct devela::all::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="../../../all/struct.FmtError.html" title="struct devela::all::FmtError">Error</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;(), Error&gt;">â“˜</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="../../../all/trait.Display.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromPyObject%3C'_%3E-for-PyBackedStr" class="impl"><a href="#impl-FromPyObject%3C'_%3E-for-PyBackedStr" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="../trait.FromPyObject.html" title="trait devela::_dep::pyo3::FromPyObject">FromPyObject</a>&lt;'_&gt; for <a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.extract_bound" class="method trait-impl"><a href="#method.extract_bound" class="anchor">Â§</a><h4 class="code-header">fn <a href="../trait.FromPyObject.html#tymethod.extract_bound" class="fn">extract_bound</a>(obj: &amp;<a class="struct" href="../struct.Bound.html" title="struct devela::_dep::pyo3::Bound">Bound</a>&lt;'_, <a class="struct" href="../struct.PyAny.html" title="struct devela::_dep::pyo3::PyAny">PyAny</a>&gt;) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;<a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a>, <a class="struct" href="../struct.PyErr.html" title="struct devela::_dep::pyo3::PyErr">PyErr</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;PyBackedStr, PyErr&gt;">â“˜</a></h4></section></summary><div class='docblock'>Extracts <code>Self</code> from the bound smart pointer <code>obj</code>. <a href="../trait.FromPyObject.html#tymethod.extract_bound">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Hash-for-PyBackedStr" class="impl"><a href="#impl-Hash-for-PyBackedStr" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.Hash.html" title="trait devela::all::Hash">Hash</a> for <a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl"><a href="#method.hash" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.Hash.html#tymethod.hash" class="fn">hash</a>&lt;H&gt;(&amp;self, state: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut H</a>)<div class="where">where
    H: <a class="trait" href="../../../all/trait.Hasher.html" title="trait devela::all::Hasher">Hasher</a>,</div></h4></section></summary><div class='docblock'>Feeds this value into the given <a href="../../../all/trait.Hasher.html" title="trait devela::all::Hasher"><code>Hasher</code></a>. <a href="../../../all/trait.Hash.html#tymethod.hash">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.hash_slice" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/hash/mod.rs.html#235-237">Source</a></span><a href="#method.hash_slice" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.Hash.html#method.hash_slice" class="fn">hash_slice</a>&lt;H&gt;(data: &amp;[Self], state: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut H</a>)<div class="where">where
    H: <a class="trait" href="../../../all/trait.Hasher.html" title="trait devela::all::Hasher">Hasher</a>,
    Self: <a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Feeds a slice of this type into the given <a href="../../../all/trait.Hasher.html" title="trait devela::all::Hasher"><code>Hasher</code></a>. <a href="../../../all/trait.Hash.html#method.hash_slice">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-IntoPyObject%3C'py%3E-for-%26PyBackedStr" class="impl"><a href="#impl-IntoPyObject%3C'py%3E-for-%26PyBackedStr" class="anchor">Â§</a><h3 class="code-header">impl&lt;'py&gt; <a class="trait" href="../trait.IntoPyObject.html" title="trait devela::_dep::pyo3::IntoPyObject">IntoPyObject</a>&lt;'py&gt; for &amp;<a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Target-2" class="associatedtype trait-impl"><a href="#associatedtype.Target-2" class="anchor">Â§</a><h4 class="code-header">type <a href="../trait.IntoPyObject.html#associatedtype.Target" class="associatedtype">Target</a> = <a class="struct" href="../struct.PyAny.html" title="struct devela::_dep::pyo3::PyAny">PyAny</a></h4></section></summary><div class='docblock'>The Python output type</div></details><details class="toggle" open><summary><section id="associatedtype.Output-1" class="associatedtype trait-impl"><a href="#associatedtype.Output-1" class="anchor">Â§</a><h4 class="code-header">type <a href="../trait.IntoPyObject.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="../struct.Bound.html" title="struct devela::_dep::pyo3::Bound">Bound</a>&lt;'py, &lt;&amp;<a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a> as <a class="trait" href="../trait.IntoPyObject.html" title="trait devela::_dep::pyo3::IntoPyObject">IntoPyObject</a>&lt;'py&gt;&gt;::<a class="associatedtype" href="../trait.IntoPyObject.html#associatedtype.Target" title="type devela::_dep::pyo3::IntoPyObject::Target">Target</a>&gt;</h4></section></summary><div class='docblock'>The smart pointer type to use. <a href="../trait.IntoPyObject.html#associatedtype.Output">Read more</a></div></details><details class="toggle" open><summary><section id="associatedtype.Error-2" class="associatedtype trait-impl"><a href="#associatedtype.Error-2" class="anchor">Â§</a><h4 class="code-header">type <a href="../trait.IntoPyObject.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="../../../code/enum.Infallible.html" title="enum devela::code::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.into_pyobject-1" class="method trait-impl"><a href="#method.into_pyobject-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="../trait.IntoPyObject.html#tymethod.into_pyobject" class="fn">into_pyobject</a>(
    self,
    py: <a class="struct" href="../struct.Python.html" title="struct devela::_dep::pyo3::Python">Python</a>&lt;'py&gt;,
) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;&lt;&amp;<a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a> as <a class="trait" href="../trait.IntoPyObject.html" title="trait devela::_dep::pyo3::IntoPyObject">IntoPyObject</a>&lt;'py&gt;&gt;::<a class="associatedtype" href="../trait.IntoPyObject.html#associatedtype.Output" title="type devela::_dep::pyo3::IntoPyObject::Output">Output</a>, &lt;&amp;<a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a> as <a class="trait" href="../trait.IntoPyObject.html" title="trait devela::_dep::pyo3::IntoPyObject">IntoPyObject</a>&lt;'py&gt;&gt;::<a class="associatedtype" href="../trait.IntoPyObject.html#associatedtype.Error" title="type devela::_dep::pyo3::IntoPyObject::Error">Error</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;&lt;&amp;PyBackedStr as IntoPyObject&lt;&#39;py&gt;&gt;::Output, &lt;&amp;PyBackedStr as IntoPyObject&lt;&#39;py&gt;&gt;::Error&gt;">â“˜</a></h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-IntoPyObject%3C'py%3E-for-PyBackedStr" class="impl"><a href="#impl-IntoPyObject%3C'py%3E-for-PyBackedStr" class="anchor">Â§</a><h3 class="code-header">impl&lt;'py&gt; <a class="trait" href="../trait.IntoPyObject.html" title="trait devela::_dep::pyo3::IntoPyObject">IntoPyObject</a>&lt;'py&gt; for <a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Target-1" class="associatedtype trait-impl"><a href="#associatedtype.Target-1" class="anchor">Â§</a><h4 class="code-header">type <a href="../trait.IntoPyObject.html#associatedtype.Target" class="associatedtype">Target</a> = <a class="struct" href="../struct.PyAny.html" title="struct devela::_dep::pyo3::PyAny">PyAny</a></h4></section></summary><div class='docblock'>The Python output type</div></details><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a href="#associatedtype.Output" class="anchor">Â§</a><h4 class="code-header">type <a href="../trait.IntoPyObject.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="../struct.Bound.html" title="struct devela::_dep::pyo3::Bound">Bound</a>&lt;'py, &lt;<a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a> as <a class="trait" href="../trait.IntoPyObject.html" title="trait devela::_dep::pyo3::IntoPyObject">IntoPyObject</a>&lt;'py&gt;&gt;::<a class="associatedtype" href="../trait.IntoPyObject.html#associatedtype.Target" title="type devela::_dep::pyo3::IntoPyObject::Target">Target</a>&gt;</h4></section></summary><div class='docblock'>The smart pointer type to use. <a href="../trait.IntoPyObject.html#associatedtype.Output">Read more</a></div></details><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">Â§</a><h4 class="code-header">type <a href="../trait.IntoPyObject.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="../../../code/enum.Infallible.html" title="enum devela::code::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.into_pyobject" class="method trait-impl"><a href="#method.into_pyobject" class="anchor">Â§</a><h4 class="code-header">fn <a href="../trait.IntoPyObject.html#tymethod.into_pyobject" class="fn">into_pyobject</a>(
    self,
    py: <a class="struct" href="../struct.Python.html" title="struct devela::_dep::pyo3::Python">Python</a>&lt;'py&gt;,
) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;&lt;<a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a> as <a class="trait" href="../trait.IntoPyObject.html" title="trait devela::_dep::pyo3::IntoPyObject">IntoPyObject</a>&lt;'py&gt;&gt;::<a class="associatedtype" href="../trait.IntoPyObject.html#associatedtype.Output" title="type devela::_dep::pyo3::IntoPyObject::Output">Output</a>, &lt;<a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a> as <a class="trait" href="../trait.IntoPyObject.html" title="trait devela::_dep::pyo3::IntoPyObject">IntoPyObject</a>&lt;'py&gt;&gt;::<a class="associatedtype" href="../trait.IntoPyObject.html#associatedtype.Error" title="type devela::_dep::pyo3::IntoPyObject::Error">Error</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;&lt;PyBackedStr as IntoPyObject&lt;&#39;py&gt;&gt;::Output, &lt;PyBackedStr as IntoPyObject&lt;&#39;py&gt;&gt;::Error&gt;">â“˜</a></h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Ord-for-PyBackedStr" class="impl"><a href="#impl-Ord-for-PyBackedStr" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.Ord.html" title="trait devela::all::Ord">Ord</a> for <a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cmp" class="method trait-impl"><a href="#method.cmp" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.Ord.html#tymethod.cmp" class="fn">cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a>) -&gt; <a class="enum" href="../../../all/enum.Ordering.html" title="enum devela::all::Ordering">Ordering</a></h4></section></summary><div class='docblock'>This method returns an <a href="../../../all/enum.Ordering.html" title="enum devela::all::Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="../../../all/trait.Ord.html#tymethod.cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.max" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1013-1015">Source</a></span><a href="#method.max" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.Ord.html#method.max" class="fn">max</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the maximum of two values. <a href="../../../all/trait.Ord.html#method.max">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.min" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1052-1054">Source</a></span><a href="#method.min" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.Ord.html#method.min" class="fn">min</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the minimum of two values. <a href="../../../all/trait.Ord.html#method.min">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clamp" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1078-1080">Source</a></span><a href="#method.clamp" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.Ord.html#method.clamp" class="fn">clamp</a>(self, min: Self, max: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Restrict a value to a certain interval. <a href="../../../all/trait.Ord.html#method.clamp">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3C%26str%3E-for-PyBackedStr" class="impl"><a href="#impl-PartialEq%3C%26str%3E-for-PyBackedStr" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.PartialEq.html" title="trait devela::all::PartialEq">PartialEq</a>&lt;&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt; for <a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-2" class="method trait-impl"><a href="#method.eq-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;&amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#265">Source</a></span><a href="#method.ne-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CPyBackedStr%3E-for-%26str" class="impl"><a href="#impl-PartialEq%3CPyBackedStr%3E-for-%26str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.PartialEq.html" title="trait devela::all::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a>&gt; for &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-4" class="method trait-impl"><a href="#method.eq-4" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-4" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#265">Source</a></span><a href="#method.ne-4" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3CPyBackedStr%3E-for-str" class="impl"><a href="#impl-PartialEq%3CPyBackedStr%3E-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.PartialEq.html" title="trait devela::all::PartialEq">PartialEq</a>&lt;<a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a>&gt; for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-3" class="method trait-impl"><a href="#method.eq-3" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-3" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#265">Source</a></span><a href="#method.ne-3" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq%3Cstr%3E-for-PyBackedStr" class="impl"><a href="#impl-PartialEq%3Cstr%3E-for-PyBackedStr" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.PartialEq.html" title="trait devela::all::PartialEq">PartialEq</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt; for <a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq-1" class="method trait-impl"><a href="#method.eq-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#265">Source</a></span><a href="#method.ne-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-PyBackedStr" class="impl"><a href="#impl-PartialEq-for-PyBackedStr" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.PartialEq.html" title="trait devela::all::PartialEq">PartialEq</a> for <a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a href="#method.eq" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#265">Source</a></span><a href="#method.ne" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3CPyBackedStr%3E-for-str" class="impl"><a href="#impl-PartialOrd%3CPyBackedStr%3E-for-str" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.PartialOrd.html" title="trait devela::all::PartialOrd">PartialOrd</a>&lt;<a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a>&gt; for <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp-2" class="method trait-impl"><a href="#method.partial_cmp-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a>) -&gt; <a class="enum" href="../../../all/enum.Option.html" title="enum devela::all::Option">Option</a>&lt;<a class="enum" href="../../../all/enum.Ordering.html" title="enum devela::all::Ordering">Ordering</a>&gt; <a href="#" class="tooltip" data-notable-ty="Option&lt;Ordering&gt;">â“˜</a></h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../../../all/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1387">Source</a></span><a href="#method.lt-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../../../all/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1405">Source</a></span><a href="#method.le-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the
<code>&lt;=</code> operator. <a href="../../../all/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1423">Source</a></span><a href="#method.gt-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>
operator. <a href="../../../all/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge-2" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1441">Source</a></span><a href="#method.ge-2" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by
the <code>&gt;=</code> operator. <a href="../../../all/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd%3Cstr%3E-for-PyBackedStr" class="impl"><a href="#impl-PartialOrd%3Cstr%3E-for-PyBackedStr" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.PartialOrd.html" title="trait devela::all::PartialOrd">PartialOrd</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>&gt; for <a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp-1" class="method trait-impl"><a href="#method.partial_cmp-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="../../../all/enum.Option.html" title="enum devela::all::Option">Option</a>&lt;<a class="enum" href="../../../all/enum.Ordering.html" title="enum devela::all::Ordering">Ordering</a>&gt; <a href="#" class="tooltip" data-notable-ty="Option&lt;Ordering&gt;">â“˜</a></h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../../../all/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1387">Source</a></span><a href="#method.lt-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../../../all/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1405">Source</a></span><a href="#method.le-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the
<code>&lt;=</code> operator. <a href="../../../all/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1423">Source</a></span><a href="#method.gt-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>
operator. <a href="../../../all/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge-1" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1441">Source</a></span><a href="#method.ge-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by
the <code>&gt;=</code> operator. <a href="../../../all/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd-for-PyBackedStr" class="impl"><a href="#impl-PartialOrd-for-PyBackedStr" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.PartialOrd.html" title="trait devela::all::PartialOrd">PartialOrd</a> for <a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl"><a href="#method.partial_cmp" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a>) -&gt; <a class="enum" href="../../../all/enum.Option.html" title="enum devela::all::Option">Option</a>&lt;<a class="enum" href="../../../all/enum.Ordering.html" title="enum devela::all::Ordering">Ordering</a>&gt; <a href="#" class="tooltip" data-notable-ty="Option&lt;Ordering&gt;">â“˜</a></h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../../../all/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1387">Source</a></span><a href="#method.lt" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../../../all/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1405">Source</a></span><a href="#method.le" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the
<code>&lt;=</code> operator. <a href="../../../all/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1423">Source</a></span><a href="#method.gt" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>
operator. <a href="../../../all/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> Â· <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1441">Source</a></span><a href="#method.ge" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by
the <code>&gt;=</code> operator. <a href="../../../all/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-TryFrom%3CBound%3C'_,+PyString%3E%3E-for-PyBackedStr" class="impl"><a href="#impl-TryFrom%3CBound%3C'_,+PyString%3E%3E-for-PyBackedStr" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="../../../code/trait.TryFrom.html" title="trait devela::code::TryFrom">TryFrom</a>&lt;<a class="struct" href="../struct.Bound.html" title="struct devela::_dep::pyo3::Bound">Bound</a>&lt;'_, <a class="struct" href="../types/struct.PyString.html" title="struct devela::_dep::pyo3::types::PyString">PyString</a>&gt;&gt; for <a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">Â§</a><h4 class="code-header">type <a href="../../../code/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="struct" href="../struct.PyErr.html" title="struct devela::_dep::pyo3::PyErr">PyErr</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a href="#method.try_from" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../code/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(
    py_string: <a class="struct" href="../struct.Bound.html" title="struct devela::_dep::pyo3::Bound">Bound</a>&lt;'_, <a class="struct" href="../types/struct.PyString.html" title="struct devela::_dep::pyo3::types::PyString">PyString</a>&gt;,
) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;<a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a>, &lt;<a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a> as <a class="trait" href="../../../code/trait.TryFrom.html" title="trait devela::code::TryFrom">TryFrom</a>&lt;<a class="struct" href="../struct.Bound.html" title="struct devela::_dep::pyo3::Bound">Bound</a>&lt;'_, <a class="struct" href="../types/struct.PyString.html" title="struct devela::_dep::pyo3::types::PyString">PyString</a>&gt;&gt;&gt;::<a class="associatedtype" href="../../../code/trait.TryFrom.html#associatedtype.Error" title="type devela::code::TryFrom::Error">Error</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;PyBackedStr, &lt;PyBackedStr as TryFrom&lt;Bound&lt;&#39;_, PyString&gt;&gt;&gt;::Error&gt;">â“˜</a></h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><section id="impl-Eq-for-PyBackedStr" class="impl"><a href="#impl-Eq-for-PyBackedStr" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.Eq.html" title="trait devela::all::Eq">Eq</a> for <a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a></h3></section><section id="impl-Send-for-PyBackedStr" class="impl"><a href="#impl-Send-for-PyBackedStr" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.Send.html" title="trait devela::all::Send">Send</a> for <a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a></h3></section><section id="impl-Sync-for-PyBackedStr" class="impl"><a href="#impl-Sync-for-PyBackedStr" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.Sync.html" title="trait devela::all::Sync">Sync</a> for <a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">Â§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-PyBackedStr" class="impl"><a href="#impl-Freeze-for-PyBackedStr" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="../../../_core/marker/trait.Freeze.html" title="trait devela::_core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a></h3></section><section id="impl-RefUnwindSafe-for-PyBackedStr" class="impl"><a href="#impl-RefUnwindSafe-for-PyBackedStr" class="anchor">Â§</a><h3 class="code-header">impl !<a class="trait" href="../../../all/trait.PanicRefUnwindSafe.html" title="trait devela::all::PanicRefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a></h3></section><section id="impl-Unpin-for-PyBackedStr" class="impl"><a href="#impl-Unpin-for-PyBackedStr" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.Unpin.html" title="trait devela::all::Unpin">Unpin</a> for <a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a></h3></section><section id="impl-UnwindSafe-for-PyBackedStr" class="impl"><a href="#impl-UnwindSafe-for-PyBackedStr" class="anchor">Â§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.PanicUnwindSafe.html" title="trait devela::all::PanicUnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.PyBackedStr.html" title="struct devela::_dep::pyo3::pybacked::PyBackedStr">PyBackedStr</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">Â§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../code/trait.Any.html" title="trait devela::code::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#139">Source</a><a href="#method.type_id-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../code/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="../../../code/struct.TypeId.html" title="struct devela::code::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="../../../code/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../all/trait.Borrow.html" title="trait devela::all::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="../../../all/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../all/trait.BorrowMut.html" title="trait devela::all::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="../../../all/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ByteSized-for-T" class="impl"><a class="src rightside" href="../../../../src/devela/sys/mem/size/byte.rs.html#8">Source</a><a href="#impl-ByteSized-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../all/trait.ByteSized.html" title="trait devela::all::ByteSized">ByteSized</a> for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.BYTE_ALIGN" class="associatedconstant trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/size/byte.rs.html#16">Source</a><a href="#associatedconstant.BYTE_ALIGN" class="anchor">Â§</a><h4 class="code-header">const <a href="../../../all/trait.ByteSized.html#associatedconstant.BYTE_ALIGN" class="constant">BYTE_ALIGN</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a> = _</h4></section></summary><div class='docblock'>The alignment of this type in bytes.</div></details><details class="toggle" open><summary><section id="associatedconstant.BYTE_SIZE" class="associatedconstant trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/size/byte.rs.html#18">Source</a><a href="#associatedconstant.BYTE_SIZE" class="anchor">Â§</a><h4 class="code-header">const <a href="../../../all/trait.ByteSized.html#associatedconstant.BYTE_SIZE" class="constant">BYTE_SIZE</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a> = _</h4></section></summary><div class='docblock'>The size of this type in bytes.</div></details><details class="toggle method-toggle" open><summary><section id="method.byte_align" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/size/byte.rs.html#21-23">Source</a><a href="#method.byte_align" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.ByteSized.html#method.byte_align" class="fn">byte_align</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the alignment of this type in bytes.</div></details><details class="toggle method-toggle" open><summary><section id="method.byte_size" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/size/byte.rs.html#28-30">Source</a><a href="#method.byte_size" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.ByteSized.html#method.byte_size" class="fn">byte_size</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the size of this type in bytes. <a href="../../../all/trait.ByteSized.html#method.byte_size">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ptr_size_ratio" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/size/byte.rs.html#61-63">Source</a><a href="#method.ptr_size_ratio" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.ByteSized.html#method.ptr_size_ratio" class="fn">ptr_size_ratio</a>(&amp;self) -&gt; [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.array.html">2</a>]</h4></section></summary><div class='docblock'>Returns the size ratio between <a href="../../../all/struct.Ptr.html#associatedconstant.BYTES" title="associated constant devela::all::Ptr::BYTES"><code>Ptr::BYTES</code></a>
and <a href="../../../all/trait.ByteSized.html#associatedconstant.BYTE_SIZE" title="trait devela::all::ByteSized"><code>BYTE_SIZE</code></a>. <a href="../../../all/trait.ByteSized.html#method.ptr_size_ratio">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Chain%3CR%3E-for-T" class="impl"><a class="src rightside" href="../../../../src/devela/code/result/chain_hook.rs.html#62">Source</a><a href="#impl-Chain%3CR%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, R&gt; <a class="trait" href="../../../all/trait.Chain.html" title="trait devela::all::Chain">Chain</a>&lt;R&gt; for T<div class="where">where
    T: ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.chain" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/result/chain_hook.rs.html#36-42">Source</a><a href="#method.chain" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.Chain.html#method.chain" class="fn">chain</a>&lt;F&gt;(self, f: F) -&gt; R<div class="where">where
    F: <a class="trait" href="../../../all/trait.FnOnce.html" title="trait devela::all::FnOnce">FnOnce</a>(Self) -&gt; R,
    Self: <a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Chain a function which takes the parameter by value.</div></details><details class="toggle method-toggle" open><summary><section id="method.chain_ref" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/result/chain_hook.rs.html#46-51">Source</a><a href="#method.chain_ref" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.Chain.html#method.chain_ref" class="fn">chain_ref</a>&lt;F&gt;(&amp;self, f: F) -&gt; R<div class="where">where
    F: <a class="trait" href="../../../all/trait.FnOnce.html" title="trait devela::all::FnOnce">FnOnce</a>(&amp;Self) -&gt; R,</div></h4></section></summary><div class='docblock'>Chain a function which takes the parameter by shared reference.</div></details><details class="toggle method-toggle" open><summary><section id="method.chain_mut" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/result/chain_hook.rs.html#55-60">Source</a><a href="#method.chain_mut" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.Chain.html#method.chain_mut" class="fn">chain_mut</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; R<div class="where">where
    F: <a class="trait" href="../../../all/trait.FnOnce.html" title="trait devela::all::FnOnce">FnOnce</a>(&amp;mut Self) -&gt; R,</div></h4></section></summary><div class='docblock'>Chain a function which takes the parameter by exclusive reference.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Comparable%3CK%3E-for-Q" class="impl"><a href="#impl-Comparable%3CK%3E-for-Q" class="anchor">Â§</a><h3 class="code-header">impl&lt;Q, K&gt; Comparable&lt;K&gt; for Q<div class="where">where
    Q: <a class="trait" href="../../../all/trait.Ord.html" title="trait devela::all::Ord">Ord</a> + ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,
    K: <a class="trait" href="../../../all/trait.Borrow.html" title="trait devela::all::Borrow">Borrow</a>&lt;Q&gt; + ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.compare" class="method trait-impl"><a href="#method.compare" class="anchor">Â§</a><h4 class="code-header">fn <a class="fn">compare</a>(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;K</a>) -&gt; <a class="enum" href="../../../all/enum.Ordering.html" title="enum devela::all::Ordering">Ordering</a></h4></section></summary><div class='docblock'>Compare self to <code>key</code> and return their ordering.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Equivalent%3CK%3E-for-Q" class="impl"><a href="#impl-Equivalent%3CK%3E-for-Q" class="anchor">Â§</a><h3 class="code-header">impl&lt;Q, K&gt; Equivalent&lt;K&gt; for Q<div class="where">where
    Q: <a class="trait" href="../../../all/trait.Eq.html" title="trait devela::all::Eq">Eq</a> + ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,
    K: <a class="trait" href="../../../all/trait.Borrow.html" title="trait devela::all::Borrow">Borrow</a>&lt;Q&gt; + ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.equivalent" class="method trait-impl"><a href="#method.equivalent" class="anchor">Â§</a><h4 class="code-header">fn <a class="fn">equivalent</a>(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;K</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Compare self to <code>key</code> and return <code>true</code> if they are equal.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Equivalent%3CK%3E-for-Q-1" class="impl"><a href="#impl-Equivalent%3CK%3E-for-Q-1" class="anchor">Â§</a><h3 class="code-header">impl&lt;Q, K&gt; <a class="trait" href="../../hashbrown/trait.Equivalent.html" title="trait devela::_dep::hashbrown::Equivalent">Equivalent</a>&lt;K&gt; for Q<div class="where">where
    Q: <a class="trait" href="../../../all/trait.Eq.html" title="trait devela::all::Eq">Eq</a> + ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,
    K: <a class="trait" href="../../../all/trait.Borrow.html" title="trait devela::all::Borrow">Borrow</a>&lt;Q&gt; + ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.equivalent-1" class="method trait-impl"><a href="#method.equivalent-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../hashbrown/trait.Equivalent.html#tymethod.equivalent" class="fn">equivalent</a>(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;K</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Checks if this value is equivalent to the given key. <a href="../../hashbrown/trait.Equivalent.html#tymethod.equivalent">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ExtAny-for-T" class="impl"><a class="src rightside" href="../../../../src/devela/code/any/ext.rs.html#17">Source</a><a href="#impl-ExtAny-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../code/trait.ExtAny.html" title="trait devela::code::ExtAny">ExtAny</a> for T<div class="where">where
    T: <a class="trait" href="../../../code/trait.Any.html" title="trait devela::code::Any">Any</a> + ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/any/ext.rs.html#39">Source</a><a href="#method.type_id" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../code/trait.ExtAny.html#method.type_id" class="fn">type_id</a>() -&gt; <a class="struct" href="../../../code/struct.TypeId.html" title="struct devela::code::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Returns the <code>TypeId</code> of <code>Self</code>. <a href="../../../code/trait.ExtAny.html#method.type_id">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.type_of" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/any/ext.rs.html#51">Source</a><a href="#method.type_of" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../code/trait.ExtAny.html#method.type_of" class="fn">type_of</a>(&amp;self) -&gt; <a class="struct" href="../../../code/struct.TypeId.html" title="struct devela::code::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Returns the <code>TypeId</code> of <code>self</code>. <a href="../../../code/trait.ExtAny.html#method.type_of">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.type_name" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/any/ext.rs.html#65">Source</a><a href="#method.type_name" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../code/trait.ExtAny.html#method.type_name" class="fn">type_name</a>(&amp;self) -&gt; &amp;'static <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <a href="#" class="tooltip" data-notable-ty="&amp;&#39;static str">â“˜</a></h4></section></summary><div class='docblock'>Returns the type name of <code>self</code>. <a href="../../../code/trait.ExtAny.html#method.type_name">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.type_is" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/any/ext.rs.html#84">Source</a><a href="#method.type_is" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../code/trait.ExtAny.html#method.type_is" class="fn">type_is</a>&lt;T: 'static&gt;(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns <code>true</code> if <code>Self</code> is of type <code>T</code>. <a href="../../../code/trait.ExtAny.html#method.type_is">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.type_hash" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/any/ext.rs.html#87-90">Source</a><a href="#method.type_hash" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../code/trait.ExtAny.html#method.type_hash" class="fn">type_hash</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a></h4></section></summary><div class='docblock'>Returns a deterministic hash of the <code>TypeId</code> of <code>Self</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.type_hash_with" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/any/ext.rs.html#93-96">Source</a><a href="#method.type_hash_with" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../code/trait.ExtAny.html#method.type_hash_with" class="fn">type_hash_with</a>&lt;H: <a class="trait" href="../../../all/trait.Hasher.html" title="trait devela::all::Hasher">Hasher</a>&gt;(&amp;self, hasher: H) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a></h4></section></summary><div class='docblock'>Returns a deterministic hash of the <code>TypeId</code> of <code>Self</code> using a custom hasher.</div></details><details class="toggle method-toggle" open><summary><section id="method.as_any_ref" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/any/ext.rs.html#111">Source</a><a href="#method.as_any_ref" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../code/trait.ExtAny.html#method.as_any_ref" class="fn">as_any_ref</a>(&amp;self) -&gt; &amp;dyn <a class="trait" href="../../../code/trait.Any.html" title="trait devela::code::Any">Any</a><div class="where">where
    Self: <a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Upcasts <code>&amp;self</code> as <code>&amp;dyn Any</code>. <a href="../../../code/trait.ExtAny.html#method.as_any_ref">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.as_any_mut" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/any/ext.rs.html#124">Source</a><a href="#method.as_any_mut" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../code/trait.ExtAny.html#method.as_any_mut" class="fn">as_any_mut</a>(&amp;mut self) -&gt; &amp;mut dyn <a class="trait" href="../../../code/trait.Any.html" title="trait devela::code::Any">Any</a><div class="where">where
    Self: <a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Upcasts <code>&amp;mut self</code> as <code>&amp;mut dyn Any</code>. <a href="../../../code/trait.ExtAny.html#method.as_any_mut">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.as_any_box" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/any/ext.rs.html#138">Source</a><a href="#method.as_any_box" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../code/trait.ExtAny.html#method.as_any_box" class="fn">as_any_box</a>(self: <a class="struct" href="../../../all/struct.Box.html" title="struct devela::all::Box">Box</a>&lt;Self&gt;) -&gt; <a class="struct" href="../../../all/struct.Box.html" title="struct devela::all::Box">Box</a>&lt;dyn <a class="trait" href="../../../code/trait.Any.html" title="trait devela::code::Any">Any</a>&gt;<div class="where">where
    Self: <a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Upcasts <code>Box&lt;self&gt;</code> as <code>Box&lt;dyn Any&gt;</code>. <a href="../../../code/trait.ExtAny.html#method.as_any_box">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.downcast_ref" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/any/ext.rs.html#196-199">Source</a><a href="#method.downcast_ref" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../code/trait.ExtAny.html#method.downcast_ref" class="fn">downcast_ref</a>&lt;T: 'static&gt;(&amp;self) -&gt; <a class="enum" href="../../../all/enum.Option.html" title="enum devela::all::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a>&gt; <a href="#" class="tooltip" data-notable-ty="Option&lt;&amp;T&gt;">â“˜</a></h4></section></summary><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>unsafe_layout</code> and non-crate feature <code>safe_code</code></strong> only.</div></span><div class='docblock'>Returns some shared reference to the inner value if it is of type <code>T</code>. <a href="../../../code/trait.ExtAny.html#method.downcast_ref">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.downcast_mut" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/any/ext.rs.html#208-211">Source</a><a href="#method.downcast_mut" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../code/trait.ExtAny.html#method.downcast_mut" class="fn">downcast_mut</a>&lt;T: 'static&gt;(&amp;mut self) -&gt; <a class="enum" href="../../../all/enum.Option.html" title="enum devela::all::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>&gt; <a href="#" class="tooltip" data-notable-ty="Option&lt;&amp;mut T&gt;">â“˜</a></h4></section></summary><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>unsafe_layout</code> and non-crate feature <code>safe_code</code></strong> only.</div></span><div class='docblock'>Returns some exclusive reference to the inner value if it is of type <code>T</code>. <a href="../../../code/trait.ExtAny.html#method.downcast_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ExtMem-for-T" class="impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#8">Source</a><a href="#impl-ExtMem-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../all/trait.ExtMem.html" title="trait devela::all::ExtMem">ExtMem</a> for T<div class="where">where
    T: ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.NEEDS_DROP" class="associatedconstant trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#18">Source</a><a href="#associatedconstant.NEEDS_DROP" class="anchor">Â§</a><h4 class="code-header">const <a href="../../../all/trait.ExtMem.html#associatedconstant.NEEDS_DROP" class="constant">NEEDS_DROP</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> = _</h4></section></summary><div class='docblock'>Know whether dropping values of this type matters, in compile-time.</div></details><details class="toggle method-toggle" open><summary><section id="method.mem_align_of" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#24">Source</a><a href="#method.mem_align_of" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.ExtMem.html#method.mem_align_of" class="fn">mem_align_of</a>&lt;T&gt;() -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the minimum alignment of the type in bytes. <a href="../../../all/trait.ExtMem.html#method.mem_align_of">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_align_of_val" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#30">Source</a><a href="#method.mem_align_of_val" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.ExtMem.html#method.mem_align_of_val" class="fn">mem_align_of_val</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the alignment of the pointed-to value in bytes. <a href="../../../all/trait.ExtMem.html#method.mem_align_of_val">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_size_of" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#36">Source</a><a href="#method.mem_size_of" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.ExtMem.html#method.mem_size_of" class="fn">mem_size_of</a>&lt;T&gt;() -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the size of a type in bytes. <a href="../../../all/trait.ExtMem.html#method.mem_size_of">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_size_of_val" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#42">Source</a><a href="#method.mem_size_of_val" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.ExtMem.html#method.mem_size_of_val" class="fn">mem_size_of_val</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the size of the pointed-to value in bytes. <a href="../../../all/trait.ExtMem.html#method.mem_size_of_val">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_copy" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#51">Source</a><a href="#method.mem_copy" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.ExtMem.html#method.mem_copy" class="fn">mem_copy</a>(&amp;self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="../../../all/trait.Copy.html" title="trait devela::all::Copy">Copy</a>,</div></h4></section></summary><div class='docblock'>Bitwise-copies a value. <a href="../../../all/trait.ExtMem.html#method.mem_copy">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_needs_drop" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#57">Source</a><a href="#method.mem_needs_drop" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.ExtMem.html#method.mem_needs_drop" class="fn">mem_needs_drop</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns <code>true</code> if dropping values of this type matters. <a href="../../../all/trait.ExtMem.html#method.mem_needs_drop">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_drop" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#62">Source</a><a href="#method.mem_drop" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.ExtMem.html#method.mem_drop" class="fn">mem_drop</a>(self)<div class="where">where
    Self: <a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Drops <code>self</code> by running its destructor. <a href="../../../all/trait.ExtMem.html#method.mem_drop">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_forget" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#67">Source</a><a href="#method.mem_forget" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.ExtMem.html#method.mem_forget" class="fn">mem_forget</a>(self)<div class="where">where
    Self: <a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Forgets about <code>self</code> <em>without running its destructor</em>. <a href="../../../all/trait.ExtMem.html#method.mem_forget">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_replace" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#73">Source</a><a href="#method.mem_replace" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.ExtMem.html#method.mem_replace" class="fn">mem_replace</a>(&amp;mut self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Replaces <code>self</code> with other, returning the previous value of <code>self</code>. <a href="../../../all/trait.ExtMem.html#method.mem_replace">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_take" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#79">Source</a><a href="#method.mem_take" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.ExtMem.html#method.mem_take" class="fn">mem_take</a>(&amp;mut self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="../../../code/trait.Default.html" title="trait devela::code::Default">Default</a>,</div></h4></section></summary><div class='docblock'>Replaces <code>self</code> with its default value, returning the previous value of <code>self</code>. <a href="../../../all/trait.ExtMem.html#method.mem_take">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_swap" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#84">Source</a><a href="#method.mem_swap" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.ExtMem.html#method.mem_swap" class="fn">mem_swap</a>(&amp;mut self, other: &amp;mut Self)<div class="where">where
    Self: <a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Swaps the value of <code>self</code> and <code>other</code> without deinitializing either one. <a href="../../../all/trait.ExtMem.html#method.mem_swap">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_zeroed" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#93">Source</a><a href="#method.mem_zeroed" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="../../../all/trait.ExtMem.html#method.mem_zeroed" class="fn">mem_zeroed</a>&lt;T&gt;() -&gt; T</h4></section></summary><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>unsafe_layout</code></strong> only.</div></span><div class='docblock'>Returns the value of type <code>T</code> represented by the all-zero byte-pattern. <a href="../../../all/trait.ExtMem.html#method.mem_zeroed">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_transmute_copy" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#102-104">Source</a><a href="#method.mem_transmute_copy" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a href="../../../all/trait.ExtMem.html#method.mem_transmute_copy" class="fn">mem_transmute_copy</a>&lt;Src, Dst&gt;(src: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Src</a>) -&gt; Dst</h4></section></summary><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>unsafe_layout</code></strong> only.</div></span><div class='docblock'>Returns the value of type <code>T</code> represented by the all-zero byte-pattern. <a href="../../../all/trait.ExtMem.html#method.mem_transmute_copy">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_as_bytes" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#113">Source</a><a href="#method.mem_as_bytes" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.ExtMem.html#method.mem_as_bytes" class="fn">mem_as_bytes</a>(&amp;self) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">â“˜</a><div class="where">where
    Self: <a class="trait" href="../../../all/trait.Sync.html" title="trait devela::all::Sync">Sync</a> + <a class="trait" href="../../../all/trait.Unpin.html" title="trait devela::all::Unpin">Unpin</a>,</div></h4></section></summary><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>unsafe_slice</code></strong> only.</div></span><div class='docblock'>View a <code>Sync + Unpin</code> <code>self</code> as <code>&amp;[u8]</code>. <a href="../../../all/trait.ExtMem.html#method.mem_as_bytes">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_as_bytes_mut" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#121">Source</a><a href="#method.mem_as_bytes_mut" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.ExtMem.html#method.mem_as_bytes_mut" class="fn">mem_as_bytes_mut</a>(&amp;mut self) -&gt; &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;mut [u8]">â“˜</a><div class="where">where
    Self: <a class="trait" href="../../../all/trait.Sync.html" title="trait devela::all::Sync">Sync</a> + <a class="trait" href="../../../all/trait.Unpin.html" title="trait devela::all::Unpin">Unpin</a>,</div></h4></section></summary><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>unsafe_slice</code></strong> only.</div></span><div class='docblock'>View a <code>Sync + Unpin</code> <code>self</code> as <code>&amp;mut [u8]</code>. <a href="../../../all/trait.ExtMem.html#method.mem_as_bytes_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#791">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../code/trait.From.html" title="trait devela::code::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#794">Source</a><a href="#method.from" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../code/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-FromPyObjectBound%3C'_,+'py%3E-for-T" class="impl"><a href="#impl-FromPyObjectBound%3C'_,+'py%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;'py, T&gt; <a class="trait" href="../conversion/trait.FromPyObjectBound.html" title="trait devela::_dep::pyo3::conversion::FromPyObjectBound">FromPyObjectBound</a>&lt;'_, 'py&gt; for T<div class="where">where
    T: <a class="trait" href="../trait.FromPyObject.html" title="trait devela::_dep::pyo3::FromPyObject">FromPyObject</a>&lt;'py&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_py_object_bound" class="method trait-impl"><a href="#method.from_py_object_bound" class="anchor">Â§</a><h4 class="code-header">fn <a href="../conversion/trait.FromPyObjectBound.html#tymethod.from_py_object_bound" class="fn">from_py_object_bound</a>(ob: <a class="struct" href="../struct.Borrowed.html" title="struct devela::_dep::pyo3::Borrowed">Borrowed</a>&lt;'_, 'py, <a class="struct" href="../struct.PyAny.html" title="struct devela::_dep::pyo3::PyAny">PyAny</a>&gt;) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;T, <a class="struct" href="../struct.PyErr.html" title="struct devela::_dep::pyo3::PyErr">PyErr</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;T, PyErr&gt;">â“˜</a></h4></section></summary><div class='docblock'>Extracts <code>Self</code> from the bound smart pointer <code>obj</code>. <a href="../conversion/trait.FromPyObjectBound.html#tymethod.from_py_object_bound">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-FromSample%3CS%3E-for-S" class="impl"><a href="#impl-FromSample%3CS%3E-for-S" class="anchor">Â§</a><h3 class="code-header">impl&lt;S&gt; FromSample&lt;S&gt; for S</h3></section></summary><div class="impl-items"><section id="method.from_sample_" class="method trait-impl"><a href="#method.from_sample_" class="anchor">Â§</a><h4 class="code-header">fn <a class="fn">from_sample_</a>(s: S) -&gt; S</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Hook-for-T" class="impl"><a class="src rightside" href="../../../../src/devela/code/result/chain_hook.rs.html#121">Source</a><a href="#impl-Hook-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../all/trait.Hook.html" title="trait devela::all::Hook">Hook</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hook_ref" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/result/chain_hook.rs.html#97-103">Source</a><a href="#method.hook_ref" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.Hook.html#method.hook_ref" class="fn">hook_ref</a>&lt;F&gt;(self, f: F) -&gt; Self<div class="where">where
    F: <a class="trait" href="../../../all/trait.FnOnce.html" title="trait devela::all::FnOnce">FnOnce</a>(&amp;Self),</div></h4></section></summary><div class='docblock'>Applies a function which takes the parameter by shared reference,
and then returns the (possibly) modified owned value. <a href="../../../all/trait.Hook.html#method.hook_ref">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.hook_mut" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/result/chain_hook.rs.html#113-119">Source</a><a href="#method.hook_mut" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.Hook.html#method.hook_mut" class="fn">hook_mut</a>&lt;F&gt;(self, f: F) -&gt; Self<div class="where">where
    F: <a class="trait" href="../../../all/trait.FnOnce.html" title="trait devela::all::FnOnce">FnOnce</a>(&amp;mut Self),</div></h4></section></summary><div class='docblock'>Applies a function which takes the parameter by exclusive reference,
and then returns the (possibly) modified owned value. <a href="../../../all/trait.Hook.html#method.hook_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#773-775">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../../../code/trait.Into.html" title="trait devela::code::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="../../../code/trait.From.html" title="trait devela::code::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#783">Source</a><a href="#method.into" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../code/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="../../../code/trait.From.html" title="trait devela::code::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-IntoEither-for-T" class="impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#64">Source</a><a href="#impl-IntoEither-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html" title="trait either::into_either::IntoEither">IntoEither</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_either" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#29">Source</a><a href="#method.into_either" class="anchor">Â§</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either" class="fn">into_either</a>(self, into_left: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="enum" href="../../itertools/enum.Either.html" title="enum devela::_dep::itertools::Either">Either</a>&lt;Self, Self&gt; <a href="#" class="tooltip" data-notable-ty="Either&lt;Self, Self&gt;">â“˜</a></h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="../../itertools/enum.Either.html#variant.Left" title="variant devela::_dep::itertools::Either::Left"><code>Left</code></a> variant of <a href="../../itertools/enum.Either.html" title="enum devela::_dep::itertools::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left</code> is <code>true</code>.
Converts <code>self</code> into a <a href="../../itertools/enum.Either.html#variant.Right" title="variant devela::_dep::itertools::Either::Right"><code>Right</code></a> variant of <a href="../../itertools/enum.Either.html" title="enum devela::_dep::itertools::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.into_either_with" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#55-57">Source</a><a href="#method.into_either_with" class="anchor">Â§</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with" class="fn">into_either_with</a>&lt;F&gt;(self, into_left: F) -&gt; <a class="enum" href="../../itertools/enum.Either.html" title="enum devela::_dep::itertools::Either">Either</a>&lt;Self, Self&gt; <a href="#" class="tooltip" data-notable-ty="Either&lt;Self, Self&gt;">â“˜</a><div class="where">where
    F: <a class="trait" href="../../../all/trait.FnOnce.html" title="trait devela::all::FnOnce">FnOnce</a>(&amp;Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="../../itertools/enum.Either.html#variant.Left" title="variant devela::_dep::itertools::Either::Left"><code>Left</code></a> variant of <a href="../../itertools/enum.Either.html" title="enum devela::_dep::itertools::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left(&amp;self)</code> returns <code>true</code>.
Converts <code>self</code> into a <a href="../../itertools/enum.Either.html#variant.Right" title="variant devela::_dep::itertools::Either::Right"><code>Right</code></a> variant of <a href="../../itertools/enum.Either.html" title="enum devela::_dep::itertools::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-IntoPyObjectExt%3C'py%3E-for-T" class="impl"><a href="#impl-IntoPyObjectExt%3C'py%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;'py, T&gt; <a class="trait" href="../trait.IntoPyObjectExt.html" title="trait devela::_dep::pyo3::IntoPyObjectExt">IntoPyObjectExt</a>&lt;'py&gt; for T<div class="where">where
    T: <a class="trait" href="../trait.IntoPyObject.html" title="trait devela::_dep::pyo3::IntoPyObject">IntoPyObject</a>&lt;'py&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_bound_py_any" class="method trait-impl"><a href="#method.into_bound_py_any" class="anchor">Â§</a><h4 class="code-header">fn <a href="../trait.IntoPyObjectExt.html#method.into_bound_py_any" class="fn">into_bound_py_any</a>(self, py: <a class="struct" href="../struct.Python.html" title="struct devela::_dep::pyo3::Python">Python</a>&lt;'py&gt;) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;<a class="struct" href="../struct.Bound.html" title="struct devela::_dep::pyo3::Bound">Bound</a>&lt;'py, <a class="struct" href="../struct.PyAny.html" title="struct devela::_dep::pyo3::PyAny">PyAny</a>&gt;, <a class="struct" href="../struct.PyErr.html" title="struct devela::_dep::pyo3::PyErr">PyErr</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;Bound&lt;&#39;py, PyAny&gt;, PyErr&gt;">â“˜</a></h4></section></summary><div class='docblock'>Converts <code>self</code> into an owned Python object, dropping type information.</div></details><details class="toggle method-toggle" open><summary><section id="method.into_py_any" class="method trait-impl"><a href="#method.into_py_any" class="anchor">Â§</a><h4 class="code-header">fn <a href="../trait.IntoPyObjectExt.html#method.into_py_any" class="fn">into_py_any</a>(self, py: <a class="struct" href="../struct.Python.html" title="struct devela::_dep::pyo3::Python">Python</a>&lt;'py&gt;) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;<a class="struct" href="../struct.Py.html" title="struct devela::_dep::pyo3::Py">Py</a>&lt;<a class="struct" href="../struct.PyAny.html" title="struct devela::_dep::pyo3::PyAny">PyAny</a>&gt;, <a class="struct" href="../struct.PyErr.html" title="struct devela::_dep::pyo3::PyErr">PyErr</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;Py&lt;PyAny&gt;, PyErr&gt;">â“˜</a></h4></section></summary><div class='docblock'>Converts <code>self</code> into an owned Python object, dropping type information and unbinding it
from the <code>'py</code> lifetime.</div></details><details class="toggle method-toggle" open><summary><section id="method.into_pyobject_or_pyerr" class="method trait-impl"><a href="#method.into_pyobject_or_pyerr" class="anchor">Â§</a><h4 class="code-header">fn <a href="../trait.IntoPyObjectExt.html#method.into_pyobject_or_pyerr" class="fn">into_pyobject_or_pyerr</a>(self, py: <a class="struct" href="../struct.Python.html" title="struct devela::_dep::pyo3::Python">Python</a>&lt;'py&gt;) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;Self::<a class="associatedtype" href="../trait.IntoPyObject.html#associatedtype.Output" title="type devela::_dep::pyo3::IntoPyObject::Output">Output</a>, <a class="struct" href="../struct.PyErr.html" title="struct devela::_dep::pyo3::PyErr">PyErr</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;Self::Output, PyErr&gt;">â“˜</a></h4></section></summary><div class='docblock'>Converts <code>self</code> into a Python object. <a href="../trait.IntoPyObjectExt.html#method.into_pyobject_or_pyerr">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-IntoSample%3CT%3E-for-F" class="impl"><a href="#impl-IntoSample%3CT%3E-for-F" class="anchor">Â§</a><h3 class="code-header">impl&lt;F, T&gt; <a class="trait" href="../../symphonia/core/conv/trait.IntoSample.html" title="trait devela::_dep::symphonia::core::conv::IntoSample">IntoSample</a>&lt;T&gt; for F<div class="where">where
    T: <a class="trait" href="../../symphonia/core/conv/trait.FromSample.html" title="trait devela::_dep::symphonia::core::conv::FromSample">FromSample</a>&lt;F&gt;,</div></h3></section></summary><div class="impl-items"><section id="method.into_sample" class="method trait-impl"><a href="#method.into_sample" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../symphonia/core/conv/trait.IntoSample.html#tymethod.into_sample" class="fn">into_sample</a>(self) -&gt; T</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Pointable-for-T" class="impl"><a href="#impl-Pointable-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; Pointable for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.ALIGN" class="associatedconstant trait-impl"><a href="#associatedconstant.ALIGN" class="anchor">Â§</a><h4 class="code-header">const <a class="constant">ALIGN</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>The alignment of pointer.</div></details><details class="toggle" open><summary><section id="associatedtype.Init" class="associatedtype trait-impl"><a href="#associatedtype.Init" class="anchor">Â§</a><h4 class="code-header">type <a class="associatedtype">Init</a> = T</h4></section></summary><div class='docblock'>The type for initializers.</div></details><details class="toggle method-toggle" open><summary><section id="method.init" class="method trait-impl"><a href="#method.init" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a class="fn">init</a>(init: &lt;T as Pointable&gt;::Init) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Initializes a with the given initializer. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.deref-1" class="method trait-impl"><a href="#method.deref-1" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a class="fn">deref</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a T</a></h4></section></summary><div class='docblock'>Dereferences the given pointer. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.deref_mut" class="method trait-impl"><a href="#method.deref_mut" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a class="fn">deref_mut</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a mut T</a></h4></section></summary><div class='docblock'>Mutably dereferences the given pointer. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.drop" class="method trait-impl"><a href="#method.drop" class="anchor">Â§</a><h4 class="code-header">unsafe fn <a class="fn">drop</a>(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></section></summary><div class='docblock'>Drops the object pointed to by the given pointer. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-PyErrArguments-for-T" class="impl"><a href="#impl-PyErrArguments-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../trait.PyErrArguments.html" title="trait devela::_dep::pyo3::PyErrArguments">PyErrArguments</a> for T<div class="where">where
    T: for&lt;'py&gt; <a class="trait" href="../trait.IntoPyObject.html" title="trait devela::_dep::pyo3::IntoPyObject">IntoPyObject</a>&lt;'py&gt; + <a class="trait" href="../../../all/trait.Send.html" title="trait devela::all::Send">Send</a> + <a class="trait" href="../../../all/trait.Sync.html" title="trait devela::all::Sync">Sync</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.arguments" class="method trait-impl"><a href="#method.arguments" class="anchor">Â§</a><h4 class="code-header">fn <a href="../trait.PyErrArguments.html#tymethod.arguments" class="fn">arguments</a>(self, py: <a class="struct" href="../struct.Python.html" title="struct devela::_dep::pyo3::Python">Python</a>&lt;'_&gt;) -&gt; <a class="struct" href="../struct.Py.html" title="struct devela::_dep::pyo3::Py">Py</a>&lt;<a class="struct" href="../struct.PyAny.html" title="struct devela::_dep::pyo3::PyAny">PyAny</a>&gt;</h4></section></summary><div class='docblock'>Arguments for exception</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Receiver-for-P" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/ops/deref.rs.html#380-382">Source</a><a href="#impl-Receiver-for-P" class="anchor">Â§</a><h3 class="code-header">impl&lt;P, T&gt; <a class="trait" href="../../../_core/ops/trait.Receiver.html" title="trait devela::_core::ops::Receiver">Receiver</a> for P<div class="where">where
    P: <a class="trait" href="../../../all/trait.Deref.html" title="trait devela::all::Deref">Deref</a>&lt;Target = T&gt; + ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,
    T: ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Target-3" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/ops/deref.rs.html#384">Source</a><a href="#associatedtype.Target-3" class="anchor">Â§</a><h4 class="code-header">type <a href="../../../_core/ops/trait.Receiver.html#associatedtype.Target" class="associatedtype">Target</a> = T</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">ğŸ”¬</span><span>This is a nightly-only experimental API. (<code>arbitrary_self_types</code>)</span></div></span><div class='docblock'>The target type on which the method may be called.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-StringZilla%3C'a,+N%3E-for-T" class="impl"><a href="#impl-StringZilla%3C'a,+N%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;'a, T, N&gt; <a class="trait" href="../../stringzilla/trait.StringZilla.html" title="trait devela::_dep::stringzilla::StringZilla">StringZilla</a>&lt;'a, N&gt; for T<div class="where">where
    T: <a class="trait" href="../../../code/trait.AsRef.html" title="trait devela::code::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt; + ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,
    N: <a class="trait" href="../../../code/trait.AsRef.html" title="trait devela::code::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt; + 'a,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sz_find" class="method trait-impl"><a href="#method.sz_find" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_find" class="fn">sz_find</a>(&amp;self, needle: N) -&gt; <a class="enum" href="../../../all/enum.Option.html" title="enum devela::all::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a href="#" class="tooltip" data-notable-ty="Option&lt;usize&gt;">â“˜</a></h4></section></summary><div class='docblock'>Searches for the first occurrence of <code>needle</code> in <code>self</code>. <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_find">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.sz_rfind" class="method trait-impl"><a href="#method.sz_rfind" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_rfind" class="fn">sz_rfind</a>(&amp;self, needle: N) -&gt; <a class="enum" href="../../../all/enum.Option.html" title="enum devela::all::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a href="#" class="tooltip" data-notable-ty="Option&lt;usize&gt;">â“˜</a></h4></section></summary><div class='docblock'>Searches for the last occurrence of <code>needle</code> in <code>self</code>. <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_rfind">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.sz_find_char_from" class="method trait-impl"><a href="#method.sz_find_char_from" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_find_char_from" class="fn">sz_find_char_from</a>(&amp;self, needles: N) -&gt; <a class="enum" href="../../../all/enum.Option.html" title="enum devela::all::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a href="#" class="tooltip" data-notable-ty="Option&lt;usize&gt;">â“˜</a></h4></section></summary><div class='docblock'>Finds the index of the first character in <code>self</code> that is also present in <code>needles</code>. <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_find_char_from">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.sz_rfind_char_from" class="method trait-impl"><a href="#method.sz_rfind_char_from" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_rfind_char_from" class="fn">sz_rfind_char_from</a>(&amp;self, needles: N) -&gt; <a class="enum" href="../../../all/enum.Option.html" title="enum devela::all::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a href="#" class="tooltip" data-notable-ty="Option&lt;usize&gt;">â“˜</a></h4></section></summary><div class='docblock'>Finds the index of the last character in <code>self</code> that is also present in <code>needles</code>. <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_rfind_char_from">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.sz_find_char_not_from" class="method trait-impl"><a href="#method.sz_find_char_not_from" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_find_char_not_from" class="fn">sz_find_char_not_from</a>(&amp;self, needles: N) -&gt; <a class="enum" href="../../../all/enum.Option.html" title="enum devela::all::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a href="#" class="tooltip" data-notable-ty="Option&lt;usize&gt;">â“˜</a></h4></section></summary><div class='docblock'>Finds the index of the first character in <code>self</code> that is not present in <code>needles</code>. <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_find_char_not_from">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.sz_rfind_char_not_from" class="method trait-impl"><a href="#method.sz_rfind_char_not_from" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_rfind_char_not_from" class="fn">sz_rfind_char_not_from</a>(&amp;self, needles: N) -&gt; <a class="enum" href="../../../all/enum.Option.html" title="enum devela::all::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt; <a href="#" class="tooltip" data-notable-ty="Option&lt;usize&gt;">â“˜</a></h4></section></summary><div class='docblock'>Finds the index of the last character in <code>self</code> that is not present in <code>needles</code>. <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_rfind_char_not_from">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.sz_edit_distance" class="method trait-impl"><a href="#method.sz_edit_distance" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_edit_distance" class="fn">sz_edit_distance</a>(&amp;self, other: N) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Computes the Levenshtein edit distance between <code>self</code> and <code>other</code>. <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_edit_distance">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.sz_alignment_score" class="method trait-impl"><a href="#method.sz_alignment_score" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_alignment_score" class="fn">sz_alignment_score</a>(
    &amp;self,
    other: N,
    matrix: [[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i8.html">i8</a>; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.array.html">256</a>]; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.array.html">256</a>],
    gap: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i8.html">i8</a>,
) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.isize.html">isize</a></h4></section></summary><div class='docblock'>Computes the alignment score between <code>self</code> and <code>other</code> using the specified
substitution matrix and gap penalty. <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_alignment_score">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.sz_matches" class="method trait-impl"><a href="#method.sz_matches" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_matches" class="fn">sz_matches</a>(&amp;'a self, needle: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a N</a>) -&gt; <a class="struct" href="../../stringzilla/struct.RangeMatches.html" title="struct devela::_dep::stringzilla::RangeMatches">RangeMatches</a>&lt;'a&gt; <a href="#" class="tooltip" data-notable-ty="RangeMatches&lt;&#39;a&gt;">â“˜</a></h4></section></summary><div class='docblock'>Returns an iterator over all non-overlapping matches of the given <code>needle</code> in <code>self</code>. <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_matches">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.sz_rmatches" class="method trait-impl"><a href="#method.sz_rmatches" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_rmatches" class="fn">sz_rmatches</a>(&amp;'a self, needle: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a N</a>) -&gt; <a class="struct" href="../../stringzilla/struct.RangeRMatches.html" title="struct devela::_dep::stringzilla::RangeRMatches">RangeRMatches</a>&lt;'a&gt; <a href="#" class="tooltip" data-notable-ty="RangeRMatches&lt;&#39;a&gt;">â“˜</a></h4></section></summary><div class='docblock'>Returns an iterator over all non-overlapping matches of the given <code>needle</code> in <code>self</code>, searching from the end. <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_rmatches">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.sz_splits" class="method trait-impl"><a href="#method.sz_splits" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_splits" class="fn">sz_splits</a>(&amp;'a self, needle: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a N</a>) -&gt; <a class="struct" href="../../stringzilla/struct.RangeSplits.html" title="struct devela::_dep::stringzilla::RangeSplits">RangeSplits</a>&lt;'a&gt; <a href="#" class="tooltip" data-notable-ty="RangeSplits&lt;&#39;a&gt;">â“˜</a></h4></section></summary><div class='docblock'>Returns an iterator over the substrings of <code>self</code> that are separated by the given <code>needle</code>. <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_splits">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.sz_rsplits" class="method trait-impl"><a href="#method.sz_rsplits" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_rsplits" class="fn">sz_rsplits</a>(&amp;'a self, needle: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a N</a>) -&gt; <a class="struct" href="../../stringzilla/struct.RangeRSplits.html" title="struct devela::_dep::stringzilla::RangeRSplits">RangeRSplits</a>&lt;'a&gt; <a href="#" class="tooltip" data-notable-ty="RangeRSplits&lt;&#39;a&gt;">â“˜</a></h4></section></summary><div class='docblock'>Returns an iterator over the substrings of <code>self</code> that are separated by the given <code>needle</code>, searching from the end. <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_rsplits">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.sz_find_first_of" class="method trait-impl"><a href="#method.sz_find_first_of" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_find_first_of" class="fn">sz_find_first_of</a>(&amp;'a self, needles: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a N</a>) -&gt; <a class="struct" href="../../stringzilla/struct.RangeMatches.html" title="struct devela::_dep::stringzilla::RangeMatches">RangeMatches</a>&lt;'a&gt; <a href="#" class="tooltip" data-notable-ty="RangeMatches&lt;&#39;a&gt;">â“˜</a></h4></section></summary><div class='docblock'>Returns an iterator over all non-overlapping matches of any of the bytes in <code>needles</code> within <code>self</code>. <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_find_first_of">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.sz_find_last_of" class="method trait-impl"><a href="#method.sz_find_last_of" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_find_last_of" class="fn">sz_find_last_of</a>(&amp;'a self, needles: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a N</a>) -&gt; <a class="struct" href="../../stringzilla/struct.RangeRMatches.html" title="struct devela::_dep::stringzilla::RangeRMatches">RangeRMatches</a>&lt;'a&gt; <a href="#" class="tooltip" data-notable-ty="RangeRMatches&lt;&#39;a&gt;">â“˜</a></h4></section></summary><div class='docblock'>Returns an iterator over all non-overlapping matches of any of the bytes in <code>needles</code> within <code>self</code>, searching from the end. <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_find_last_of">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.sz_find_first_not_of" class="method trait-impl"><a href="#method.sz_find_first_not_of" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_find_first_not_of" class="fn">sz_find_first_not_of</a>(&amp;'a self, needles: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a N</a>) -&gt; <a class="struct" href="../../stringzilla/struct.RangeMatches.html" title="struct devela::_dep::stringzilla::RangeMatches">RangeMatches</a>&lt;'a&gt; <a href="#" class="tooltip" data-notable-ty="RangeMatches&lt;&#39;a&gt;">â“˜</a></h4></section></summary><div class='docblock'>Returns an iterator over all non-overlapping matches of any byte not in <code>needles</code> within <code>self</code>. <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_find_first_not_of">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.sz_find_last_not_of" class="method trait-impl"><a href="#method.sz_find_last_not_of" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_find_last_not_of" class="fn">sz_find_last_not_of</a>(&amp;'a self, needles: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a N</a>) -&gt; <a class="struct" href="../../stringzilla/struct.RangeRMatches.html" title="struct devela::_dep::stringzilla::RangeRMatches">RangeRMatches</a>&lt;'a&gt; <a href="#" class="tooltip" data-notable-ty="RangeRMatches&lt;&#39;a&gt;">â“˜</a></h4></section></summary><div class='docblock'>Returns an iterator over all non-overlapping matches of any byte not in <code>needles</code> within <code>self</code>, searching from the end. <a href="../../stringzilla/trait.StringZilla.html#tymethod.sz_find_last_not_of">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToSample%3CU%3E-for-T" class="impl"><a href="#impl-ToSample%3CU%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, U&gt; ToSample&lt;U&gt; for T<div class="where">where
    U: FromSample&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><section id="method.to_sample_" class="method trait-impl"><a href="#method.to_sample_" class="anchor">Â§</a><h4 class="code-header">fn <a class="fn">to_sample_</a>(self) -&gt; U</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToString-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/string.rs.html#2796">Source</a><a href="#impl-ToString-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../all/trait.ToString.html" title="trait devela::all::ToString">ToString</a> for T<div class="where">where
    T: <a class="trait" href="../../../all/trait.Display.html" title="trait devela::all::Display">Display</a> + ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.to_string" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/string.rs.html#2798">Source</a><a href="#method.to_string" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../all/trait.ToString.html#tymethod.to_string" class="fn">to_string</a>(&amp;self) -&gt; <a class="struct" href="../../../all/struct.String.html" title="struct devela::all::String">String</a> <a href="#" class="tooltip" data-notable-ty="String">â“˜</a></h4></section></summary><div class='docblock'>Converts the given value to a <code>String</code>. <a href="../../../all/trait.ToString.html#tymethod.to_string">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#833-835">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../../../code/trait.TryFrom.html" title="trait devela::code::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="../../../code/trait.Into.html" title="trait devela::code::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-4" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#837">Source</a><a href="#associatedtype.Error-4" class="anchor">Â§</a><h4 class="code-header">type <a href="../../../code/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="../../../code/enum.Infallible.html" title="enum devela::code::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#840">Source</a><a href="#method.try_from-1" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../code/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="../../../code/trait.TryFrom.html" title="trait devela::code::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="../../../code/trait.TryFrom.html#associatedtype.Error" title="type devela::code::TryFrom::Error">Error</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;">â“˜</a></h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#817-819">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../../../code/trait.TryInto.html" title="trait devela::code::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="../../../code/trait.TryFrom.html" title="trait devela::code::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-3" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#821">Source</a><a href="#associatedtype.Error-3" class="anchor">Â§</a><h4 class="code-header">type <a href="../../../code/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="../../../code/trait.TryFrom.html" title="trait devela::code::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="../../../code/trait.TryFrom.html#associatedtype.Error" title="type devela::code::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#824">Source</a><a href="#method.try_into" class="anchor">Â§</a><h4 class="code-header">fn <a href="../../../code/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="../../../code/trait.TryFrom.html" title="trait devela::code::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="../../../code/trait.TryFrom.html#associatedtype.Error" title="type devela::code::TryFrom::Error">Error</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;">â“˜</a></h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><section id="impl-Duplex%3CS%3E-for-T" class="impl"><a href="#impl-Duplex%3CS%3E-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;S, T&gt; Duplex&lt;S&gt; for T<div class="where">where
    T: FromSample&lt;S&gt; + ToSample&lt;S&gt;,</div></h3></section><section id="impl-Ungil-for-T" class="impl"><a href="#impl-Ungil-for-T" class="anchor">Â§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../marker/trait.Ungil.html" title="trait devela::_dep::pyo3::marker::Ungil">Ungil</a> for T<div class="where">where
    T: <a class="trait" href="../../../all/trait.Send.html" title="trait devela::all::Send">Send</a>,</div></h3></section></div><script type="text/json" id="notable-traits-data">{"&'static str":"<h3>Notable traits for <code><a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a></code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"../../../all/trait.ExtStr.html\" title=\"trait devela::all::ExtStr\">ExtStr</a> for <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a></div>","&[AsciiChar]":"<h3>Notable traits for <code><a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></code></h3><pre><code><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtSlice.html\" title=\"trait devela::all::ExtSlice\">ExtSlice</a>&lt;T&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtSliceMut.html\" title=\"trait devela::all::ExtSliceMut\">ExtSliceMut</a>&lt;T&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtSlice.html\" title=\"trait devela::all::ExtSlice\">ExtSlice</a>&lt;T&gt; for &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div>","&[u8]":"<h3>Notable traits for <code>&amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"../../../all/trait.IoRead.html\" title=\"trait devela::all::IoRead\">Read</a> for &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>]</div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtSlice.html\" title=\"trait devela::all::ExtSlice\">ExtSlice</a>&lt;T&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtSliceMut.html\" title=\"trait devela::all::ExtSliceMut\">ExtSliceMut</a>&lt;T&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtSlice.html\" title=\"trait devela::all::ExtSlice\">ExtSlice</a>&lt;T&gt; for &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div>","&mut [u8]":"<h3>Notable traits for <code>&amp;mut [<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"../../../all/trait.IoWrite.html\" title=\"trait devela::all::IoWrite\">Write</a> for &amp;mut [<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>]</div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtSlice.html\" title=\"trait devela::all::ExtSlice\">ExtSlice</a>&lt;T&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtSliceMut.html\" title=\"trait devela::all::ExtSliceMut\">ExtSliceMut</a>&lt;T&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtSlice.html\" title=\"trait devela::all::ExtSlice\">ExtSlice</a>&lt;T&gt; for &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtSliceMut.html\" title=\"trait devela::all::ExtSliceMut\">ExtSliceMut</a>&lt;T&gt; for &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div>","&str":"<h3>Notable traits for <code><a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a></code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"../../../all/trait.ExtStr.html\" title=\"trait devela::all::ExtStr\">ExtStr</a> for <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a></div>","(&str, &str)":"<h3>Notable traits for <code><a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.tuple.html\">(_0, _1)</a></code></h3><pre><code><div class=\"where\">impl&lt;_0, _1&gt; <a class=\"trait\" href=\"../../../all/trait.Tuple.html\" title=\"trait devela::all::Tuple\">Tuple</a> for <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.tuple.html\">(_0, _1)</a></div><div class=\"where\">    type <a href=\"../../../all/trait.Tuple.html#associatedtype.Head\" class=\"associatedtype\">Head</a> = _0;</div><div class=\"where\">    type <a href=\"../../../all/trait.Tuple.html#associatedtype.Tail\" class=\"associatedtype\">Tail</a> = _1;</div><div class=\"where\">    type <a href=\"../../../all/trait.Tuple.html#associatedtype.NoHead\" class=\"associatedtype\">NoHead</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.tuple.html\">(_1,)</a>;</div><div class=\"where\">    type <a href=\"../../../all/trait.Tuple.html#associatedtype.NoTail\" class=\"associatedtype\">NoTail</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.tuple.html\">(_0,)</a>;</div><div class=\"where\">    type <a href=\"../../../all/trait.Tuple.html#associatedtype.Append\" class=\"associatedtype\">Append</a>&lt;T&gt; = <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.tuple.html\">(_0, _1, T)</a>;</div><div class=\"where\">    type <a href=\"../../../all/trait.Tuple.html#associatedtype.Prepend\" class=\"associatedtype\">Prepend</a>&lt;T&gt; = <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.tuple.html\">(T, _0, _1)</a>;</div><div class=\"where\">    type <a href=\"../../../all/trait.Tuple.html#associatedtype._0\" class=\"associatedtype\">_0</a> = _0;</div><div class=\"where\">    type <a href=\"../../../all/trait.Tuple.html#associatedtype._1\" class=\"associatedtype\">_1</a> = _1;</div><div class=\"where\">    type <a href=\"../../../all/trait.Tuple.html#associatedtype._2\" class=\"associatedtype\">_2</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>;</div><div class=\"where\">    type <a href=\"../../../all/trait.Tuple.html#associatedtype._3\" class=\"associatedtype\">_3</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>;</div><div class=\"where\">    type <a href=\"../../../all/trait.Tuple.html#associatedtype._4\" class=\"associatedtype\">_4</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>;</div><div class=\"where\">    type <a href=\"../../../all/trait.Tuple.html#associatedtype._5\" class=\"associatedtype\">_5</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>;</div><div class=\"where\">    type <a href=\"../../../all/trait.Tuple.html#associatedtype._6\" class=\"associatedtype\">_6</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>;</div><div class=\"where\">    type <a href=\"../../../all/trait.Tuple.html#associatedtype._7\" class=\"associatedtype\">_7</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>;</div><div class=\"where\">    type <a href=\"../../../all/trait.Tuple.html#associatedtype._8\" class=\"associatedtype\">_8</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>;</div><div class=\"where\">    type <a href=\"../../../all/trait.Tuple.html#associatedtype._9\" class=\"associatedtype\">_9</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>;</div><div class=\"where\">    type <a href=\"../../../all/trait.Tuple.html#associatedtype._10\" class=\"associatedtype\">_10</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>;</div><div class=\"where\">    type <a href=\"../../../all/trait.Tuple.html#associatedtype._11\" class=\"associatedtype\">_11</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.unit.html\">()</a>;</div><div class=\"where\">impl&lt;Candidate, Requirement&gt; <a class=\"trait\" href=\"../../../all/trait.MemAligned.html\" title=\"trait devela::all::MemAligned\">MemAligned</a> for <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.tuple.html\">(Candidate, Requirement)</a></div>","Bytes<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../../_core/str/struct.Bytes.html\" title=\"struct devela::_core::str::Bytes\">Bytes</a>&lt;'_&gt;</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../../_core/str/struct.Bytes.html\" title=\"struct devela::_core::str::Bytes\">Bytes</a>&lt;'_&gt;</div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>;</div>","CharIndices<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../../_core/str/struct.CharIndices.html\" title=\"struct devela::_core::str::CharIndices\">CharIndices</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../../_core/str/struct.CharIndices.html\" title=\"struct devela::_core::str::CharIndices\">CharIndices</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.usize.html\">usize</a>, <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.char.html\">char</a>);</div>","Chars<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../../text/struct.IterChars.html\" title=\"struct devela::text::IterChars\">Chars</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../../text/struct.IterChars.html\" title=\"struct devela::text::IterChars\">Chars</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.char.html\">char</a>;</div>","Either<Self, Self>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../itertools/enum.Either.html\" title=\"enum devela::_dep::itertools::Either\">Either</a>&lt;L, R&gt;</code></h3><pre><code><div class=\"where\">impl&lt;L, R&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"enum\" href=\"../../itertools/enum.Either.html\" title=\"enum devela::_dep::itertools::Either\">Either</a>&lt;L, R&gt;<div class=\"where\">where\n    L: <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a>,\n    R: <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a>&lt;Item = &lt;L as <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"../../../all/trait.Iterator.html#associatedtype.Item\" title=\"type devela::all::Iterator::Item\">Item</a>&gt;,</div></div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;L as <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"../../../all/trait.Iterator.html#associatedtype.Item\" title=\"type devela::all::Iterator::Item\">Item</a>;</div><div class=\"where\">impl&lt;L, R&gt; <a class=\"trait\" href=\"../../../all/trait.Future.html\" title=\"trait devela::all::Future\">Future</a> for <a class=\"enum\" href=\"../../itertools/enum.Either.html\" title=\"enum devela::_dep::itertools::Either\">Either</a>&lt;L, R&gt;<div class=\"where\">where\n    L: <a class=\"trait\" href=\"../../../all/trait.Future.html\" title=\"trait devela::all::Future\">Future</a>,\n    R: <a class=\"trait\" href=\"../../../all/trait.Future.html\" title=\"trait devela::all::Future\">Future</a>&lt;Output = &lt;L as <a class=\"trait\" href=\"../../../all/trait.Future.html\" title=\"trait devela::all::Future\">Future</a>&gt;::<a class=\"associatedtype\" href=\"../../../all/trait.Future.html#associatedtype.Output\" title=\"type devela::all::Future::Output\">Output</a>&gt;,</div></div><div class=\"where\">    type <a href=\"../../../all/trait.Future.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = &lt;L as <a class=\"trait\" href=\"../../../all/trait.Future.html\" title=\"trait devela::all::Future\">Future</a>&gt;::<a class=\"associatedtype\" href=\"../../../all/trait.Future.html#associatedtype.Output\" title=\"type devela::all::Future::Output\">Output</a>;</div><div class=\"where\">impl&lt;L, R&gt; <a class=\"trait\" href=\"../../../all/trait.IoRead.html\" title=\"trait devela::all::IoRead\">Read</a> for <a class=\"enum\" href=\"../../itertools/enum.Either.html\" title=\"enum devela::_dep::itertools::Either\">Either</a>&lt;L, R&gt;<div class=\"where\">where\n    L: <a class=\"trait\" href=\"../../../all/trait.IoRead.html\" title=\"trait devela::all::IoRead\">Read</a>,\n    R: <a class=\"trait\" href=\"../../../all/trait.IoRead.html\" title=\"trait devela::all::IoRead\">Read</a>,</div></div><div class=\"where\">impl&lt;L, R&gt; <a class=\"trait\" href=\"../../../all/trait.IoWrite.html\" title=\"trait devela::all::IoWrite\">Write</a> for <a class=\"enum\" href=\"../../itertools/enum.Either.html\" title=\"enum devela::_dep::itertools::Either\">Either</a>&lt;L, R&gt;<div class=\"where\">where\n    L: <a class=\"trait\" href=\"../../../all/trait.IoWrite.html\" title=\"trait devela::all::IoWrite\">Write</a>,\n    R: <a class=\"trait\" href=\"../../../all/trait.IoWrite.html\" title=\"trait devela::all::IoWrite\">Write</a>,</div></div>","EncodeUtf16<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../../_core/str/struct.EncodeUtf16.html\" title=\"struct devela::_core::str::EncodeUtf16\">EncodeUtf16</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../../_core/str/struct.EncodeUtf16.html\" title=\"struct devela::_core::str::EncodeUtf16\">EncodeUtf16</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u16.html\">u16</a>;</div>","EscapeDebug<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../../_core/str/struct.EscapeDebug.html\" title=\"struct devela::_core::str::EscapeDebug\">EscapeDebug</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../../_core/str/struct.EscapeDebug.html\" title=\"struct devela::_core::str::EscapeDebug\">EscapeDebug</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.char.html\">char</a>;</div>","EscapeDefault<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../../_core/str/struct.EscapeDefault.html\" title=\"struct devela::_core::str::EscapeDefault\">EscapeDefault</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../../_core/str/struct.EscapeDefault.html\" title=\"struct devela::_core::str::EscapeDefault\">EscapeDefault</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.char.html\">char</a>;</div>","EscapeUnicode<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../../_core/str/struct.EscapeUnicode.html\" title=\"struct devela::_core::str::EscapeUnicode\">EscapeUnicode</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../../_core/str/struct.EscapeUnicode.html\" title=\"struct devela::_core::str::EscapeUnicode\">EscapeUnicode</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.char.html\">char</a>;</div>","Lines<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../../_core/str/struct.Lines.html\" title=\"struct devela::_core::str::Lines\">Lines</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../../_core/str/struct.Lines.html\" title=\"struct devela::_core::str::Lines\">Lines</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>;</div>","LinesAny<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../../_core/str/struct.LinesAny.html\" title=\"struct devela::_core::str::LinesAny\">LinesAny</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../../_core/str/struct.LinesAny.html\" title=\"struct devela::_core::str::LinesAny\">LinesAny</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>;</div>","MatchIndices<'_, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../../_core/str/struct.MatchIndices.html\" title=\"struct devela::_core::str::MatchIndices\">MatchIndices</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../../_core/str/struct.MatchIndices.html\" title=\"struct devela::_core::str::MatchIndices\">MatchIndices</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../../../_core/str/pattern/trait.Pattern.html\" title=\"trait devela::_core::str::pattern::Pattern\">Pattern</a>,</div></div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.usize.html\">usize</a>, &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>);</div>","Matches<'_, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../../_core/str/struct.Matches.html\" title=\"struct devela::_core::str::Matches\">Matches</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../../_core/str/struct.Matches.html\" title=\"struct devela::_core::str::Matches\">Matches</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../../../_core/str/pattern/trait.Pattern.html\" title=\"trait devela::_core::str::pattern::Pattern\">Pattern</a>,</div></div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>;</div>","Option<&<I as SliceIndex<str>>::Output>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtOption.html\" title=\"trait devela::all::ExtOption\">ExtOption</a>&lt;T&gt; for <a class=\"enum\" href=\"../../../all/enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</div>","Option<&T>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtOption.html\" title=\"trait devela::all::ExtOption\">ExtOption</a>&lt;T&gt; for <a class=\"enum\" href=\"../../../all/enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</div>","Option<&[AsciiChar]>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtOption.html\" title=\"trait devela::all::ExtOption\">ExtOption</a>&lt;T&gt; for <a class=\"enum\" href=\"../../../all/enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</div>","Option<&mut T>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtOption.html\" title=\"trait devela::all::ExtOption\">ExtOption</a>&lt;T&gt; for <a class=\"enum\" href=\"../../../all/enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</div>","Option<&str>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtOption.html\" title=\"trait devela::all::ExtOption\">ExtOption</a>&lt;T&gt; for <a class=\"enum\" href=\"../../../all/enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</div>","Option<(&str, &str)>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtOption.html\" title=\"trait devela::all::ExtOption\">ExtOption</a>&lt;T&gt; for <a class=\"enum\" href=\"../../../all/enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</div>","Option<Ordering>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtOption.html\" title=\"trait devela::all::ExtOption\">ExtOption</a>&lt;T&gt; for <a class=\"enum\" href=\"../../../all/enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</div>","Option<Range<usize>>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtOption.html\" title=\"trait devela::all::ExtOption\">ExtOption</a>&lt;T&gt; for <a class=\"enum\" href=\"../../../all/enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</div>","Option<usize>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtOption.html\" title=\"trait devela::all::ExtOption\">ExtOption</a>&lt;T&gt; for <a class=\"enum\" href=\"../../../all/enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</div>","RMatchIndices<'_, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../../_core/str/struct.RMatchIndices.html\" title=\"struct devela::_core::str::RMatchIndices\">RMatchIndices</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../../_core/str/struct.RMatchIndices.html\" title=\"struct devela::_core::str::RMatchIndices\">RMatchIndices</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../../../_core/str/pattern/trait.Pattern.html\" title=\"trait devela::_core::str::pattern::Pattern\">Pattern</a>,\n    &lt;P as <a class=\"trait\" href=\"../../../_core/str/pattern/trait.Pattern.html\" title=\"trait devela::_core::str::pattern::Pattern\">Pattern</a>&gt;::<a class=\"associatedtype\" href=\"../../../_core/str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type devela::_core::str::pattern::Pattern::Searcher\">Searcher</a>&lt;'a&gt;: <a class=\"trait\" href=\"../../../_core/str/pattern/trait.ReverseSearcher.html\" title=\"trait devela::_core::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = (<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.usize.html\">usize</a>, &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>);</div>","RMatches<'_, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../../_core/str/struct.RMatches.html\" title=\"struct devela::_core::str::RMatches\">RMatches</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../../_core/str/struct.RMatches.html\" title=\"struct devela::_core::str::RMatches\">RMatches</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../../../_core/str/pattern/trait.Pattern.html\" title=\"trait devela::_core::str::pattern::Pattern\">Pattern</a>,\n    &lt;P as <a class=\"trait\" href=\"../../../_core/str/pattern/trait.Pattern.html\" title=\"trait devela::_core::str::pattern::Pattern\">Pattern</a>&gt;::<a class=\"associatedtype\" href=\"../../../_core/str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type devela::_core::str::pattern::Pattern::Searcher\">Searcher</a>&lt;'a&gt;: <a class=\"trait\" href=\"../../../_core/str/pattern/trait.ReverseSearcher.html\" title=\"trait devela::_core::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>;</div>","RSplit<'_, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../../_core/str/struct.RSplit.html\" title=\"struct devela::_core::str::RSplit\">RSplit</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../../_core/str/struct.RSplit.html\" title=\"struct devela::_core::str::RSplit\">RSplit</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../../../_core/str/pattern/trait.Pattern.html\" title=\"trait devela::_core::str::pattern::Pattern\">Pattern</a>,\n    &lt;P as <a class=\"trait\" href=\"../../../_core/str/pattern/trait.Pattern.html\" title=\"trait devela::_core::str::pattern::Pattern\">Pattern</a>&gt;::<a class=\"associatedtype\" href=\"../../../_core/str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type devela::_core::str::pattern::Pattern::Searcher\">Searcher</a>&lt;'a&gt;: <a class=\"trait\" href=\"../../../_core/str/pattern/trait.ReverseSearcher.html\" title=\"trait devela::_core::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>;</div>","RSplitN<'_, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../../_core/str/struct.RSplitN.html\" title=\"struct devela::_core::str::RSplitN\">RSplitN</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../../_core/str/struct.RSplitN.html\" title=\"struct devela::_core::str::RSplitN\">RSplitN</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../../../_core/str/pattern/trait.Pattern.html\" title=\"trait devela::_core::str::pattern::Pattern\">Pattern</a>,\n    &lt;P as <a class=\"trait\" href=\"../../../_core/str/pattern/trait.Pattern.html\" title=\"trait devela::_core::str::pattern::Pattern\">Pattern</a>&gt;::<a class=\"associatedtype\" href=\"../../../_core/str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type devela::_core::str::pattern::Pattern::Searcher\">Searcher</a>&lt;'a&gt;: <a class=\"trait\" href=\"../../../_core/str/pattern/trait.ReverseSearcher.html\" title=\"trait devela::_core::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>;</div>","RSplitTerminator<'_, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../../_core/str/struct.RSplitTerminator.html\" title=\"struct devela::_core::str::RSplitTerminator\">RSplitTerminator</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../../_core/str/struct.RSplitTerminator.html\" title=\"struct devela::_core::str::RSplitTerminator\">RSplitTerminator</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../../../_core/str/pattern/trait.Pattern.html\" title=\"trait devela::_core::str::pattern::Pattern\">Pattern</a>,\n    &lt;P as <a class=\"trait\" href=\"../../../_core/str/pattern/trait.Pattern.html\" title=\"trait devela::_core::str::pattern::Pattern\">Pattern</a>&gt;::<a class=\"associatedtype\" href=\"../../../_core/str/pattern/trait.Pattern.html#associatedtype.Searcher\" title=\"type devela::_core::str::pattern::Pattern::Searcher\">Searcher</a>&lt;'a&gt;: <a class=\"trait\" href=\"../../../_core/str/pattern/trait.ReverseSearcher.html\" title=\"trait devela::_core::str::pattern::ReverseSearcher\">ReverseSearcher</a>&lt;'a&gt;,</div></div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>;</div>","RangeMatches<'a>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../stringzilla/struct.RangeMatches.html\" title=\"struct devela::_dep::stringzilla::RangeMatches\">RangeMatches</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../stringzilla/struct.RangeMatches.html\" title=\"struct devela::_dep::stringzilla::RangeMatches\">RangeMatches</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a [<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>];</div>","RangeRMatches<'a>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../stringzilla/struct.RangeRMatches.html\" title=\"struct devela::_dep::stringzilla::RangeRMatches\">RangeRMatches</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../stringzilla/struct.RangeRMatches.html\" title=\"struct devela::_dep::stringzilla::RangeRMatches\">RangeRMatches</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a [<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>];</div>","RangeRSplits<'a>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../stringzilla/struct.RangeRSplits.html\" title=\"struct devela::_dep::stringzilla::RangeRSplits\">RangeRSplits</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../stringzilla/struct.RangeRSplits.html\" title=\"struct devela::_dep::stringzilla::RangeRSplits\">RangeRSplits</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a [<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>];</div>","RangeSplits<'a>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../stringzilla/struct.RangeSplits.html\" title=\"struct devela::_dep::stringzilla::RangeSplits\">RangeSplits</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../stringzilla/struct.RangeSplits.html\" title=\"struct devela::_dep::stringzilla::RangeSplits\">RangeSplits</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a [<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>];</div>","Result<(), Error>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"../../../all/trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>","Result<<&PyBackedStr as IntoPyObject<'py>>::Output, <&PyBackedStr as IntoPyObject<'py>>::Error>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"../../../all/trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>","Result<<PyBackedStr as IntoPyObject<'py>>::Output, <PyBackedStr as IntoPyObject<'py>>::Error>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"../../../all/trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>","Result<Bound<'py, PyAny>, PyErr>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"../../../all/trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>","Result<F, <F as FromStr>::Err>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"../../../all/trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>","Result<Py<PyAny>, PyErr>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"../../../all/trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>","Result<PyBackedStr, <PyBackedStr as TryFrom<Bound<'_, PyString>>>::Error>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"../../../all/trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>","Result<PyBackedStr, PyErr>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"../../../all/trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>","Result<Self::Output, PyErr>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"../../../all/trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>","Result<T, <T as TryFrom<U>>::Error>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"../../../all/trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>","Result<T, PyErr>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"../../../all/trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>","Result<U, <U as TryFrom<T>>::Error>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"../../../all/trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>","Split<'_, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../../_core/str/struct.Split.html\" title=\"struct devela::_core::str::Split\">Split</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../../_core/str/struct.Split.html\" title=\"struct devela::_core::str::Split\">Split</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../../../_core/str/pattern/trait.Pattern.html\" title=\"trait devela::_core::str::pattern::Pattern\">Pattern</a>,</div></div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>;</div>","SplitAsciiWhitespace<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../../_core/str/struct.SplitAsciiWhitespace.html\" title=\"struct devela::_core::str::SplitAsciiWhitespace\">SplitAsciiWhitespace</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../../_core/str/struct.SplitAsciiWhitespace.html\" title=\"struct devela::_core::str::SplitAsciiWhitespace\">SplitAsciiWhitespace</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>;</div>","SplitInclusive<'_, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../../_core/str/struct.SplitInclusive.html\" title=\"struct devela::_core::str::SplitInclusive\">SplitInclusive</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../../_core/str/struct.SplitInclusive.html\" title=\"struct devela::_core::str::SplitInclusive\">SplitInclusive</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../../../_core/str/pattern/trait.Pattern.html\" title=\"trait devela::_core::str::pattern::Pattern\">Pattern</a>,</div></div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>;</div>","SplitN<'_, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../../_core/str/struct.SplitN.html\" title=\"struct devela::_core::str::SplitN\">SplitN</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../../_core/str/struct.SplitN.html\" title=\"struct devela::_core::str::SplitN\">SplitN</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../../../_core/str/pattern/trait.Pattern.html\" title=\"trait devela::_core::str::pattern::Pattern\">Pattern</a>,</div></div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>;</div>","SplitTerminator<'_, P>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../../_core/str/struct.SplitTerminator.html\" title=\"struct devela::_core::str::SplitTerminator\">SplitTerminator</a>&lt;'a, P&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a, P&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../../_core/str/struct.SplitTerminator.html\" title=\"struct devela::_core::str::SplitTerminator\">SplitTerminator</a>&lt;'a, P&gt;<div class=\"where\">where\n    P: <a class=\"trait\" href=\"../../../_core/str/pattern/trait.Pattern.html\" title=\"trait devela::_core::str::pattern::Pattern\">Pattern</a>,</div></div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>;</div>","SplitWhitespace<'_>":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../../_core/str/struct.SplitWhitespace.html\" title=\"struct devela::_core::str::SplitWhitespace\">SplitWhitespace</a>&lt;'a&gt;</code></h3><pre><code><div class=\"where\">impl&lt;'a&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"../../../_core/str/struct.SplitWhitespace.html\" title=\"struct devela::_core::str::SplitWhitespace\">SplitWhitespace</a>&lt;'a&gt;</div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &amp;'a <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a>;</div>","String":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../../all/struct.String.html\" title=\"struct devela::all::String\">String</a></code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"../../../all/trait.ExtString.html\" title=\"trait devela::all::ExtString\">ExtString</a> for <a class=\"struct\" href=\"../../../all/struct.String.html\" title=\"struct devela::all::String\">String</a></div>"}</script></section></div></main></body></html>