<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Utilities for improved cooperative scheduling."><title>devela::_dep::tokio::task::coop - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../../../" data-static-root-path="../../../../../static.files/" data-current-crate="devela" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-nightly (f2824da98 2025-08-28)" data-channel="nightly" data-search-js="search-03d23683.js" data-stringdex-js="stringdex-0e748618.js" data-settings-js="settings-c38705f0.js" ><script src="../../../../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../../../static.files/favicon-044be391.svg"><script>
  document.addEventListener("DOMContentLoaded", async function() {
    // Ensure this script runs only once per page load
    if (window.scriptLoaderInitialized) return;
    window.scriptLoaderInitialized = true;

    /* settings */

    const crateName = "devela";
    const allowedKatex = ["/all", "/media/color", "/num/", "/phys/"];
    const allowedKatexChem = ["/all/", "/phys/"];

    // Find the LAST occurrence of `/devela/` in the path
    const path = window.location.pathname;
    const lastCrateIndex = path.lastIndexOf(`/${crateName}/`);
    if (lastCrateIndex === -1) return;
    // Extract everything after the last `/devela/`
    const relativePath = path.slice(lastCrateIndex + crateName.length + 1);

    /* load resources */

    try {
      if (allowedKatex.some(prefix => relativePath.startsWith(prefix))) {
        await loadKatex().catch(handleMathError);
      }
      if (allowedKatexChem.some(prefix => relativePath.startsWith(prefix))) {
        await loadKatexChem().catch(handleMathError);
      }
    } catch (error) {
      handleMathError(error);
    }

    /* resource loading functions */

    // INFO: https://katex.org/docs/browser.html#starter-template
    // INFO: https://github.com/KaTeX/KaTeX/tree/main/contrib/copy-tex
    async function loadKatex() {
      console.log("Loading KaTeX for:", relativePath);

      // Load CSS, and scripts sequentially
      const katexCSS = document.createElement("link");
      katexCSS.rel = "stylesheet";
      katexCSS.href = "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css";
      katexCSS.integrity = "sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib";
      katexCSS.crossOrigin = "anonymous";
      document.head.appendChild(katexCSS);

      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js",
        integrity: "sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh"
      });
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js",
        integrity: "sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh"
      });
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/copy-tex.min.js",
        integrity: "sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi"
      });

      // Initialize KaTeX
      renderMathInElement(document.body, {
        delimiters: [
          {left: "$$", right: "$$", display: true},
          {left: "$", right: "$", display: false},
          {left: "\\(", right: "\\)", display: false},
          {left: "\\[", right: "\\]", display: true}
        ],
        trust: (context) => context.command === "\\href"
      });
      // Add custom styles: https://katex.org/docs/issues.html#css-customization
      const katexStyle = document.createElement("style");
      katexStyle.textContent = `
        .katex-display { overflow: hidden; }
        .docblock p { overflow-y: hidden; }
      `;
      document.head.appendChild(katexStyle);
    }

    // INFO: https://github.com/KaTeX/KaTeX/blob/main/contrib/mhchem/README.md
    async function loadKatexChem() {
      console.log("Loading KaTeX MhChem plugin for:", relativePath);
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/mhchem.min.js",
        integrity: "sha384-F2ptQFZqNJuqfGGl28mIXyQ5kXH48spn7rcoS0Y9psqIKAcZPLd1NzwFlm/bl1mH"
      });
    }

    /* helper functions */

    function loadScript(config) {
      return new Promise((resolve, reject) => {
        const script = document.createElement("script");
        script.src = config.src;
        if (config.integrity) {
          script.integrity = config.integrity;
          script.crossOrigin = "anonymous";
        }
        script.onload = resolve;
        script.onerror = () => reject(new Error(`Failed to load script: ${config.src}`));
        document.head.appendChild(script);
      });
    }
    function handleMathError(error) {
      console.error("Math rendering error:", error);
    }
  });
</script>

</head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module coop</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../../devela/index.html">devela</a><span class="version">0.25.0-wip</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module coop</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#cooperative-scheduling" title="Cooperative scheduling">Cooperative scheduling</a><ul><li><a href="#unconstrained" title="unconstrained">unconstrained</a></li></ul></li></ul><h3><a href="#structs">Module Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In devela::<wbr>_<wbr>dep::<wbr>tokio::<wbr>task</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../../../index.html">devela</a>::<wbr><a href="../../../index.html">_dep</a>::<wbr><a href="../../index.html">tokio</a>::<wbr><a href="../index.html">task</a></div><h1>Module <span>coop</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"></span></div><span class="item-info"><div class="stab portability">Available on <strong>crate features <code>dep_tokio</code> and <code>std</code></strong> only.</div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Utilities for improved cooperative scheduling.</p>
<h4 id="cooperative-scheduling"><a class="doc-anchor" href="#cooperative-scheduling">§</a>Cooperative scheduling</h4>
<p>A single call to <a href="../../../../all/trait.Future.html#tymethod.poll" title="method devela::all::Future::poll"><code>poll</code></a> on a top-level task may potentially do a lot of
work before it returns <code>Poll::Pending</code>. If a task runs for a long period of
time without yielding back to the executor, it can starve other tasks
waiting on that executor to execute them, or drive underlying resources.
Since Rust does not have a runtime, it is difficult to forcibly preempt a
long-running task. Instead, this module provides an opt-in mechanism for
futures to collaborate with the executor to avoid starvation.</p>
<p>Consider a future like this one:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">async fn </span>drop_all&lt;I: Stream + Unpin&gt;(<span class="kw-2">mut </span>input: I) {
    <span class="kw">while let </span><span class="prelude-val">Some</span>(<span class="kw">_</span>) = input.next().<span class="kw">await </span>{}
}</code></pre></div>
<p>It may look harmless, but consider what happens under heavy load if the
input stream is <em>always</em> ready. If we spawn <code>drop_all</code>, the task will never
yield, and will starve other tasks and resources on the same executor.</p>
<p>To account for this, Tokio has explicit yield points in a number of library
functions, which force tasks to return to the executor periodically.</p>
<h5 id="unconstrained"><a class="doc-anchor" href="#unconstrained">§</a>unconstrained</h5>
<p>If necessary, <a href="../fn.unconstrained.html" title="fn devela::_dep::tokio::task::unconstrained"><code>task::unconstrained</code></a> lets you opt a future out of Tokio’s cooperative
scheduling. When a future is wrapped with <code>unconstrained</code>, it will never be forced to yield to
Tokio. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tokio::{task, sync::mpsc};

<span class="kw">let </span>fut = <span class="kw">async </span>{
    <span class="kw">let </span>(tx, <span class="kw-2">mut </span>rx) = mpsc::unbounded_channel();

    <span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..<span class="number">1000 </span>{
        <span class="kw">let _ </span>= tx.send(());
        <span class="comment">// This will always be ready. If coop was in effect, this code would be forced to yield
        // periodically. However, if left unconstrained, then this code will never yield.
        </span>rx.recv().<span class="kw">await</span>;
    }
};

task::coop::unconstrained(fut).<span class="kw">await</span>;</code></pre></div>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Coop.html" title="struct devela::_dep::tokio::task::coop::Coop">Coop</a></dt><dd>Future wrapper to ensure cooperative scheduling created by <a href="fn.cooperative.html" title="fn devela::_dep::tokio::task::coop::cooperative"><code>cooperative</code></a>.</dd><dt><a class="struct" href="struct.RestoreOnPending.html" title="struct devela::_dep::tokio::task::coop::RestoreOnPending">Restore<wbr>OnPending</a></dt><dd>Value returned by the <a href="fn.poll_proceed.html" title="fn devela::_dep::tokio::task::coop::poll_proceed"><code>poll_proceed</code></a> method.</dd><dt><a class="struct" href="struct.Unconstrained.html" title="struct devela::_dep::tokio::task::coop::Unconstrained">Unconstrained</a></dt><dd>Future for the <a href="../fn.unconstrained.html" title="fn devela::_dep::tokio::task::unconstrained"><code>unconstrained</code></a> method.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.consume_budget.html" title="fn devela::_dep::tokio::task::coop::consume_budget">consume_<wbr>budget</a></dt><dd>Consumes a unit of budget and returns the execution back to the Tokio
runtime <em>if</em> the task’s coop budget was exhausted.</dd><dt><a class="fn" href="fn.cooperative.html" title="fn devela::_dep::tokio::task::coop::cooperative">cooperative</a></dt><dd>Creates a wrapper future that makes the inner future cooperate with the Tokio scheduler.</dd><dt><a class="fn" href="fn.has_budget_remaining.html" title="fn devela::_dep::tokio::task::coop::has_budget_remaining">has_<wbr>budget_<wbr>remaining</a></dt><dd>Returns <code>true</code> if there is still budget left on the task.</dd><dt><a class="fn" href="fn.poll_proceed.html" title="fn devela::_dep::tokio::task::coop::poll_proceed">poll_<wbr>proceed</a></dt><dd>Decrements the task budget and returns <a href="../../../../all/enum.TaskPoll.html#variant.Pending" title="variant devela::all::TaskPoll::Pending"><code>Poll::Pending</code></a> if the budget is depleted.
This indicates that the task should yield to the scheduler. Otherwise, returns
<a href="struct.RestoreOnPending.html" title="struct devela::_dep::tokio::task::coop::RestoreOnPending"><code>RestoreOnPending</code></a> which can be used to commit the budget consumption.</dd><dt><a class="fn" href="fn.unconstrained.html" title="fn devela::_dep::tokio::task::coop::unconstrained">unconstrained</a></dt><dd>Turn off cooperative scheduling for a future. The future will never be forced to yield by
Tokio. Using this exposes your service to starvation if the unconstrained future never yields
otherwise.</dd></dl></section></div></main></body></html>