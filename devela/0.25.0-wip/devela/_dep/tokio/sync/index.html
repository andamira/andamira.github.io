<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Synchronization primitives for use in asynchronous contexts."><title>devela::_dep::tokio::sync - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="devela" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-nightly (f2824da98 2025-08-28)" data-channel="nightly" data-search-js="search-03d23683.js" data-stringdex-js="stringdex-0e748618.js" data-settings-js="settings-c38705f0.js" ><script src="../../../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-044be391.svg"><script>
  document.addEventListener("DOMContentLoaded", async function() {
    // Ensure this script runs only once per page load
    if (window.scriptLoaderInitialized) return;
    window.scriptLoaderInitialized = true;

    /* settings */

    const crateName = "devela";
    const allowedKatex = ["/all", "/media/color", "/num/", "/phys/"];
    const allowedKatexChem = ["/all/", "/phys/"];

    // Find the LAST occurrence of `/devela/` in the path
    const path = window.location.pathname;
    const lastCrateIndex = path.lastIndexOf(`/${crateName}/`);
    if (lastCrateIndex === -1) return;
    // Extract everything after the last `/devela/`
    const relativePath = path.slice(lastCrateIndex + crateName.length + 1);

    /* load resources */

    try {
      if (allowedKatex.some(prefix => relativePath.startsWith(prefix))) {
        await loadKatex().catch(handleMathError);
      }
      if (allowedKatexChem.some(prefix => relativePath.startsWith(prefix))) {
        await loadKatexChem().catch(handleMathError);
      }
    } catch (error) {
      handleMathError(error);
    }

    /* resource loading functions */

    // INFO: https://katex.org/docs/browser.html#starter-template
    // INFO: https://github.com/KaTeX/KaTeX/tree/main/contrib/copy-tex
    async function loadKatex() {
      console.log("Loading KaTeX for:", relativePath);

      // Load CSS, and scripts sequentially
      const katexCSS = document.createElement("link");
      katexCSS.rel = "stylesheet";
      katexCSS.href = "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css";
      katexCSS.integrity = "sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib";
      katexCSS.crossOrigin = "anonymous";
      document.head.appendChild(katexCSS);

      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js",
        integrity: "sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh"
      });
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js",
        integrity: "sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh"
      });
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/copy-tex.min.js",
        integrity: "sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi"
      });

      // Initialize KaTeX
      renderMathInElement(document.body, {
        delimiters: [
          {left: "$$", right: "$$", display: true},
          {left: "$", right: "$", display: false},
          {left: "\\(", right: "\\)", display: false},
          {left: "\\[", right: "\\]", display: true}
        ],
        trust: (context) => context.command === "\\href"
      });
      // Add custom styles: https://katex.org/docs/issues.html#css-customization
      const katexStyle = document.createElement("style");
      katexStyle.textContent = `
        .katex-display { overflow: hidden; }
        .docblock p { overflow-y: hidden; }
      `;
      document.head.appendChild(katexStyle);
    }

    // INFO: https://github.com/KaTeX/KaTeX/blob/main/contrib/mhchem/README.md
    async function loadKatexChem() {
      console.log("Loading KaTeX MhChem plugin for:", relativePath);
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/mhchem.min.js",
        integrity: "sha384-F2ptQFZqNJuqfGGl28mIXyQ5kXH48spn7rcoS0Y9psqIKAcZPLd1NzwFlm/bl1mH"
      });
    }

    /* helper functions */

    function loadScript(config) {
      return new Promise((resolve, reject) => {
        const script = document.createElement("script");
        script.src = config.src;
        if (config.integrity) {
          script.integrity = config.integrity;
          script.crossOrigin = "anonymous";
        }
        script.onload = resolve;
        script.onerror = () => reject(new Error(`Failed to load script: ${config.src}`));
        document.head.appendChild(script);
      });
    }
    function handleMathError(error) {
      console.error("Math rendering error:", error);
    }
  });
</script>

</head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module sync</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../devela/index.html">devela</a><span class="version">0.25.0-wip</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module sync</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#message-passing" title="Message passing">Message passing</a><ul><li><a href="#oneshot-channel" title="`oneshot` channel"><code>oneshot</code> channel</a></li><li><a href="#mpsc-channel" title="`mpsc` channel"><code>mpsc</code> channel</a></li><li><a href="#broadcast-channel" title="`broadcast` channel"><code>broadcast</code> channel</a></li><li><a href="#watch-channel" title="`watch` channel"><code>watch</code> channel</a></li></ul></li><li><a href="#state-synchronization" title="State synchronization">State synchronization</a></li><li><a href="#runtime-compatibility" title="Runtime compatibility">Runtime compatibility</a></li></ul><h3><a href="#modules">Module Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In devela::<wbr>_<wbr>dep::<wbr>tokio</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../../index.html">devela</a>::<wbr><a href="../../index.html">_dep</a>::<wbr><a href="../index.html">tokio</a></div><h1>Module <span>sync</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"></span></div><span class="item-info"><div class="stab portability">Available on <strong>crate features <code>dep_tokio</code> and <code>std</code></strong> only.</div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Synchronization primitives for use in asynchronous contexts.</p>
<p>Tokio programs tend to be organized as a set of <a href="../task/index.html" title="mod devela::_dep::tokio::task">tasks</a> where each task
operates independently and may be executed on separate physical threads. The
synchronization primitives provided in this module permit these independent
tasks to communicate together.</p>
<h2 id="message-passing"><a class="doc-anchor" href="#message-passing">ยง</a>Message passing</h2>
<p>The most common form of synchronization in a Tokio program is message
passing. Two tasks operate independently and send messages to each other to
synchronize. Doing so has the advantage of avoiding shared state.</p>
<p>Message passing is implemented using channels. A channel supports sending a
message from one producer task to one or more consumer tasks. There are a
few flavors of channels provided by Tokio. Each channel flavor supports
different message passing patterns. When a channel supports multiple
producers, many separate tasks may <strong>send</strong> messages. When a channel
supports multiple consumers, many different separate tasks may <strong>receive</strong>
messages.</p>
<p>Tokio provides many different channel flavors as different message passing
patterns are best handled with different implementations.</p>
<h3 id="oneshot-channel"><a class="doc-anchor" href="#oneshot-channel">ยง</a><code>oneshot</code> channel</h3>
<p>The <a href="oneshot/index.html" title="mod devela::_dep::tokio::sync::oneshot"><code>oneshot</code> channel</a> supports sending a <strong>single</strong> value from a
single producer to a single consumer. This channel is usually used to send
the result of a computation to a waiter.</p>
<p><strong>Example:</strong> using a <a href="oneshot/index.html" title="mod devela::_dep::tokio::sync::oneshot"><code>oneshot</code> channel</a> to receive the result of a
computation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tokio::sync::oneshot;

<span class="kw">async fn </span>some_computation() -&gt; String {
    <span class="string">"represents the result of the computation"</span>.to_string()
}

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
    <span class="kw">let </span>(tx, rx) = oneshot::channel();

    tokio::spawn(<span class="kw">async move </span>{
        <span class="kw">let </span>res = some_computation().<span class="kw">await</span>;
        tx.send(res).unwrap();
    });

    <span class="comment">// Do other work while the computation is happening in the background

    // Wait for the computation result
    </span><span class="kw">let </span>res = rx.<span class="kw">await</span>.unwrap();
}</code></pre></div>
<p>Note, if the task produces a computation result as its final
action before terminating, the <a href="../task/struct.JoinHandle.html" title="struct devela::_dep::tokio::task::JoinHandle"><code>JoinHandle</code></a> can be used to
receive that value instead of allocating resources for the
<code>oneshot</code> channel. Awaiting on <a href="../task/struct.JoinHandle.html" title="struct devela::_dep::tokio::task::JoinHandle"><code>JoinHandle</code></a> returns <code>Result</code>. If
the task panics, the <code>Joinhandle</code> yields <code>Err</code> with the panic
cause.</p>
<p><strong>Example:</strong></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">async fn </span>some_computation() -&gt; String {
    <span class="string">"the result of the computation"</span>.to_string()
}

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
    <span class="kw">let </span>join_handle = tokio::spawn(<span class="kw">async move </span>{
        some_computation().<span class="kw">await
    </span>});

    <span class="comment">// Do other work while the computation is happening in the background

    // Wait for the computation result
    </span><span class="kw">let </span>res = join_handle.<span class="kw">await</span>.unwrap();
}</code></pre></div>
<h3 id="mpsc-channel"><a class="doc-anchor" href="#mpsc-channel">ยง</a><code>mpsc</code> channel</h3>
<p>The <a href="mpsc/index.html" title="mod devela::_dep::tokio::sync::mpsc"><code>mpsc</code> channel</a> supports sending <strong>many</strong> values from <strong>many</strong>
producers to a single consumer. This channel is often used to send work to a
task or to receive the result of many computations.</p>
<p>This is also the channel you should use if you want to send many messages
from a single producer to a single consumer. There is no dedicated spsc
channel.</p>
<p><strong>Example:</strong> using an mpsc to incrementally stream the results of a series
of computations.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tokio::sync::mpsc;

<span class="kw">async fn </span>some_computation(input: u32) -&gt; String {
    <span class="macro">format!</span>(<span class="string">"the result of computation {}"</span>, input)
}

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
    <span class="kw">let </span>(tx, <span class="kw-2">mut </span>rx) = mpsc::channel(<span class="number">100</span>);

    tokio::spawn(<span class="kw">async move </span>{
        <span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..<span class="number">10 </span>{
            <span class="kw">let </span>res = some_computation(i).<span class="kw">await</span>;
            tx.send(res).<span class="kw">await</span>.unwrap();
        }
    });

    <span class="kw">while let </span><span class="prelude-val">Some</span>(res) = rx.recv().<span class="kw">await </span>{
        <span class="macro">println!</span>(<span class="string">"got = {}"</span>, res);
    }
}</code></pre></div>
<p>The argument to <code>mpsc::channel</code> is the channel capacity. This is the maximum
number of values that can be stored in the channel pending receipt at any
given time. Properly setting this value is key in implementing robust
programs as the channel capacity plays a critical part in handling back
pressure.</p>
<p>A common concurrency pattern for resource management is to spawn a task
dedicated to managing that resource and using message passing between other
tasks to interact with the resource. The resource may be anything that may
not be concurrently used. Some examples include a socket and program state.
For example, if multiple tasks need to send data over a single socket, spawn
a task to manage the socket and use a channel to synchronize.</p>
<p><strong>Example:</strong> sending data from many tasks over a single socket using message
passing.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tokio::io::{<span class="self">self</span>, AsyncWriteExt};
<span class="kw">use </span>tokio::net::TcpStream;
<span class="kw">use </span>tokio::sync::mpsc;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() -&gt; io::Result&lt;()&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>socket = TcpStream::connect(<span class="string">"www.example.com:1234"</span>).<span class="kw">await</span><span class="question-mark">?</span>;
    <span class="kw">let </span>(tx, <span class="kw-2">mut </span>rx) = mpsc::channel(<span class="number">100</span>);

    <span class="kw">for _ in </span><span class="number">0</span>..<span class="number">10 </span>{
        <span class="comment">// Each task needs its own `tx` handle. This is done by cloning the
        // original handle.
        </span><span class="kw">let </span>tx = tx.clone();

        tokio::spawn(<span class="kw">async move </span>{
            tx.send(<span class="kw-2">&amp;</span><span class="string">b"data to write"</span>[..]).<span class="kw">await</span>.unwrap();
        });
    }

    <span class="comment">// The `rx` half of the channel returns `None` once **all** `tx` clones
    // drop. To ensure `None` is returned, drop the handle owned by the
    // current task. If this `tx` handle is not dropped, there will always
    // be a single outstanding `tx` handle.
    </span>drop(tx);

    <span class="kw">while let </span><span class="prelude-val">Some</span>(res) = rx.recv().<span class="kw">await </span>{
        socket.write_all(res).<span class="kw">await</span><span class="question-mark">?</span>;
    }

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>The <a href="mpsc/index.html" title="mod devela::_dep::tokio::sync::mpsc"><code>mpsc</code></a> and <a href="oneshot/index.html" title="mod devela::_dep::tokio::sync::oneshot"><code>oneshot</code></a> channels can be combined to provide a request /
response type synchronization pattern with a shared resource. A task is
spawned to synchronize a resource and waits on commands received on a
<a href="mpsc/index.html" title="mod devela::_dep::tokio::sync::mpsc"><code>mpsc</code></a> channel. Each command includes a <a href="oneshot/index.html" title="mod devela::_dep::tokio::sync::oneshot"><code>oneshot</code></a> <code>Sender</code> on which the
result of the command is sent.</p>
<p><strong>Example:</strong> use a task to synchronize a <code>u64</code> counter. Each task sends an
โfetch and incrementโ command. The counter value <strong>before</strong> the increment is
sent over the provided <code>oneshot</code> channel.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tokio::sync::{oneshot, mpsc};
<span class="kw">use </span>Command::Increment;

<span class="kw">enum </span>Command {
    Increment,
    <span class="comment">// Other commands can be added here
</span>}

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
    <span class="kw">let </span>(cmd_tx, <span class="kw-2">mut </span>cmd_rx) = mpsc::channel::&lt;(Command, oneshot::Sender&lt;u64&gt;)&gt;(<span class="number">100</span>);

    <span class="comment">// Spawn a task to manage the counter
    </span>tokio::spawn(<span class="kw">async move </span>{
        <span class="kw">let </span><span class="kw-2">mut </span>counter: u64 = <span class="number">0</span>;

        <span class="kw">while let </span><span class="prelude-val">Some</span>((cmd, response)) = cmd_rx.recv().<span class="kw">await </span>{
            <span class="kw">match </span>cmd {
                Increment =&gt; {
                    <span class="kw">let </span>prev = counter;
                    counter += <span class="number">1</span>;
                    response.send(prev).unwrap();
                }
            }
        }
    });

    <span class="kw">let </span><span class="kw-2">mut </span>join_handles = <span class="macro">vec!</span>[];

    <span class="comment">// Spawn tasks that will send the increment command.
    </span><span class="kw">for _ in </span><span class="number">0</span>..<span class="number">10 </span>{
        <span class="kw">let </span>cmd_tx = cmd_tx.clone();

        join_handles.push(tokio::spawn(<span class="kw">async move </span>{
            <span class="kw">let </span>(resp_tx, resp_rx) = oneshot::channel();

            cmd_tx.send((Increment, resp_tx)).<span class="kw">await</span>.ok().unwrap();
            <span class="kw">let </span>res = resp_rx.<span class="kw">await</span>.unwrap();

            <span class="macro">println!</span>(<span class="string">"previous value = {}"</span>, res);
        }));
    }

    <span class="comment">// Wait for all tasks to complete
    </span><span class="kw">for </span>join_handle <span class="kw">in </span>join_handles.drain(..) {
        join_handle.<span class="kw">await</span>.unwrap();
    }
}</code></pre></div>
<h3 id="broadcast-channel"><a class="doc-anchor" href="#broadcast-channel">ยง</a><code>broadcast</code> channel</h3>
<p>The <a href="broadcast/index.html" title="mod devela::_dep::tokio::sync::broadcast"><code>broadcast</code> channel</a> supports sending <strong>many</strong> values from
<strong>many</strong> producers to <strong>many</strong> consumers. Each consumer will receive
<strong>each</strong> value. This channel can be used to implement โfan outโ style
patterns common with pub / sub or โchatโ systems.</p>
<p>This channel tends to be used less often than <code>oneshot</code> and <code>mpsc</code> but still
has its use cases.</p>
<p>This is also the channel you should use if you want to broadcast values from
a single producer to many consumers. There is no dedicated spmc broadcast
channel.</p>
<p>Basic usage</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tokio::sync::broadcast;

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
    <span class="kw">let </span>(tx, <span class="kw-2">mut </span>rx1) = broadcast::channel(<span class="number">16</span>);
    <span class="kw">let </span><span class="kw-2">mut </span>rx2 = tx.subscribe();

    tokio::spawn(<span class="kw">async move </span>{
        <span class="macro">assert_eq!</span>(rx1.recv().<span class="kw">await</span>.unwrap(), <span class="number">10</span>);
        <span class="macro">assert_eq!</span>(rx1.recv().<span class="kw">await</span>.unwrap(), <span class="number">20</span>);
    });

    tokio::spawn(<span class="kw">async move </span>{
        <span class="macro">assert_eq!</span>(rx2.recv().<span class="kw">await</span>.unwrap(), <span class="number">10</span>);
        <span class="macro">assert_eq!</span>(rx2.recv().<span class="kw">await</span>.unwrap(), <span class="number">20</span>);
    });

    tx.send(<span class="number">10</span>).unwrap();
    tx.send(<span class="number">20</span>).unwrap();
}</code></pre></div>
<h3 id="watch-channel"><a class="doc-anchor" href="#watch-channel">ยง</a><code>watch</code> channel</h3>
<p>The <a href="watch/index.html" title="mod devela::_dep::tokio::sync::watch"><code>watch</code> channel</a> supports sending <strong>many</strong> values from a <strong>many</strong>
producer to <strong>many</strong> consumers. However, only the <strong>most recent</strong> value is
stored in the channel. Consumers are notified when a new value is sent, but
there is no guarantee that consumers will see <strong>all</strong> values.</p>
<p>The <a href="watch/index.html" title="mod devela::_dep::tokio::sync::watch"><code>watch</code> channel</a> is similar to a <a href="broadcast/index.html" title="mod devela::_dep::tokio::sync::broadcast"><code>broadcast</code> channel</a> with capacity 1.</p>
<p>Use cases for the <a href="watch/index.html" title="mod devela::_dep::tokio::sync::watch"><code>watch</code> channel</a> include broadcasting configuration
changes or signalling program state changes, such as transitioning to
shutdown.</p>
<p><strong>Example:</strong> use a <a href="watch/index.html" title="mod devela::_dep::tokio::sync::watch"><code>watch</code> channel</a> to notify tasks of configuration
changes. In this example, a configuration file is checked periodically. When
the file changes, the configuration changes are signalled to consumers.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tokio::sync::watch;
<span class="kw">use </span>tokio::time::{<span class="self">self</span>, Duration, Instant};

<span class="kw">use </span>std::io;

<span class="attr">#[derive(Debug, Clone, Eq, PartialEq)]
</span><span class="kw">struct </span>Config {
    timeout: Duration,
}

<span class="kw">impl </span>Config {
    <span class="kw">async fn </span>load_from_file() -&gt; io::Result&lt;Config&gt; {
        <span class="comment">// file loading and deserialization logic here
    </span>}
}

<span class="kw">async fn </span>my_async_operation() {
    <span class="comment">// Do something here
</span>}

<span class="attr">#[tokio::main]
</span><span class="kw">async fn </span>main() {
    <span class="comment">// Load initial configuration value
    </span><span class="kw">let </span><span class="kw-2">mut </span>config = Config::load_from_file().<span class="kw">await</span>.unwrap();

    <span class="comment">// Create the watch channel, initialized with the loaded configuration
    </span><span class="kw">let </span>(tx, rx) = watch::channel(config.clone());

    <span class="comment">// Spawn a task to monitor the file.
    </span>tokio::spawn(<span class="kw">async move </span>{
        <span class="kw">loop </span>{
            <span class="comment">// Wait 10 seconds between checks
            </span>time::sleep(Duration::from_secs(<span class="number">10</span>)).<span class="kw">await</span>;

            <span class="comment">// Load the configuration file
            </span><span class="kw">let </span>new_config = Config::load_from_file().<span class="kw">await</span>.unwrap();

            <span class="comment">// If the configuration changed, send the new config value
            // on the watch channel.
            </span><span class="kw">if </span>new_config != config {
                tx.send(new_config.clone()).unwrap();
                config = new_config;
            }
        }
    });

    <span class="kw">let </span><span class="kw-2">mut </span>handles = <span class="macro">vec!</span>[];

    <span class="comment">// Spawn tasks that runs the async operation for at most `timeout`. If
    // the timeout elapses, restart the operation.
    //
    // The task simultaneously watches the `Config` for changes. When the
    // timeout duration changes, the timeout is updated without restarting
    // the in-flight operation.
    </span><span class="kw">for _ in </span><span class="number">0</span>..<span class="number">5 </span>{
        <span class="comment">// Clone a config watch handle for use in this task
        </span><span class="kw">let </span><span class="kw-2">mut </span>rx = rx.clone();

        <span class="kw">let </span>handle = tokio::spawn(<span class="kw">async move </span>{
            <span class="comment">// Start the initial operation and pin the future to the stack.
            // Pinning to the stack is required to resume the operation
            // across multiple calls to `select!`
            </span><span class="kw">let </span>op = my_async_operation();
            <span class="macro">tokio::pin!</span>(op);

            <span class="comment">// Get the initial config value
            </span><span class="kw">let </span><span class="kw-2">mut </span>conf = rx.borrow().clone();

            <span class="kw">let </span><span class="kw-2">mut </span>op_start = Instant::now();
            <span class="kw">let </span>sleep = time::sleep_until(op_start + conf.timeout);
            <span class="macro">tokio::pin!</span>(sleep);

            <span class="kw">loop </span>{
                <span class="macro">tokio::select!</span> {
                    <span class="kw">_ </span>= <span class="kw-2">&amp;mut </span>sleep =&gt; {
                        <span class="comment">// The operation elapsed. Restart it
                        </span>op.set(my_async_operation());

                        <span class="comment">// Track the new start time
                        </span>op_start = Instant::now();

                        <span class="comment">// Restart the timeout
                        </span>sleep.set(time::sleep_until(op_start + conf.timeout));
                    }
                    <span class="kw">_ </span>= rx.changed() =&gt; {
                        conf = rx.borrow_and_update().clone();

                        <span class="comment">// The configuration has been updated. Update the
                        // `sleep` using the new `timeout` value.
                        </span>sleep.as_mut().reset(op_start + conf.timeout);
                    }
                    <span class="kw">_ </span>= <span class="kw-2">&amp;mut </span>op =&gt; {
                        <span class="comment">// The operation completed!
                        </span><span class="kw">return
                    </span>}
                }
            }
        });

        handles.push(handle);
    }

    <span class="kw">for </span>handle <span class="kw">in </span>handles.drain(..) {
        handle.<span class="kw">await</span>.unwrap();
    }
}</code></pre></div>
<h2 id="state-synchronization"><a class="doc-anchor" href="#state-synchronization">ยง</a>State synchronization</h2>
<p>The remaining synchronization primitives focus on synchronizing state.
These are asynchronous equivalents to versions provided by <code>std</code>. They
operate in a similar way as their <code>std</code> counterparts but will wait
asynchronously instead of blocking the thread.</p>
<ul>
<li>
<p><a href="struct.Barrier.html" title="struct devela::_dep::tokio::sync::Barrier"><code>Barrier</code></a> Ensures multiple tasks will wait for each other to reach a
point in the program, before continuing execution all together.</p>
</li>
<li>
<p><a href="struct.Mutex.html" title="struct devela::_dep::tokio::sync::Mutex"><code>Mutex</code></a> Mutual Exclusion mechanism, which ensures that at most one
thread at a time is able to access some data.</p>
</li>
<li>
<p><a href="struct.Notify.html" title="struct devela::_dep::tokio::sync::Notify"><code>Notify</code></a> Basic task notification. <code>Notify</code> supports notifying a
receiving task without sending data. In this case, the task wakes up and
resumes processing.</p>
</li>
<li>
<p><a href="struct.RwLock.html" title="struct devela::_dep::tokio::sync::RwLock"><code>RwLock</code></a> Provides a mutual exclusion mechanism which allows multiple
readers at the same time, while allowing only one writer at a time. In
some cases, this can be more efficient than a mutex.</p>
</li>
<li>
<p><a href="struct.Semaphore.html" title="struct devela::_dep::tokio::sync::Semaphore"><code>Semaphore</code></a> Limits the amount of concurrency. A semaphore holds a
number of permits, which tasks may request in order to enter a critical
section. Semaphores are useful for implementing limiting or bounding of
any kind.</p>
</li>
</ul>
<h2 id="runtime-compatibility"><a class="doc-anchor" href="#runtime-compatibility">ยง</a>Runtime compatibility</h2>
<p>All synchronization primitives provided in this module are runtime agnostic.
You can freely move them between different instances of the Tokio runtime
or even use them from non-Tokio runtimes.</p>
<p>When used in a Tokio runtime, the synchronization primitives participate in
<a href="../task/coop/index.html#cooperative-scheduling" title="mod devela::_dep::tokio::task::coop">cooperative scheduling</a> to avoid
starvation. This feature does not apply when used from non-Tokio runtimes.</p>
<p>As an exception, methods ending in <code>_timeout</code> are not runtime agnostic
because they require access to the Tokio timer. See the documentation of
each <code>*_timeout</code> method for more information on its use.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="mod" href="broadcast/index.html" title="mod devela::_dep::tokio::sync::broadcast">broadcast</a></dt><dd>A multi-producer, multi-consumer broadcast queue. Each sent value is seen by
all consumers.</dd><dt><a class="mod" href="futures/index.html" title="mod devela::_dep::tokio::sync::futures">futures</a></dt><dd>Named future types.</dd><dt><a class="mod" href="mpsc/index.html" title="mod devela::_dep::tokio::sync::mpsc">mpsc</a></dt><dd>A multi-producer, single-consumer queue for sending values between
asynchronous tasks.</dd><dt><a class="mod" href="oneshot/index.html" title="mod devela::_dep::tokio::sync::oneshot">oneshot</a></dt><dd>A one-shot channel is used for sending a single message between
asynchronous tasks. The <a href="oneshot/fn.channel.html" title="fn devela::_dep::tokio::sync::oneshot::channel"><code>channel</code></a> function is used to create a
<a href="oneshot/struct.Sender.html" title="struct devela::_dep::tokio::sync::oneshot::Sender"><code>Sender</code></a> and <a href="oneshot/struct.Receiver.html" title="struct devela::_dep::tokio::sync::oneshot::Receiver"><code>Receiver</code></a> handle pair that form the channel.</dd><dt><a class="mod" href="watch/index.html" title="mod devela::_dep::tokio::sync::watch">watch</a></dt><dd>A multi-producer, multi-consumer channel that only retains the <em>last</em> sent
value.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="struct" href="struct.AcquireError.html" title="struct devela::_dep::tokio::sync::AcquireError">Acquire<wbr>Error</a></dt><dd>Error returned from the <a href="struct.Semaphore.html#method.acquire" title="method devela::_dep::tokio::sync::Semaphore::acquire"><code>Semaphore::acquire</code></a> function.</dd><dt><a class="struct" href="struct.Barrier.html" title="struct devela::_dep::tokio::sync::Barrier">Barrier</a></dt><dd>A barrier enables multiple tasks to synchronize the beginning of some computation.</dd><dt><a class="struct" href="struct.BarrierWaitResult.html" title="struct devela::_dep::tokio::sync::BarrierWaitResult">Barrier<wbr>Wait<wbr>Result</a></dt><dd>A <code>BarrierWaitResult</code> is returned by <code>wait</code> when all tasks in the <code>Barrier</code> have rendezvoused.</dd><dt><a class="struct" href="struct.MappedMutexGuard.html" title="struct devela::_dep::tokio::sync::MappedMutexGuard">Mapped<wbr>Mutex<wbr>Guard</a></dt><dd>A handle to a held <code>Mutex</code> that has had a function applied to it via <a href="struct.MutexGuard.html#method.map" title="associated function devela::_dep::tokio::sync::MutexGuard::map"><code>MutexGuard::map</code></a>.</dd><dt><a class="struct" href="struct.Mutex.html" title="struct devela::_dep::tokio::sync::Mutex">Mutex</a></dt><dd>An asynchronous <code>Mutex</code>-like type.</dd><dt><a class="struct" href="struct.MutexGuard.html" title="struct devela::_dep::tokio::sync::MutexGuard">Mutex<wbr>Guard</a></dt><dd>A handle to a held <code>Mutex</code>. The guard can be held across any <code>.await</code> point
as it is <a href="../../../all/trait.Send.html" title="trait devela::all::Send"><code>Send</code></a>.</dd><dt><a class="struct" href="struct.Notify.html" title="struct devela::_dep::tokio::sync::Notify">Notify</a></dt><dd>Notifies a single task to wake up.</dd><dt><a class="struct" href="struct.OnceCell.html" title="struct devela::_dep::tokio::sync::OnceCell">Once<wbr>Cell</a></dt><dd>A thread-safe cell that can be written to only once.</dd><dt><a class="struct" href="struct.OwnedMappedMutexGuard.html" title="struct devela::_dep::tokio::sync::OwnedMappedMutexGuard">Owned<wbr>Mapped<wbr>Mutex<wbr>Guard</a></dt><dd>A owned handle to a held <code>Mutex</code> that has had a function applied to it via
<a href="struct.OwnedMutexGuard.html#method.map" title="associated function devela::_dep::tokio::sync::OwnedMutexGuard::map"><code>OwnedMutexGuard::map</code></a>.</dd><dt><a class="struct" href="struct.OwnedMutexGuard.html" title="struct devela::_dep::tokio::sync::OwnedMutexGuard">Owned<wbr>Mutex<wbr>Guard</a></dt><dd>An owned handle to a held <code>Mutex</code>.</dd><dt><a class="struct" href="struct.OwnedRwLockMappedWriteGuard.html" title="struct devela::_dep::tokio::sync::OwnedRwLockMappedWriteGuard">Owned<wbr>RwLock<wbr>Mapped<wbr>Write<wbr>Guard</a></dt><dd>Owned RAII structure used to release the exclusive write access of a lock when
dropped.</dd><dt><a class="struct" href="struct.OwnedRwLockReadGuard.html" title="struct devela::_dep::tokio::sync::OwnedRwLockReadGuard">Owned<wbr>RwLock<wbr>Read<wbr>Guard</a></dt><dd>Owned RAII structure used to release the shared read access of a lock when
dropped.</dd><dt><a class="struct" href="struct.OwnedRwLockWriteGuard.html" title="struct devela::_dep::tokio::sync::OwnedRwLockWriteGuard">Owned<wbr>RwLock<wbr>Write<wbr>Guard</a></dt><dd>Owned RAII structure used to release the exclusive write access of a lock when
dropped.</dd><dt><a class="struct" href="struct.OwnedSemaphorePermit.html" title="struct devela::_dep::tokio::sync::OwnedSemaphorePermit">Owned<wbr>Semaphore<wbr>Permit</a></dt><dd>An owned permit from the semaphore.</dd><dt><a class="struct" href="struct.RwLock.html" title="struct devela::_dep::tokio::sync::RwLock">RwLock</a></dt><dd>An asynchronous reader-writer lock.</dd><dt><a class="struct" href="struct.RwLockMappedWriteGuard.html" title="struct devela::_dep::tokio::sync::RwLockMappedWriteGuard">RwLock<wbr>Mapped<wbr>Write<wbr>Guard</a></dt><dd>RAII structure used to release the exclusive write access of a lock when
dropped.</dd><dt><a class="struct" href="struct.RwLockReadGuard.html" title="struct devela::_dep::tokio::sync::RwLockReadGuard">RwLock<wbr>Read<wbr>Guard</a></dt><dd>RAII structure used to release the shared read access of a lock when
dropped.</dd><dt><a class="struct" href="struct.RwLockWriteGuard.html" title="struct devela::_dep::tokio::sync::RwLockWriteGuard">RwLock<wbr>Write<wbr>Guard</a></dt><dd>RAII structure used to release the exclusive write access of a lock when
dropped.</dd><dt><a class="struct" href="struct.Semaphore.html" title="struct devela::_dep::tokio::sync::Semaphore">Semaphore</a></dt><dd>Counting semaphore performing asynchronous permit acquisition.</dd><dt><a class="struct" href="struct.SemaphorePermit.html" title="struct devela::_dep::tokio::sync::SemaphorePermit">Semaphore<wbr>Permit</a></dt><dd>A permit from the semaphore.</dd><dt><a class="struct" href="struct.SetOnce.html" title="struct devela::_dep::tokio::sync::SetOnce">SetOnce</a></dt><dd>A thread-safe cell that can be written to only once.</dd><dt><a class="struct" href="struct.SetOnceError.html" title="struct devela::_dep::tokio::sync::SetOnceError">SetOnce<wbr>Error</a></dt><dd>Error that can be returned from <a href="struct.SetOnce.html#method.set" title="method devela::_dep::tokio::sync::SetOnce::set"><code>SetOnce::set</code></a>.</dd><dt><a class="struct" href="struct.TryLockError.html" title="struct devela::_dep::tokio::sync::TryLockError">TryLock<wbr>Error</a></dt><dd>Error returned from the <a href="struct.Mutex.html#method.try_lock" title="method devela::_dep::tokio::sync::Mutex::try_lock"><code>Mutex::try_lock</code></a>, <a href="struct.RwLock.html#method.try_read" title="method devela::_dep::tokio::sync::RwLock::try_read"><code>RwLock::try_read</code></a> and
<a href="struct.RwLock.html#method.try_write" title="method devela::_dep::tokio::sync::RwLock::try_write"><code>RwLock::try_write</code></a> functions.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">ยง</a></h2><dl class="item-table"><dt><a class="enum" href="enum.SetError.html" title="enum devela::_dep::tokio::sync::SetError">SetError</a></dt><dd>Errors that can be returned from <a href="struct.OnceCell.html#method.set" title="method devela::_dep::tokio::sync::OnceCell::set"><code>OnceCell::set</code></a>.</dd><dt><a class="enum" href="enum.TryAcquireError.html" title="enum devela::_dep::tokio::sync::TryAcquireError">TryAcquire<wbr>Error</a></dt><dd>Error returned from the <a href="struct.Semaphore.html#method.try_acquire" title="method devela::_dep::tokio::sync::Semaphore::try_acquire"><code>Semaphore::try_acquire</code></a> function.</dd></dl></section></div></main></body></html>