<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A representation of civil “wall clock” time."><title>Time in devela::_dep::jiff::civil - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="devela" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-nightly (f2824da98 2025-08-28)" data-channel="nightly" data-search-js="search-03d23683.js" data-stringdex-js="stringdex-0e748618.js" data-settings-js="settings-c38705f0.js" ><script src="../../../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-044be391.svg"><script>
  document.addEventListener("DOMContentLoaded", async function() {
    // Ensure this script runs only once per page load
    if (window.scriptLoaderInitialized) return;
    window.scriptLoaderInitialized = true;

    /* settings */

    const crateName = "devela";
    const allowedKatex = ["/all", "/media/color", "/num/", "/phys/"];
    const allowedKatexChem = ["/all/", "/phys/"];

    // Find the LAST occurrence of `/devela/` in the path
    const path = window.location.pathname;
    const lastCrateIndex = path.lastIndexOf(`/${crateName}/`);
    if (lastCrateIndex === -1) return;
    // Extract everything after the last `/devela/`
    const relativePath = path.slice(lastCrateIndex + crateName.length + 1);

    /* load resources */

    try {
      if (allowedKatex.some(prefix => relativePath.startsWith(prefix))) {
        await loadKatex().catch(handleMathError);
      }
      if (allowedKatexChem.some(prefix => relativePath.startsWith(prefix))) {
        await loadKatexChem().catch(handleMathError);
      }
    } catch (error) {
      handleMathError(error);
    }

    /* resource loading functions */

    // INFO: https://katex.org/docs/browser.html#starter-template
    // INFO: https://github.com/KaTeX/KaTeX/tree/main/contrib/copy-tex
    async function loadKatex() {
      console.log("Loading KaTeX for:", relativePath);

      // Load CSS, and scripts sequentially
      const katexCSS = document.createElement("link");
      katexCSS.rel = "stylesheet";
      katexCSS.href = "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css";
      katexCSS.integrity = "sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib";
      katexCSS.crossOrigin = "anonymous";
      document.head.appendChild(katexCSS);

      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js",
        integrity: "sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh"
      });
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js",
        integrity: "sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh"
      });
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/copy-tex.min.js",
        integrity: "sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi"
      });

      // Initialize KaTeX
      renderMathInElement(document.body, {
        delimiters: [
          {left: "$$", right: "$$", display: true},
          {left: "$", right: "$", display: false},
          {left: "\\(", right: "\\)", display: false},
          {left: "\\[", right: "\\]", display: true}
        ],
        trust: (context) => context.command === "\\href"
      });
      // Add custom styles: https://katex.org/docs/issues.html#css-customization
      const katexStyle = document.createElement("style");
      katexStyle.textContent = `
        .katex-display { overflow: hidden; }
        .docblock p { overflow-y: hidden; }
      `;
      document.head.appendChild(katexStyle);
    }

    // INFO: https://github.com/KaTeX/KaTeX/blob/main/contrib/mhchem/README.md
    async function loadKatexChem() {
      console.log("Loading KaTeX MhChem plugin for:", relativePath);
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/mhchem.min.js",
        integrity: "sha384-F2ptQFZqNJuqfGGl28mIXyQ5kXH48spn7rcoS0Y9psqIKAcZPLd1NzwFlm/bl1mH"
      });
    }

    /* helper functions */

    function loadScript(config) {
      return new Promise((resolve, reject) => {
        const script = document.createElement("script");
        script.src = config.src;
        if (config.integrity) {
          script.integrity = config.integrity;
          script.crossOrigin = "anonymous";
        }
        script.onload = resolve;
        script.onerror = () => reject(new Error(`Failed to load script: ${config.src}`));
        document.head.appendChild(script);
      });
    }
    function handleMathError(error) {
      console.error("Math rendering error:", error);
    }
  });
</script>

</head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Time</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../devela/index.html">devela</a><span class="version">0.25.0-wip</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Time</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#civil-time" title="Civil time">Civil time</a></li><li><a href="#parsing-and-printing" title="Parsing and printing">Parsing and printing</a></li><li><a href="#default-value" title="Default value">Default value</a></li><li><a href="#leap-seconds" title="Leap seconds">Leap seconds</a></li><li><a href="#comparisons" title="Comparisons">Comparisons</a></li><li><a href="#arithmetic" title="Arithmetic">Arithmetic</a></li><li><a href="#rounding" title="Rounding">Rounding</a></li></ul><h3><a href="#implementations">Associated Constants</a></h3><ul class="block associatedconstant"><li><a href="#associatedconstant.MAX" title="MAX">MAX</a></li><li><a href="#associatedconstant.MIN" title="MIN">MIN</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.checked_add" title="checked_add">checked_add</a></li><li><a href="#method.checked_sub" title="checked_sub">checked_sub</a></li><li><a href="#method.constant" title="constant">constant</a></li><li><a href="#method.duration_since" title="duration_since">duration_since</a></li><li><a href="#method.duration_until" title="duration_until">duration_until</a></li><li><a href="#method.hour" title="hour">hour</a></li><li><a href="#method.microsecond" title="microsecond">microsecond</a></li><li><a href="#method.midnight" title="midnight">midnight</a></li><li><a href="#method.millisecond" title="millisecond">millisecond</a></li><li><a href="#method.minute" title="minute">minute</a></li><li><a href="#method.nanosecond" title="nanosecond">nanosecond</a></li><li><a href="#method.new" title="new">new</a></li><li><a href="#method.on" title="on">on</a></li><li><a href="#method.round" title="round">round</a></li><li><a href="#method.saturating_add" title="saturating_add">saturating_add</a></li><li><a href="#method.saturating_sub" title="saturating_sub">saturating_sub</a></li><li><a href="#method.second" title="second">second</a></li><li><a href="#method.series" title="series">series</a></li><li><a href="#method.since" title="since">since</a></li><li><a href="#method.strftime" title="strftime">strftime</a></li><li><a href="#method.strptime" title="strptime">strptime</a></li><li><a href="#method.subsec_nanosecond" title="subsec_nanosecond">subsec_nanosecond</a></li><li><a href="#method.to_datetime" title="to_datetime">to_datetime</a></li><li><a href="#method.until" title="until">until</a></li><li><a href="#method.with" title="with">with</a></li><li><a href="#method.wrapping_add" title="wrapping_add">wrapping_add</a></li><li><a href="#method.wrapping_sub" title="wrapping_sub">wrapping_sub</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Add%3CDuration%3E-for-Time" title="Add&#60;Duration&#62;">Add&#60;Duration&#62;</a></li><li><a href="#impl-Add%3CSignedDuration%3E-for-Time" title="Add&#60;SignedDuration&#62;">Add&#60;SignedDuration&#62;</a></li><li><a href="#impl-Add%3CSpan%3E-for-Time" title="Add&#60;Span&#62;">Add&#60;Span&#62;</a></li><li><a href="#impl-AddAssign%3CDuration%3E-for-Time" title="AddAssign&#60;Duration&#62;">AddAssign&#60;Duration&#62;</a></li><li><a href="#impl-AddAssign%3CSignedDuration%3E-for-Time" title="AddAssign&#60;SignedDuration&#62;">AddAssign&#60;SignedDuration&#62;</a></li><li><a href="#impl-AddAssign%3CSpan%3E-for-Time" title="AddAssign&#60;Span&#62;">AddAssign&#60;Span&#62;</a></li><li><a href="#impl-Clone-for-Time" title="Clone">Clone</a></li><li><a href="#impl-Copy-for-Time" title="Copy">Copy</a></li><li><a href="#impl-Debug-for-Time" title="Debug">Debug</a></li><li><a href="#impl-Default-for-Time" title="Default">Default</a></li><li><a href="#impl-Display-for-Time" title="Display">Display</a></li><li><a href="#impl-Eq-for-Time" title="Eq">Eq</a></li><li><a href="#impl-From%3C%26Zoned%3E-for-Time" title="From&#60;&#38;&#39;a Zoned&#62;">From&#60;&#38;&#39;a Zoned&#62;</a></li><li><a href="#impl-From%3CDateTime%3E-for-Time" title="From&#60;DateTime&#62;">From&#60;DateTime&#62;</a></li><li><a href="#impl-From%3CTime%3E-for-BrokenDownTime" title="From&#60;Time&#62;">From&#60;Time&#62;</a></li><li><a href="#impl-From%3CTime%3E-for-Meridiem" title="From&#60;Time&#62;">From&#60;Time&#62;</a></li><li><a href="#impl-From%3CTime%3E-for-TimeDifference" title="From&#60;Time&#62;">From&#60;Time&#62;</a></li><li><a href="#impl-From%3CZoned%3E-for-Time" title="From&#60;Zoned&#62;">From&#60;Zoned&#62;</a></li><li><a href="#impl-FromPyObject%3C'py%3E-for-Time" title="FromPyObject&#60;&#39;py&#62;">FromPyObject&#60;&#39;py&#62;</a></li><li><a href="#impl-FromStr-for-Time" title="FromStr">FromStr</a></li><li><a href="#impl-Hash-for-Time" title="Hash">Hash</a></li><li><a href="#impl-IntoPyObject%3C'py%3E-for-%26Time" title="IntoPyObject&#60;&#39;py&#62;">IntoPyObject&#60;&#39;py&#62;</a></li><li><a href="#impl-IntoPyObject%3C'py%3E-for-Time" title="IntoPyObject&#60;&#39;py&#62;">IntoPyObject&#60;&#39;py&#62;</a></li><li><a href="#impl-Ord-for-Time" title="Ord">Ord</a></li><li><a href="#impl-PartialEq-for-Time" title="PartialEq">PartialEq</a></li><li><a href="#impl-PartialOrd-for-Time" title="PartialOrd">PartialOrd</a></li><li><a href="#impl-StructuralPartialEq-for-Time" title="StructuralPartialEq">StructuralPartialEq</a></li><li><a href="#impl-Sub-for-Time" title="Sub">Sub</a></li><li><a href="#impl-Sub%3CDuration%3E-for-Time" title="Sub&#60;Duration&#62;">Sub&#60;Duration&#62;</a></li><li><a href="#impl-Sub%3CSignedDuration%3E-for-Time" title="Sub&#60;SignedDuration&#62;">Sub&#60;SignedDuration&#62;</a></li><li><a href="#impl-Sub%3CSpan%3E-for-Time" title="Sub&#60;Span&#62;">Sub&#60;Span&#62;</a></li><li><a href="#impl-SubAssign%3CDuration%3E-for-Time" title="SubAssign&#60;Duration&#62;">SubAssign&#60;Duration&#62;</a></li><li><a href="#impl-SubAssign%3CSignedDuration%3E-for-Time" title="SubAssign&#60;SignedDuration&#62;">SubAssign&#60;SignedDuration&#62;</a></li><li><a href="#impl-SubAssign%3CSpan%3E-for-Time" title="SubAssign&#60;Span&#62;">SubAssign&#60;Span&#62;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-Time" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Time" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Time" title="Send">Send</a></li><li><a href="#impl-Sync-for-Time" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-Time" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Time" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-ByteSized-for-T" title="ByteSized">ByteSized</a></li><li><a href="#impl-Chain%3CR%3E-for-T" title="Chain&#60;R&#62;">Chain&#60;R&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-Comparable%3CK%3E-for-Q" title="Comparable&#60;K&#62;">Comparable&#60;K&#62;</a></li><li><a href="#impl-Duplex%3CS%3E-for-T" title="Duplex&#60;S&#62;">Duplex&#60;S&#62;</a></li><li><a href="#impl-Equivalent%3CK%3E-for-Q" title="Equivalent&#60;K&#62;">Equivalent&#60;K&#62;</a></li><li><a href="#impl-ExtAny-for-T" title="ExtAny">ExtAny</a></li><li><a href="#impl-ExtMem-for-T" title="ExtMem">ExtMem</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-FromPyObjectBound%3C'_,+'py%3E-for-T" title="FromPyObjectBound&#60;&#39;_, &#39;py&#62;">FromPyObjectBound&#60;&#39;_, &#39;py&#62;</a></li><li><a href="#impl-FromSample%3CS%3E-for-S" title="FromSample&#60;S&#62;">FromSample&#60;S&#62;</a></li><li><a href="#impl-Hook-for-T" title="Hook">Hook</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-IntoEither-for-T" title="IntoEither">IntoEither</a></li><li><a href="#impl-IntoPyObjectExt%3C'py%3E-for-T" title="IntoPyObjectExt&#60;&#39;py&#62;">IntoPyObjectExt&#60;&#39;py&#62;</a></li><li><a href="#impl-IntoSample%3CT%3E-for-F" title="IntoSample&#60;T&#62;">IntoSample&#60;T&#62;</a></li><li><a href="#impl-Pointable-for-T" title="Pointable">Pointable</a></li><li><a href="#impl-PyErrArguments-for-T" title="PyErrArguments">PyErrArguments</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-ToSample%3CU%3E-for-T" title="ToSample&#60;U&#62;">ToSample&#60;U&#62;</a></li><li><a href="#impl-ToString-for-T" title="ToString">ToString</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li><li><a href="#impl-Ungil-for-T" title="Ungil">Ungil</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In devela::<wbr>_<wbr>dep::<wbr>jiff::<wbr>civil</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../../index.html">devela</a>::<wbr><a href="../../index.html">_dep</a>::<wbr><a href="../index.html">jiff</a>::<wbr><a href="index.html">civil</a></div><h1>Struct <span class="struct">Time</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"></span></div><pre class="rust item-decl"><code>pub struct Time { <span class="comment">/* private fields */</span> }</code></pre><span class="item-info"><div class="stab portability">Available on <strong>crate features <code>dep_jiff</code> and <code>alloc</code></strong> only.</div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A representation of civil “wall clock” time.</p>
<p>Conceptually, a <code>Time</code> value corresponds to the typical hours and minutes
that you might see on a clock. This type also contains the second and
fractional subsecond (to nanosecond precision) associated with a time.</p>
<h2 id="civil-time"><a class="doc-anchor" href="#civil-time">§</a>Civil time</h2>
<p>A <code>Time</code> value behaves as if it corresponds precisely to a single
nanosecond within a day, where all days have <code>86,400</code> seconds. That is,
any given <code>Time</code> value corresponds to a nanosecond in the inclusive range
<code>[0, 86399999999999]</code>, where <code>0</code> corresponds to <code>00:00:00.000000000</code>
(<a href="struct.Time.html#associatedconstant.MIN" title="associated constant devela::_dep::jiff::civil::Time::MIN"><code>Time::MIN</code></a>) and <code>86399999999999</code> corresponds to <code>23:59:59.999999999</code>
(<a href="struct.Time.html#associatedconstant.MAX" title="associated constant devela::_dep::jiff::civil::Time::MAX"><code>Time::MAX</code></a>). Moreover, in civil time, all hours have the same number of
minutes, all minutes have the same number of seconds and all seconds have
the same number of nanoseconds.</p>
<h2 id="parsing-and-printing"><a class="doc-anchor" href="#parsing-and-printing">§</a>Parsing and printing</h2>
<p>The <code>Time</code> type provides convenient trait implementations of
<a href="../../../all/trait.FromStr.html" title="trait devela::all::FromStr"><code>std::str::FromStr</code></a> and <a href="../../../all/trait.Display.html" title="trait devela::all::Display"><code>std::fmt::Display</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::Time;

<span class="kw">let </span>t: Time = <span class="string">"15:22:45"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(t.to_string(), <span class="string">"15:22:45"</span>);
</code></pre></div>
<p>A civil <code>Time</code> can also be parsed from something that <em>contains</em> a
time, but with perhaps other data (such as an offset or time zone):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::Time;

<span class="kw">let </span>t: Time = <span class="string">"2024-06-19T15:22:45-04[America/New_York]"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(t.to_string(), <span class="string">"15:22:45"</span>);
</code></pre></div>
<p>For more information on the specific format supported, see the
<a href="../fmt/temporal/index.html" title="mod devela::_dep::jiff::fmt::temporal"><code>fmt::temporal</code></a> module documentation.</p>
<h2 id="default-value"><a class="doc-anchor" href="#default-value">§</a>Default value</h2>
<p>For convenience, this type implements the <code>Default</code> trait. Its default
value is midnight. i.e., <code>00:00:00.000000000</code>.</p>
<h2 id="leap-seconds"><a class="doc-anchor" href="#leap-seconds">§</a>Leap seconds</h2>
<p>Jiff does not support leap seconds. Jiff behaves as if they don’t exist.
The only exception is that if one parses a time with a second component
of <code>60</code>, then it is automatically constrained to <code>59</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{Time, time};

<span class="kw">let </span>t: Time = <span class="string">"23:59:60"</span>.parse()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(t, time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">0</span>));
</code></pre></div>
<h2 id="comparisons"><a class="doc-anchor" href="#comparisons">§</a>Comparisons</h2>
<p>The <code>Time</code> type provides both <code>Eq</code> and <code>Ord</code> trait implementations to
facilitate easy comparisons. When a time <code>t1</code> occurs before a time <code>t2</code>,
then <code>t1 &lt; t2</code>. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t1 = time(<span class="number">7</span>, <span class="number">30</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="kw">let </span>t2 = time(<span class="number">8</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert!</span>(t1 &lt; t2);</code></pre></div>
<p>As mentioned above, <code>Time</code> values are not associated with timezones, and
thus transitions such as DST are not taken into account when comparing
<code>Time</code> values.</p>
<h2 id="arithmetic"><a class="doc-anchor" href="#arithmetic">§</a>Arithmetic</h2>
<p>This type provides routines for adding and subtracting spans of time, as
well as computing the span of time between two <code>Time</code> values.</p>
<p>For adding or subtracting spans of time, one can use any of the following
routines:</p>
<ul>
<li><a href="struct.Time.html#method.wrapping_add" title="method devela::_dep::jiff::civil::Time::wrapping_add"><code>Time::wrapping_add</code></a> or <a href="struct.Time.html#method.wrapping_sub" title="method devela::_dep::jiff::civil::Time::wrapping_sub"><code>Time::wrapping_sub</code></a> for wrapping arithmetic.</li>
<li><a href="struct.Time.html#method.checked_add" title="method devela::_dep::jiff::civil::Time::checked_add"><code>Time::checked_add</code></a> or <a href="struct.Time.html#method.checked_sub" title="method devela::_dep::jiff::civil::Time::checked_sub"><code>Time::checked_sub</code></a> for checked arithmetic.</li>
<li><a href="struct.Time.html#method.saturating_add" title="method devela::_dep::jiff::civil::Time::saturating_add"><code>Time::saturating_add</code></a> or <a href="struct.Time.html#method.saturating_sub" title="method devela::_dep::jiff::civil::Time::saturating_sub"><code>Time::saturating_sub</code></a> for saturating
arithmetic.</li>
</ul>
<p>Additionally, wrapping arithmetic is available via the <code>Add</code> and <code>Sub</code>
trait implementations:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>t = time(<span class="number">20</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="kw">let </span>span = <span class="number">1</span>.hours().minutes(<span class="number">49</span>).seconds(<span class="number">59</span>);
<span class="macro">assert_eq!</span>(t + span, time(<span class="number">22</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));

<span class="comment">// Overflow will result in wrap-around unless using checked
// arithmetic explicitly.
</span><span class="kw">let </span>t = time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>);
<span class="macro">assert_eq!</span>(time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), t + <span class="number">1</span>.nanoseconds());</code></pre></div>
<p>Wrapping arithmetic is used by default because it corresponds to how clocks
showing the time of day behave in practice.</p>
<p>One can compute the span of time between two times using either
<a href="struct.Time.html#method.until" title="method devela::_dep::jiff::civil::Time::until"><code>Time::until</code></a> or <a href="struct.Time.html#method.since" title="method devela::_dep::jiff::civil::Time::since"><code>Time::since</code></a>. It’s also possible to subtract two
<code>Time</code> values directly via a <code>Sub</code> trait implementation:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>time1 = time(<span class="number">22</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>time2 = time(<span class="number">20</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    time1 - time2,
    <span class="number">1</span>.hours().minutes(<span class="number">49</span>).seconds(<span class="number">59</span>).fieldwise(),
);</code></pre></div>
<p>The <code>until</code> and <code>since</code> APIs are polymorphic and allow re-balancing and
rounding the span returned. For example, the default largest unit is hours
(as exemplified above), but we can ask for smaller units:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan, Unit};

<span class="kw">let </span>time1 = time(<span class="number">23</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>time2 = time(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    time1.since((Unit::Minute, time2))<span class="question-mark">?</span>,
    <span class="number">990</span>.minutes().fieldwise(),
);
</code></pre></div>
<p>Or even round the span returned:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{TimeDifference, time}, RoundMode, ToSpan, Unit};

<span class="kw">let </span>time1 = time(<span class="number">23</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>time2 = time(<span class="number">23</span>, <span class="number">35</span>, <span class="number">59</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    time1.until(
        TimeDifference::new(time2).smallest(Unit::Minute),
    )<span class="question-mark">?</span>,
    <span class="number">5</span>.minutes().fieldwise(),
);
<span class="comment">// `TimeDifference` uses truncation as a rounding mode by default,
// but you can set the rounding mode to break ties away from zero:
</span><span class="macro">assert_eq!</span>(
    time1.until(
        TimeDifference::new(time2)
            .smallest(Unit::Minute)
            .mode(RoundMode::HalfExpand),
    )<span class="question-mark">?</span>,
    <span class="comment">// Rounds up to 6 minutes.
    </span><span class="number">6</span>.minutes().fieldwise(),
);
</code></pre></div>
<h2 id="rounding"><a class="doc-anchor" href="#rounding">§</a>Rounding</h2>
<p>A <code>Time</code> can be rounded based on a <a href="struct.TimeRound.html" title="struct devela::_dep::jiff::civil::TimeRound"><code>TimeRound</code></a> configuration of smallest
units, rounding increment and rounding mode. Here’s an example showing how
to round to the nearest third hour:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{TimeRound, time}, Unit};

<span class="kw">let </span>t = time(<span class="number">16</span>, <span class="number">27</span>, <span class="number">29</span>, <span class="number">999_999_999</span>);
<span class="macro">assert_eq!</span>(
    t.round(TimeRound::new().smallest(Unit::Hour).increment(<span class="number">3</span>))<span class="question-mark">?</span>,
    time(<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);
<span class="comment">// Or alternatively, make use of the `From&lt;(Unit, i64)&gt; for TimeRound`
// trait implementation:
</span><span class="macro">assert_eq!</span>(t.round((Unit::Hour, <span class="number">3</span>))<span class="question-mark">?</span>, time(<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>));
</code></pre></div>
<p>See <a href="struct.Time.html#method.round" title="method devela::_dep::jiff::civil::Time::round"><code>Time::round</code></a> for more details.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Time" class="impl"><a href="#impl-Time" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.MIN" class="associatedconstant"><h4 class="code-header">pub const <a href="#associatedconstant.MIN" class="constant">MIN</a>: <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h4></section></summary><div class="docblock"><p>The minimum representable time value.</p>
<p>This corresponds to <code>00:00:00.000000000</code>.</p>
</div></details><details class="toggle" open><summary><section id="associatedconstant.MAX" class="associatedconstant"><h4 class="code-header">pub const <a href="#associatedconstant.MAX" class="constant">MAX</a>: <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h4></section></summary><div class="docblock"><p>The maximum representable time value.</p>
<p>This corresponds to <code>23:59:59.999999999</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>(
    hour: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i8.html">i8</a>,
    minute: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i8.html">i8</a>,
    second: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i8.html">i8</a>,
    subsec_nanosecond: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>,
) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;<a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a>, <a class="struct" href="../struct.Error.html" title="struct devela::_dep::jiff::Error">Error</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;Time, Error&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Creates a new <code>Time</code> value from its component hour, minute, second and
fractional subsecond (up to nanosecond precision) values.</p>
<p>To set the component values of a time after creating it, use
<a href="struct.TimeWith.html" title="struct devela::_dep::jiff::civil::TimeWith"><code>TimeWith</code></a> via <a href="struct.Time.html#method.with" title="method devela::_dep::jiff::civil::Time::with"><code>Time::with</code></a> to build a new <a href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time"><code>Time</code></a> from the fields
of an existing time.</p>
<h5 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h5>
<p>This returns an error unless <em>all</em> of the following conditions are
true:</p>
<ul>
<li><code>0 &lt;= hour &lt;= 23</code></li>
<li><code>0 &lt;= minute &lt;= 59</code></li>
<li><code>0 &lt;= second &lt;= 59</code></li>
<li><code>0 &lt;= subsec_nanosecond &lt;= 999,999,999</code></li>
</ul>
<h5 id="example"><a class="doc-anchor" href="#example">§</a>Example</h5>
<p>This shows an example of a valid time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::Time;

<span class="kw">let </span>t = Time::new(<span class="number">21</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">123_456_789</span>).unwrap();
<span class="macro">assert_eq!</span>(t.hour(), <span class="number">21</span>);
<span class="macro">assert_eq!</span>(t.minute(), <span class="number">30</span>);
<span class="macro">assert_eq!</span>(t.second(), <span class="number">5</span>);
<span class="macro">assert_eq!</span>(t.millisecond(), <span class="number">123</span>);
<span class="macro">assert_eq!</span>(t.microsecond(), <span class="number">456</span>);
<span class="macro">assert_eq!</span>(t.nanosecond(), <span class="number">789</span>);</code></pre></div>
<p>This shows an example of an invalid time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::Time;

<span class="macro">assert!</span>(Time::new(<span class="number">21</span>, <span class="number">30</span>, <span class="number">60</span>, <span class="number">0</span>).is_err());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.constant" class="method"><h4 class="code-header">pub const fn <a href="#method.constant" class="fn">constant</a>(
    hour: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i8.html">i8</a>,
    minute: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i8.html">i8</a>,
    second: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i8.html">i8</a>,
    subsec_nanosecond: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>,
) -&gt; <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h4></section></summary><div class="docblock"><p>Creates a new <code>Time</code> value in a <code>const</code> context.</p>
<h5 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h5>
<p>This panics if the given values do not correspond to a valid <code>Time</code>.
All of the following conditions must be true:</p>
<ul>
<li><code>0 &lt;= hour &lt;= 23</code></li>
<li><code>0 &lt;= minute &lt;= 59</code></li>
<li><code>0 &lt;= second &lt;= 59</code></li>
<li><code>0 &lt;= subsec_nanosecond &lt;= 999,999,999</code></li>
</ul>
<p>Similarly, when used in a const context, invalid parameters will
prevent your Rust program from compiling.</p>
<h5 id="example-1"><a class="doc-anchor" href="#example-1">§</a>Example</h5>
<p>This shows an example of a valid time in a <code>const</code> context:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::Time;

<span class="kw">const </span>BEDTIME: Time = Time::constant(<span class="number">21</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(BEDTIME.hour(), <span class="number">21</span>);
<span class="macro">assert_eq!</span>(BEDTIME.minute(), <span class="number">30</span>);
<span class="macro">assert_eq!</span>(BEDTIME.second(), <span class="number">5</span>);
<span class="macro">assert_eq!</span>(BEDTIME.millisecond(), <span class="number">123</span>);
<span class="macro">assert_eq!</span>(BEDTIME.microsecond(), <span class="number">456</span>);
<span class="macro">assert_eq!</span>(BEDTIME.nanosecond(), <span class="number">789</span>);
<span class="macro">assert_eq!</span>(BEDTIME.subsec_nanosecond(), <span class="number">123_456_789</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.midnight" class="method"><h4 class="code-header">pub const fn <a href="#method.midnight" class="fn">midnight</a>() -&gt; <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h4></section></summary><div class="docblock"><p>Returns the first moment of time in a day.</p>
<p>Specifically, this has the <code>hour</code>, <code>minute</code>, <code>second</code>, <code>millisecond</code>,
<code>microsecond</code> and <code>nanosecond</code> fields all set to <code>0</code>.</p>
<h5 id="example-2"><a class="doc-anchor" href="#example-2">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::Time;

<span class="kw">let </span>t = Time::midnight();
<span class="macro">assert_eq!</span>(t.hour(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t.minute(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t.second(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t.millisecond(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t.microsecond(), <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t.nanosecond(), <span class="number">0</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.with" class="method"><h4 class="code-header">pub fn <a href="#method.with" class="fn">with</a>(self) -&gt; <a class="struct" href="struct.TimeWith.html" title="struct devela::_dep::jiff::civil::TimeWith">TimeWith</a></h4></section></summary><div class="docblock"><p>Create a builder for constructing a <code>Time</code> from the fields of this
time.</p>
<p>See the methods on <a href="struct.TimeWith.html" title="struct devela::_dep::jiff::civil::TimeWith"><code>TimeWith</code></a> for the different ways one can set the
fields of a new <code>Time</code>.</p>
<h5 id="example-3"><a class="doc-anchor" href="#example-3">§</a>Example</h5>
<p>Unlike <a href="struct.Date.html" title="struct devela::_dep::jiff::civil::Date"><code>Date</code></a>, a <a href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time"><code>Time</code></a> is valid for all possible valid values
of its fields. That is, there is no way for two valid field values
to combine into an invalid <code>Time</code>. So, for <code>Time</code>, this builder does
have as much of a benefit versus an API design with methods like
<code>Time::with_hour</code> and <code>Time::with_minute</code>. Nevertheless, this builder
permits settings multiple fields at the same time and performing only
one validity check. Moreover, this provides a consistent API with other
date and time types in this crate.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t1 = time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">24</span>, <span class="number">0</span>);
<span class="kw">let </span>t2 = t1.with().hour(<span class="number">15</span>).minute(<span class="number">30</span>).millisecond(<span class="number">10</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(t2, time(<span class="number">15</span>, <span class="number">30</span>, <span class="number">24</span>, <span class="number">10_000_000</span>));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.hour" class="method"><h4 class="code-header">pub fn <a href="#method.hour" class="fn">hour</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i8.html">i8</a></h4></section></summary><div class="docblock"><p>Returns the “hour” component of this time.</p>
<p>The value returned is guaranteed to be in the range <code>0..=23</code>.</p>
<h5 id="example-4"><a class="doc-anchor" href="#example-4">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">13</span>, <span class="number">35</span>, <span class="number">56</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(t.hour(), <span class="number">13</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.minute" class="method"><h4 class="code-header">pub fn <a href="#method.minute" class="fn">minute</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i8.html">i8</a></h4></section></summary><div class="docblock"><p>Returns the “minute” component of this time.</p>
<p>The value returned is guaranteed to be in the range <code>0..=59</code>.</p>
<h5 id="example-5"><a class="doc-anchor" href="#example-5">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">13</span>, <span class="number">35</span>, <span class="number">56</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(t.minute(), <span class="number">35</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.second" class="method"><h4 class="code-header">pub fn <a href="#method.second" class="fn">second</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i8.html">i8</a></h4></section></summary><div class="docblock"><p>Returns the “second” component of this time.</p>
<p>The value returned is guaranteed to be in the range <code>0..=59</code>.</p>
<h5 id="example-6"><a class="doc-anchor" href="#example-6">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">13</span>, <span class="number">35</span>, <span class="number">56</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(t.second(), <span class="number">56</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.millisecond" class="method"><h4 class="code-header">pub fn <a href="#method.millisecond" class="fn">millisecond</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i16.html">i16</a></h4></section></summary><div class="docblock"><p>Returns the “millisecond” component of this time.</p>
<p>The value returned is guaranteed to be in the range <code>0..=999</code>.</p>
<h5 id="example-7"><a class="doc-anchor" href="#example-7">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">13</span>, <span class="number">35</span>, <span class="number">56</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(t.millisecond(), <span class="number">123</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.microsecond" class="method"><h4 class="code-header">pub fn <a href="#method.microsecond" class="fn">microsecond</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i16.html">i16</a></h4></section></summary><div class="docblock"><p>Returns the “microsecond” component of this time.</p>
<p>The value returned is guaranteed to be in the range <code>0..=999</code>.</p>
<h5 id="example-8"><a class="doc-anchor" href="#example-8">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">13</span>, <span class="number">35</span>, <span class="number">56</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(t.microsecond(), <span class="number">456</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.nanosecond" class="method"><h4 class="code-header">pub fn <a href="#method.nanosecond" class="fn">nanosecond</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i16.html">i16</a></h4></section></summary><div class="docblock"><p>Returns the “nanosecond” component of this time.</p>
<p>The value returned is guaranteed to be in the range <code>0..=999</code>.</p>
<h5 id="example-9"><a class="doc-anchor" href="#example-9">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">13</span>, <span class="number">35</span>, <span class="number">56</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(t.nanosecond(), <span class="number">789</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.subsec_nanosecond" class="method"><h4 class="code-header">pub fn <a href="#method.subsec_nanosecond" class="fn">subsec_nanosecond</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a></h4></section></summary><div class="docblock"><p>Returns the fractional nanosecond for this <code>Time</code> value.</p>
<p>If you want to set this value on <code>Time</code>, then use
<a href="struct.TimeWith.html#method.subsec_nanosecond" title="method devela::_dep::jiff::civil::TimeWith::subsec_nanosecond"><code>TimeWith::subsec_nanosecond</code></a> via <a href="struct.Time.html#method.with" title="method devela::_dep::jiff::civil::Time::with"><code>Time::with</code></a>.</p>
<p>The value returned is guaranteed to be in the range <code>0..=999_999_999</code>.</p>
<h5 id="example-10"><a class="doc-anchor" href="#example-10">§</a>Example</h5>
<p>This shows the relationship between constructing a <code>Time</code> value
with routines like <code>with().millisecond()</code> and accessing the entire
fractional part as a nanosecond:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">15</span>, <span class="number">21</span>, <span class="number">35</span>, <span class="number">0</span>).with().millisecond(<span class="number">987</span>).build()<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(t.subsec_nanosecond(), <span class="number">987_000_000</span>);
</code></pre></div>
<h5 id="example-nanoseconds-from-a-timestamp"><a class="doc-anchor" href="#example-nanoseconds-from-a-timestamp">§</a>Example: nanoseconds from a timestamp</h5>
<p>This shows how the fractional nanosecond part of a <code>Time</code> value
manifests from a specific timestamp.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil, Timestamp};

<span class="comment">// 1,234 nanoseconds after the Unix epoch.
</span><span class="kw">let </span>zdt = Timestamp::new(<span class="number">0</span>, <span class="number">1_234</span>)<span class="question-mark">?</span>.in_tz(<span class="string">"UTC"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>time = zdt.datetime().time();
<span class="macro">assert_eq!</span>(time.subsec_nanosecond(), <span class="number">1_234</span>);

<span class="comment">// 1,234 nanoseconds before the Unix epoch.
</span><span class="kw">let </span>zdt = Timestamp::new(<span class="number">0</span>, -<span class="number">1_234</span>)<span class="question-mark">?</span>.in_tz(<span class="string">"UTC"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>time = zdt.datetime().time();
<span class="comment">// The nanosecond is equal to `1_000_000_000 - 1_234`.
</span><span class="macro">assert_eq!</span>(time.subsec_nanosecond(), <span class="number">999998766</span>);
<span class="comment">// Looking at the other components of the time value might help.
</span><span class="macro">assert_eq!</span>(time.hour(), <span class="number">23</span>);
<span class="macro">assert_eq!</span>(time.minute(), <span class="number">59</span>);
<span class="macro">assert_eq!</span>(time.second(), <span class="number">59</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.to_datetime" class="method"><h4 class="code-header">pub const fn <a href="#method.to_datetime" class="fn">to_datetime</a>(self, date: <a class="struct" href="struct.Date.html" title="struct devela::_dep::jiff::civil::Date">Date</a>) -&gt; <a class="struct" href="struct.DateTime.html" title="struct devela::_dep::jiff::civil::DateTime">DateTime</a></h4></section></summary><div class="docblock"><p>Given a <a href="struct.Date.html" title="struct devela::_dep::jiff::civil::Date"><code>Date</code></a>, this constructs a <a href="struct.DateTime.html" title="struct devela::_dep::jiff::civil::DateTime"><code>DateTime</code></a> value with its time
component equal to this time.</p>
<p>This is a convenience function for <a href="struct.DateTime.html#method.from_parts" title="associated function devela::_dep::jiff::civil::DateTime::from_parts"><code>DateTime::from_parts</code></a>.</p>
<h5 id="example-11"><a class="doc-anchor" href="#example-11">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::{DateTime, date, time};

<span class="kw">let </span>d = date(<span class="number">2010</span>, <span class="number">3</span>, <span class="number">14</span>);
<span class="kw">let </span>t = time(<span class="number">2</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(DateTime::from_parts(d, t), t.to_datetime(d));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.on" class="method"><h4 class="code-header">pub const fn <a href="#method.on" class="fn">on</a>(self, year: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i16.html">i16</a>, month: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i8.html">i8</a>, day: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i8.html">i8</a>) -&gt; <a class="struct" href="struct.DateTime.html" title="struct devela::_dep::jiff::civil::DateTime">DateTime</a></h4></section></summary><div class="docblock"><p>A convenience function for constructing a <a href="struct.DateTime.html" title="struct devela::_dep::jiff::civil::DateTime"><code>DateTime</code></a> from this time
on the date given by its components.</p>
<h5 id="example-12"><a class="doc-anchor" href="#example-12">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="macro">assert_eq!</span>(
    time(<span class="number">2</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).on(<span class="number">2010</span>, <span class="number">3</span>, <span class="number">14</span>).to_string(),
    <span class="string">"2010-03-14T02:30:00"</span>,
);</code></pre></div>
<p>One can also flip the order by making use of <a href="struct.Date.html#method.at" title="method devela::_dep::jiff::civil::Date::at"><code>Date::at</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::date;

<span class="macro">assert_eq!</span>(
    date(<span class="number">2010</span>, <span class="number">3</span>, <span class="number">14</span>).at(<span class="number">2</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>).to_string(),
    <span class="string">"2010-03-14T02:30:00"</span>,
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_add" class="method"><h4 class="code-header">pub fn <a href="#method.wrapping_add" class="fn">wrapping_add</a>&lt;A&gt;(self, duration: A) -&gt; <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a><div class="where">where
    A: <a class="trait" href="../../../code/trait.Into.html" title="trait devela::code::Into">Into</a>&lt;<a class="struct" href="struct.TimeArithmetic.html" title="struct devela::_dep::jiff::civil::TimeArithmetic">TimeArithmetic</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Add the given span to this time and wrap around on overflow.</p>
<p>This operation accepts three different duration types: <a href="../struct.Span.html" title="struct devela::_dep::jiff::Span"><code>Span</code></a>,
<a href="../struct.SignedDuration.html" title="struct devela::_dep::jiff::SignedDuration"><code>SignedDuration</code></a> or <a href="../../../all/struct.Duration.html" title="struct devela::all::Duration"><code>std::time::Duration</code></a>. This is achieved via
<code>From</code> trait implementations for the <a href="struct.TimeArithmetic.html" title="struct devela::_dep::jiff::civil::TimeArithmetic"><code>TimeArithmetic</code></a> type.</p>
<h5 id="properties"><a class="doc-anchor" href="#properties">§</a>Properties</h5>
<p>Given times <code>t1</code> and <code>t2</code>, and a span <code>s</code>, with <code>t2 = t1 + s</code>, it
follows then that <code>t1 = t2 - s</code> for all values of <code>t1</code> and <code>s</code> that sum
to <code>t2</code>.</p>
<p>In short, subtracting the given span from the sum returned by this
function is guaranteed to result in precisely the original time.</p>
<h5 id="example-available-via-addition-operator"><a class="doc-anchor" href="#example-available-via-addition-operator">§</a>Example: available via addition operator</h5>
<p>This routine can be used via the <code>+</code> operator.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>t = time(<span class="number">20</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    t + <span class="number">1</span>.hours().minutes(<span class="number">49</span>).seconds(<span class="number">59</span>),
    time(<span class="number">22</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);</code></pre></div>
<h5 id="example-add-nanoseconds-to-a-time"><a class="doc-anchor" href="#example-add-nanoseconds-to-a-time">§</a>Example: add nanoseconds to a <code>Time</code></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>t = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">3</span>, <span class="number">500_000_000</span>),
    t.wrapping_add(<span class="number">2_500_000_000i64</span>.nanoseconds()),
);</code></pre></div>
<h5 id="example-add-span-with-multiple-units"><a class="doc-anchor" href="#example-add-span-with-multiple-units">§</a>Example: add span with multiple units</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>t = time(<span class="number">20</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    time(<span class="number">22</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    t.wrapping_add(<span class="number">1</span>.hours().minutes(<span class="number">49</span>).seconds(<span class="number">59</span>)),
);</code></pre></div>
<h5 id="example-adding-an-empty-span-is-a-no-op"><a class="doc-anchor" href="#example-adding-an-empty-span-is-a-no-op">§</a>Example: adding an empty span is a no-op</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, Span};

<span class="kw">let </span>t = time(<span class="number">20</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t, t.wrapping_add(Span::new()));</code></pre></div>
<h5 id="example-addition-wraps-on-overflow"><a class="doc-anchor" href="#example-addition-wraps-on-overflow">§</a>Example: addition wraps on overflow</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, SignedDuration, ToSpan};

<span class="kw">let </span>t = time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>);
<span class="macro">assert_eq!</span>(
    t.wrapping_add(<span class="number">1</span>.nanoseconds()),
    time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);
<span class="macro">assert_eq!</span>(
    t.wrapping_add(SignedDuration::from_nanos(<span class="number">1</span>)),
    time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);
<span class="macro">assert_eq!</span>(
    t.wrapping_add(std::time::Duration::from_nanos(<span class="number">1</span>)),
    time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);</code></pre></div>
<p>Similarly, if there are any non-zero units greater than hours in the
given span, then they also result in wrapping behavior (i.e., they are
ignored):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="comment">// doesn't matter what our time value is in this example
</span><span class="kw">let </span>t = time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t, t.wrapping_add(<span class="number">1</span>.days()));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.wrapping_sub" class="method"><h4 class="code-header">pub fn <a href="#method.wrapping_sub" class="fn">wrapping_sub</a>&lt;A&gt;(self, duration: A) -&gt; <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a><div class="where">where
    A: <a class="trait" href="../../../code/trait.Into.html" title="trait devela::code::Into">Into</a>&lt;<a class="struct" href="struct.TimeArithmetic.html" title="struct devela::_dep::jiff::civil::TimeArithmetic">TimeArithmetic</a>&gt;,</div></h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Time.html#method.wrapping_add" title="method devela::_dep::jiff::civil::Time::wrapping_add"><code>Time::wrapping_add</code></a> with the duration
negated.</p>
<h5 id="example-13"><a class="doc-anchor" href="#example-13">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, SignedDuration, ToSpan};

<span class="kw">let </span>t = time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    t.wrapping_sub(<span class="number">1</span>.nanoseconds()),
    time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>),
);
<span class="macro">assert_eq!</span>(
    t.wrapping_sub(SignedDuration::from_nanos(<span class="number">1</span>)),
    time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>),
);
<span class="macro">assert_eq!</span>(
    t.wrapping_sub(std::time::Duration::from_nanos(<span class="number">1</span>)),
    time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>),
);

<span class="macro">assert_eq!</span>(
    t.wrapping_sub(SignedDuration::MIN),
    time(<span class="number">15</span>, <span class="number">30</span>, <span class="number">8</span>, <span class="number">999_999_999</span>),
);
<span class="macro">assert_eq!</span>(
    t.wrapping_sub(SignedDuration::MAX),
    time(<span class="number">8</span>, <span class="number">29</span>, <span class="number">52</span>, <span class="number">1</span>),
);
<span class="macro">assert_eq!</span>(
    t.wrapping_sub(std::time::Duration::MAX),
    time(<span class="number">16</span>, <span class="number">59</span>, <span class="number">44</span>, <span class="number">1</span>),
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.checked_add" class="method"><h4 class="code-header">pub fn <a href="#method.checked_add" class="fn">checked_add</a>&lt;A&gt;(self, duration: A) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;<a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a>, <a class="struct" href="../struct.Error.html" title="struct devela::_dep::jiff::Error">Error</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;Time, Error&gt;">ⓘ</a><div class="where">where
    A: <a class="trait" href="../../../code/trait.Into.html" title="trait devela::code::Into">Into</a>&lt;<a class="struct" href="struct.TimeArithmetic.html" title="struct devela::_dep::jiff::civil::TimeArithmetic">TimeArithmetic</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Add the given span to this time and return an error if the result would
otherwise overflow.</p>
<p>This operation accepts three different duration types: <a href="../struct.Span.html" title="struct devela::_dep::jiff::Span"><code>Span</code></a>,
<a href="../struct.SignedDuration.html" title="struct devela::_dep::jiff::SignedDuration"><code>SignedDuration</code></a> or <a href="../../../all/struct.Duration.html" title="struct devela::all::Duration"><code>std::time::Duration</code></a>. This is achieved via
<code>From</code> trait implementations for the <a href="struct.TimeArithmetic.html" title="struct devela::_dep::jiff::civil::TimeArithmetic"><code>TimeArithmetic</code></a> type.</p>
<h5 id="properties-1"><a class="doc-anchor" href="#properties-1">§</a>Properties</h5>
<p>Given a time <code>t1</code> and a span <code>s</code>, and assuming <code>t2 = t1 + s</code> exists, it
follows then that <code>t1 = t2 - s</code> for all values of <code>t1</code> and <code>s</code> that sum
to a valid <code>t2</code>.</p>
<p>In short, subtracting the given span from the sum returned by this
function is guaranteed to result in precisely the original time.</p>
<h5 id="errors-1"><a class="doc-anchor" href="#errors-1">§</a>Errors</h5>
<p>If the sum would overflow the minimum or maximum timestamp values, then
an error is returned.</p>
<p>If the given span has any non-zero units greater than hours, then an
error is returned.</p>
<h5 id="example-add-nanoseconds-to-a-time-1"><a class="doc-anchor" href="#example-add-nanoseconds-to-a-time-1">§</a>Example: add nanoseconds to a <code>Time</code></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>t = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">3</span>, <span class="number">500_000_000</span>),
    t.checked_add(<span class="number">2_500_000_000i64</span>.nanoseconds())<span class="question-mark">?</span>,
);</code></pre></div>
<h5 id="example-add-span-with-multiple-units-1"><a class="doc-anchor" href="#example-add-span-with-multiple-units-1">§</a>Example: add span with multiple units</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>t = time(<span class="number">20</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    time(<span class="number">22</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    t.checked_add(<span class="number">1</span>.hours().minutes(<span class="number">49</span>).seconds(<span class="number">59</span>))<span class="question-mark">?</span>,
);</code></pre></div>
<h5 id="example-adding-an-empty-span-is-a-no-op-1"><a class="doc-anchor" href="#example-adding-an-empty-span-is-a-no-op-1">§</a>Example: adding an empty span is a no-op</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, Span};

<span class="kw">let </span>t = time(<span class="number">20</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t, t.checked_add(Span::new())<span class="question-mark">?</span>);
</code></pre></div>
<h5 id="example-error-on-overflow"><a class="doc-anchor" href="#example-error-on-overflow">§</a>Example: error on overflow</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="comment">// okay
</span><span class="kw">let </span>t = time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_998</span>);
<span class="macro">assert_eq!</span>(
    t.with().nanosecond(<span class="number">999</span>).build()<span class="question-mark">?</span>,
    t.checked_add(<span class="number">1</span>.nanoseconds())<span class="question-mark">?</span>,
);

<span class="comment">// not okay
</span><span class="kw">let </span>t = time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>);
<span class="macro">assert!</span>(t.checked_add(<span class="number">1</span>.nanoseconds()).is_err());
</code></pre></div>
<p>Similarly, if there are any non-zero units greater than hours in the
given span, then they also result in overflow (and thus an error):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="comment">// doesn't matter what our time value is in this example
</span><span class="kw">let </span>t = time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert!</span>(t.checked_add(<span class="number">1</span>.days()).is_err());</code></pre></div>
<h5 id="example-adding-absolute-durations"><a class="doc-anchor" href="#example-adding-absolute-durations">§</a>Example: adding absolute durations</h5>
<p>This shows how to add signed and unsigned absolute durations to a
<code>Time</code>. As with adding a <code>Span</code>, any overflow that occurs results in
an error.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::{civil::time, SignedDuration};

<span class="kw">let </span>t = time(<span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);

<span class="kw">let </span>dur = SignedDuration::from_mins(<span class="number">30</span>);
<span class="macro">assert_eq!</span>(t.checked_add(dur)<span class="question-mark">?</span>, time(<span class="number">23</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="macro">assert_eq!</span>(t.checked_add(-dur)<span class="question-mark">?</span>, time(<span class="number">22</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));

<span class="kw">let </span>dur = Duration::new(<span class="number">0</span>, <span class="number">1</span>);
<span class="macro">assert_eq!</span>(t.checked_add(dur)<span class="question-mark">?</span>, time(<span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.checked_sub" class="method"><h4 class="code-header">pub fn <a href="#method.checked_sub" class="fn">checked_sub</a>&lt;A&gt;(self, duration: A) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;<a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a>, <a class="struct" href="../struct.Error.html" title="struct devela::_dep::jiff::Error">Error</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;Time, Error&gt;">ⓘ</a><div class="where">where
    A: <a class="trait" href="../../../code/trait.Into.html" title="trait devela::code::Into">Into</a>&lt;<a class="struct" href="struct.TimeArithmetic.html" title="struct devela::_dep::jiff::civil::TimeArithmetic">TimeArithmetic</a>&gt;,</div></h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Time.html#method.checked_add" title="method devela::_dep::jiff::civil::Time::checked_add"><code>Time::checked_add</code></a> with the duration
negated.</p>
<h5 id="errors-2"><a class="doc-anchor" href="#errors-2">§</a>Errors</h5>
<p>This has the same error conditions as <a href="struct.Time.html#method.checked_add" title="method devela::_dep::jiff::civil::Time::checked_add"><code>Time::checked_add</code></a>.</p>
<h5 id="example-14"><a class="doc-anchor" href="#example-14">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::{civil::time, SignedDuration, ToSpan};

<span class="kw">let </span>t = time(<span class="number">22</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    t.checked_sub(<span class="number">1</span>.hours().minutes(<span class="number">49</span>).seconds(<span class="number">59</span>))<span class="question-mark">?</span>,
    time(<span class="number">20</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">0</span>),
);
<span class="macro">assert_eq!</span>(
    t.checked_sub(SignedDuration::from_hours(<span class="number">1</span>))<span class="question-mark">?</span>,
    time(<span class="number">21</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);
<span class="macro">assert_eq!</span>(
    t.checked_sub(Duration::from_secs(<span class="number">60 </span>* <span class="number">60</span>))<span class="question-mark">?</span>,
    time(<span class="number">21</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.saturating_add" class="method"><h4 class="code-header">pub fn <a href="#method.saturating_add" class="fn">saturating_add</a>&lt;A&gt;(self, duration: A) -&gt; <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a><div class="where">where
    A: <a class="trait" href="../../../code/trait.Into.html" title="trait devela::code::Into">Into</a>&lt;<a class="struct" href="struct.TimeArithmetic.html" title="struct devela::_dep::jiff::civil::TimeArithmetic">TimeArithmetic</a>&gt;,</div></h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Time.html#method.checked_add" title="method devela::_dep::jiff::civil::Time::checked_add"><code>Time::checked_add</code></a>, except the
result saturates on overflow. That is, instead of overflow, either
<a href="struct.Time.html#associatedconstant.MIN" title="associated constant devela::_dep::jiff::civil::Time::MIN"><code>Time::MIN</code></a> or <a href="struct.Time.html#associatedconstant.MAX" title="associated constant devela::_dep::jiff::civil::Time::MAX"><code>Time::MAX</code></a> is returned.</p>
<h5 id="example-15"><a class="doc-anchor" href="#example-15">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{Time, time}, SignedDuration, ToSpan};

<span class="comment">// no saturation
</span><span class="kw">let </span>t = time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_998</span>);
<span class="macro">assert_eq!</span>(
    t.with().nanosecond(<span class="number">999</span>).build()<span class="question-mark">?</span>,
    t.saturating_add(<span class="number">1</span>.nanoseconds()),
);

<span class="comment">// saturates
</span><span class="kw">let </span>t = time(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>, <span class="number">999_999_999</span>);
<span class="macro">assert_eq!</span>(Time::MAX, t.saturating_add(<span class="number">1</span>.nanoseconds()));
<span class="macro">assert_eq!</span>(Time::MAX, t.saturating_add(SignedDuration::MAX));
<span class="macro">assert_eq!</span>(Time::MIN, t.saturating_add(SignedDuration::MIN));
<span class="macro">assert_eq!</span>(Time::MAX, t.saturating_add(std::time::Duration::MAX));
</code></pre></div>
<p>Similarly, if there are any non-zero units greater than hours in the
given span, then they also result in overflow (and thus saturation):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{Time, time}, ToSpan};

<span class="comment">// doesn't matter what our time value is in this example
</span><span class="kw">let </span>t = time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(Time::MAX, t.saturating_add(<span class="number">1</span>.days()));</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.saturating_sub" class="method"><h4 class="code-header">pub fn <a href="#method.saturating_sub" class="fn">saturating_sub</a>&lt;A&gt;(self, duration: A) -&gt; <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a><div class="where">where
    A: <a class="trait" href="../../../code/trait.Into.html" title="trait devela::code::Into">Into</a>&lt;<a class="struct" href="struct.TimeArithmetic.html" title="struct devela::_dep::jiff::civil::TimeArithmetic">TimeArithmetic</a>&gt;,</div></h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Time.html#method.saturating_add" title="method devela::_dep::jiff::civil::Time::saturating_add"><code>Time::saturating_add</code></a> with the duration
negated.</p>
<h5 id="example-16"><a class="doc-anchor" href="#example-16">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{Time, time}, SignedDuration, ToSpan};

<span class="comment">// no saturation
</span><span class="kw">let </span>t = time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);
<span class="macro">assert_eq!</span>(
    t.with().nanosecond(<span class="number">0</span>).build()<span class="question-mark">?</span>,
    t.saturating_sub(<span class="number">1</span>.nanoseconds()),
);

<span class="comment">// saturates
</span><span class="kw">let </span>t = time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(Time::MIN, t.saturating_sub(<span class="number">1</span>.nanoseconds()));
<span class="macro">assert_eq!</span>(Time::MIN, t.saturating_sub(SignedDuration::MAX));
<span class="macro">assert_eq!</span>(Time::MAX, t.saturating_sub(SignedDuration::MIN));
<span class="macro">assert_eq!</span>(Time::MIN, t.saturating_sub(std::time::Duration::MAX));
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.until" class="method"><h4 class="code-header">pub fn <a href="#method.until" class="fn">until</a>&lt;A&gt;(self, other: A) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;<a class="struct" href="../struct.Span.html" title="struct devela::_dep::jiff::Span">Span</a>, <a class="struct" href="../struct.Error.html" title="struct devela::_dep::jiff::Error">Error</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;Span, Error&gt;">ⓘ</a><div class="where">where
    A: <a class="trait" href="../../../code/trait.Into.html" title="trait devela::code::Into">Into</a>&lt;<a class="struct" href="struct.TimeDifference.html" title="struct devela::_dep::jiff::civil::TimeDifference">TimeDifference</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Returns a span representing the elapsed time from this time until
the given <code>other</code> time.</p>
<p>When <code>other</code> is earlier than this time, the span returned will be
negative.</p>
<p>Depending on the input provided, the span returned is rounded. It may
also be balanced down to smaller units than the default. By default,
the span returned is balanced such that the biggest possible unit is
hours.</p>
<p>This operation is configured by providing a <a href="struct.TimeDifference.html" title="struct devela::_dep::jiff::civil::TimeDifference"><code>TimeDifference</code></a>
value. Since this routine accepts anything that implements
<code>Into&lt;TimeDifference&gt;</code>, once can pass a <code>Time</code> directly. One
can also pass a <code>(Unit, Time)</code>, where <code>Unit</code> is treated as
<a href="struct.TimeDifference.html#method.largest" title="method devela::_dep::jiff::civil::TimeDifference::largest"><code>TimeDifference::largest</code></a>.</p>
<h5 id="properties-2"><a class="doc-anchor" href="#properties-2">§</a>Properties</h5>
<p>As long as no rounding is requested, it is guaranteed that adding the
span returned to the <code>other</code> time will always equal this time.</p>
<h5 id="errors-3"><a class="doc-anchor" href="#errors-3">§</a>Errors</h5>
<p>An error can occur if <code>TimeDifference</code> is misconfigured. For example,
if the smallest unit provided is bigger than the largest unit, or if
the largest unit is bigger than <a href="../enum.Unit.html#variant.Hour" title="variant devela::_dep::jiff::Unit::Hour"><code>Unit::Hour</code></a>.</p>
<p>It is guaranteed that if one provides a time with the default
<a href="struct.TimeDifference.html" title="struct devela::_dep::jiff::civil::TimeDifference"><code>TimeDifference</code></a> configuration, then this routine will never fail.</p>
<h5 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>t1 = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="kw">let </span>t2 = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">3</span>, <span class="number">500_000_000</span>);
<span class="macro">assert_eq!</span>(t1.until(t2)<span class="question-mark">?</span>, <span class="number">2</span>.seconds().milliseconds(<span class="number">500</span>).fieldwise());
<span class="comment">// Flipping the dates is fine, but you'll get a negative span.
</span><span class="macro">assert_eq!</span>(t2.until(t1)<span class="question-mark">?</span>, -<span class="number">2</span>.seconds().milliseconds(<span class="number">500</span>).fieldwise());
</code></pre></div>
<h5 id="example-using-smaller-units"><a class="doc-anchor" href="#example-using-smaller-units">§</a>Example: using smaller units</h5>
<p>This example shows how to contract the span returned to smaller units.
This makes use of a <code>From&lt;(Unit, Time)&gt; for TimeDifference</code>
trait implementation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, Unit, ToSpan};

<span class="kw">let </span>t1 = time(<span class="number">3</span>, <span class="number">24</span>, <span class="number">30</span>, <span class="number">3500</span>);
<span class="kw">let </span>t2 = time(<span class="number">15</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);

<span class="comment">// The default limits spans to using "hours" as the biggest unit.
</span><span class="kw">let </span>span = t1.until(t2)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"PT12H5M29.9999965S"</span>);

<span class="comment">// But we can ask for smaller units, like capping the biggest unit
// to minutes instead of hours.
</span><span class="kw">let </span>span = t1.until((Unit::Minute, t2))<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(span.to_string(), <span class="string">"PT725M29.9999965S"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.since" class="method"><h4 class="code-header">pub fn <a href="#method.since" class="fn">since</a>&lt;A&gt;(self, other: A) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;<a class="struct" href="../struct.Span.html" title="struct devela::_dep::jiff::Span">Span</a>, <a class="struct" href="../struct.Error.html" title="struct devela::_dep::jiff::Error">Error</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;Span, Error&gt;">ⓘ</a><div class="where">where
    A: <a class="trait" href="../../../code/trait.Into.html" title="trait devela::code::Into">Into</a>&lt;<a class="struct" href="struct.TimeDifference.html" title="struct devela::_dep::jiff::civil::TimeDifference">TimeDifference</a>&gt;,</div></h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Time.html#method.until" title="method devela::_dep::jiff::civil::Time::until"><code>Time::until</code></a>, but the order of the
parameters is flipped.</p>
<h5 id="errors-4"><a class="doc-anchor" href="#errors-4">§</a>Errors</h5>
<p>This has the same error conditions as <a href="struct.Time.html#method.until" title="method devela::_dep::jiff::civil::Time::until"><code>Time::until</code></a>.</p>
<h5 id="example-17"><a class="doc-anchor" href="#example-17">§</a>Example</h5>
<p>This routine can be used via the <code>-</code> operator. Since the default
configuration is used and because a <code>Span</code> can represent the difference
between any two possible times, it will never panic.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, ToSpan};

<span class="kw">let </span>earlier = time(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>later = time(<span class="number">22</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(later - earlier, <span class="number">21</span>.hours().minutes(<span class="number">30</span>).fieldwise());</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.duration_until" class="method"><h4 class="code-header">pub fn <a href="#method.duration_until" class="fn">duration_until</a>(self, other: <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a>) -&gt; <a class="struct" href="../struct.SignedDuration.html" title="struct devela::_dep::jiff::SignedDuration">SignedDuration</a></h4></section></summary><div class="docblock"><p>Returns an absolute duration representing the elapsed time from this
time until the given <code>other</code> time.</p>
<p>When <code>other</code> occurs before this time, then the duration returned will
be negative.</p>
<p>Unlike <a href="struct.Time.html#method.until" title="method devela::_dep::jiff::civil::Time::until"><code>Time::until</code></a>, this returns a duration corresponding to a
96-bit integer of nanoseconds between two times. In this case of
computing durations between civil times where all days are assumed to
be 24 hours long, the duration returned will always be less than 24
hours.</p>
<h5 id="fallibility"><a class="doc-anchor" href="#fallibility">§</a>Fallibility</h5>
<p>This routine never panics or returns an error. Since there are no
configuration options that can be incorrectly provided, no error is
possible when calling this routine. In contrast, <a href="struct.Time.html#method.until" title="method devela::_dep::jiff::civil::Time::until"><code>Time::until</code></a> can
return an error in some cases due to misconfiguration. But like this
routine, <a href="struct.Time.html#method.until" title="method devela::_dep::jiff::civil::Time::until"><code>Time::until</code></a> never panics or returns an error in its
default configuration.</p>
<h5 id="when-should-i-use-this-versus-timeuntil"><a class="doc-anchor" href="#when-should-i-use-this-versus-timeuntil">§</a>When should I use this versus <a href="struct.Time.html#method.until" title="method devela::_dep::jiff::civil::Time::until"><code>Time::until</code></a>?</h5>
<p>See the type documentation for <a href="../struct.SignedDuration.html" title="struct devela::_dep::jiff::SignedDuration"><code>SignedDuration</code></a> for the section on
when one should use <a href="../struct.Span.html" title="struct devela::_dep::jiff::Span"><code>Span</code></a> and when one should use <code>SignedDuration</code>.
In short, use <code>Span</code> (and therefore <code>Time::until</code>) unless you have a
specific reason to do otherwise.</p>
<h5 id="example-18"><a class="doc-anchor" href="#example-18">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, SignedDuration};

<span class="kw">let </span>t1 = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="kw">let </span>t2 = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">3</span>, <span class="number">500_000_000</span>);
<span class="macro">assert_eq!</span>(t1.duration_until(t2), SignedDuration::new(<span class="number">2</span>, <span class="number">500_000_000</span>));
<span class="comment">// Flipping the time is fine, but you'll get a negative duration.
</span><span class="macro">assert_eq!</span>(t2.duration_until(t1), -SignedDuration::new(<span class="number">2</span>, <span class="number">500_000_000</span>));</code></pre></div>
<h5 id="example-difference-with-timeuntil"><a class="doc-anchor" href="#example-difference-with-timeuntil">§</a>Example: difference with <a href="struct.Time.html#method.until" title="method devela::_dep::jiff::civil::Time::until"><code>Time::until</code></a></h5>
<p>Since the difference between two civil times is always expressed in
units of hours or smaller, and units of hours or smaller are always
uniform, there is no “expressive” difference between this routine and
<code>Time::until</code>. The only difference is that this routine returns a
<code>SignedDuration</code> and <code>Time::until</code> returns a <a href="../struct.Span.html" title="struct devela::_dep::jiff::Span"><code>Span</code></a>. Moreover, since
the difference is always less than 24 hours, the return values can
always be infallibly and losslessly converted between each other:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, SignedDuration, Span};

<span class="kw">let </span>t1 = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="kw">let </span>t2 = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">3</span>, <span class="number">500_000_000</span>);
<span class="kw">let </span>dur = t1.duration_until(t2);
<span class="comment">// Guaranteed to never fail because the duration
// between two civil times never exceeds the limits
// of a `Span`.
</span><span class="kw">let </span>span = Span::try_from(dur).unwrap();
<span class="macro">assert_eq!</span>(span, Span::new().seconds(<span class="number">2</span>).milliseconds(<span class="number">500</span>).fieldwise());
<span class="comment">// Guaranteed to succeed and always return the original
// duration because the units are always hours or smaller,
// and thus uniform. This means a relative datetime is
// never required to do this conversion.
</span><span class="kw">let </span>dur = SignedDuration::try_from(span).unwrap();
<span class="macro">assert_eq!</span>(dur, SignedDuration::new(<span class="number">2</span>, <span class="number">500_000_000</span>));</code></pre></div>
<p>This conversion guarantee also applies to <a href="struct.Time.html#method.until" title="method devela::_dep::jiff::civil::Time::until"><code>Time::until</code></a> since it
always returns a balanced span. That is, it never returns spans like
<code>1 second 1000 milliseconds</code>. (Those cannot be losslessly converted to
a <code>SignedDuration</code> since a <code>SignedDuration</code> is only represented as a
single 96-bit integer of nanoseconds.)</p>
<h5 id="example-getting-an-unsigned-duration"><a class="doc-anchor" href="#example-getting-an-unsigned-duration">§</a>Example: getting an unsigned duration</h5>
<p>If you’re looking to find the duration between two times as a
<a href="../../../all/struct.Duration.html" title="struct devela::all::Duration"><code>std::time::Duration</code></a>, you’ll need to use this method to get a
<a href="../struct.SignedDuration.html" title="struct devela::_dep::jiff::SignedDuration"><code>SignedDuration</code></a> and then convert it to a <code>std::time::Duration</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::time::Duration;

<span class="kw">use </span>jiff::{civil::time, SignedDuration, Span};

<span class="kw">let </span>t1 = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">1</span>, <span class="number">0</span>);
<span class="kw">let </span>t2 = time(<span class="number">22</span>, <span class="number">35</span>, <span class="number">3</span>, <span class="number">500_000_000</span>);
<span class="kw">let </span>dur = Duration::try_from(t1.duration_until(t2))<span class="question-mark">?</span>;;
<span class="macro">assert_eq!</span>(dur, Duration::new(<span class="number">2</span>, <span class="number">500_000_000</span>));

<span class="comment">// Note that unsigned durations cannot represent all
// possible differences! If the duration would be negative,
// then the conversion fails:
</span><span class="macro">assert!</span>(Duration::try_from(t2.duration_until(t1)).is_err());
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.duration_since" class="method"><h4 class="code-header">pub fn <a href="#method.duration_since" class="fn">duration_since</a>(self, other: <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a>) -&gt; <a class="struct" href="../struct.SignedDuration.html" title="struct devela::_dep::jiff::SignedDuration">SignedDuration</a></h4></section></summary><div class="docblock"><p>This routine is identical to <a href="struct.Time.html#method.duration_until" title="method devela::_dep::jiff::civil::Time::duration_until"><code>Time::duration_until</code></a>, but the order of
the parameters is flipped.</p>
<h5 id="example-19"><a class="doc-anchor" href="#example-19">§</a>Example</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, SignedDuration};

<span class="kw">let </span>earlier = time(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>later = time(<span class="number">22</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(
    later.duration_since(earlier),
    SignedDuration::from_secs((<span class="number">21 </span>* <span class="number">60 </span>* <span class="number">60</span>) + (<span class="number">30 </span>* <span class="number">60</span>)),
);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.round" class="method"><h4 class="code-header">pub fn <a href="#method.round" class="fn">round</a>&lt;R&gt;(self, options: R) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;<a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a>, <a class="struct" href="../struct.Error.html" title="struct devela::_dep::jiff::Error">Error</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;Time, Error&gt;">ⓘ</a><div class="where">where
    R: <a class="trait" href="../../../code/trait.Into.html" title="trait devela::code::Into">Into</a>&lt;<a class="struct" href="struct.TimeRound.html" title="struct devela::_dep::jiff::civil::TimeRound">TimeRound</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Rounds this time according to the <a href="struct.TimeRound.html" title="struct devela::_dep::jiff::civil::TimeRound"><code>TimeRound</code></a> configuration given.</p>
<p>The principal option is <a href="struct.TimeRound.html#method.smallest" title="method devela::_dep::jiff::civil::TimeRound::smallest"><code>TimeRound::smallest</code></a>, which allows one
to configure the smallest units in the returned time. Rounding
is what determines whether that unit should keep its current value
or whether it should be incremented. Moreover, the amount it should
be incremented can be configured via <a href="struct.TimeRound.html#method.increment" title="method devela::_dep::jiff::civil::TimeRound::increment"><code>TimeRound::increment</code></a>.
Finally, the rounding strategy itself can be configured via
<a href="struct.TimeRound.html#method.mode" title="method devela::_dep::jiff::civil::TimeRound::mode"><code>TimeRound::mode</code></a>.</p>
<p>Note that this routine is generic and accepts anything that
implements <code>Into&lt;TimeRound&gt;</code>. Some notable implementations are:</p>
<ul>
<li><code>From&lt;Unit&gt; for Round</code>, which will automatically create a
<code>TimeRound::new().smallest(unit)</code> from the unit provided.</li>
<li><code>From&lt;(Unit, i64)&gt; for Round</code>, which will automatically create a
<code>TimeRound::new().smallest(unit).increment(number)</code> from the unit
and increment provided.</li>
</ul>
<h5 id="errors-5"><a class="doc-anchor" href="#errors-5">§</a>Errors</h5>
<p>This returns an error if the smallest unit configured on the given
<a href="struct.TimeRound.html" title="struct devela::_dep::jiff::civil::TimeRound"><code>TimeRound</code></a> is bigger than hours.</p>
<p>The rounding increment must divide evenly into the next highest unit
after the smallest unit configured (and must not be equivalent to it).
For example, if the smallest unit is <a href="../enum.Unit.html#variant.Nanosecond" title="variant devela::_dep::jiff::Unit::Nanosecond"><code>Unit::Nanosecond</code></a>, then <em>some</em>
of the valid values for the rounding increment are <code>1</code>, <code>2</code>, <code>4</code>, <code>5</code>,
<code>100</code> and <code>500</code>. Namely, any integer that divides evenly into <code>1,000</code>
nanoseconds since there are <code>1,000</code> nanoseconds in the next highest
unit (microseconds).</p>
<p>This can never fail because of overflow for any input. The only
possible errors are “configuration” errors.</p>
<h5 id="example-20"><a class="doc-anchor" href="#example-20">§</a>Example</h5>
<p>This is a basic example that demonstrates rounding a datetime to the
nearest second. This also demonstrates calling this method with the
smallest unit directly, instead of constructing a <code>TimeRound</code> manually.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, Unit};

<span class="kw">let </span>t = time(<span class="number">15</span>, <span class="number">45</span>, <span class="number">10</span>, <span class="number">123_456_789</span>);
<span class="macro">assert_eq!</span>(
    t.round(Unit::Second)<span class="question-mark">?</span>,
    time(<span class="number">15</span>, <span class="number">45</span>, <span class="number">10</span>, <span class="number">0</span>),
);
<span class="kw">let </span>t = time(<span class="number">15</span>, <span class="number">45</span>, <span class="number">10</span>, <span class="number">500_000_001</span>);
<span class="macro">assert_eq!</span>(
    t.round(Unit::Second)<span class="question-mark">?</span>,
    time(<span class="number">15</span>, <span class="number">45</span>, <span class="number">11</span>, <span class="number">0</span>),
);
</code></pre></div>
<h5 id="example-changing-the-rounding-mode"><a class="doc-anchor" href="#example-changing-the-rounding-mode">§</a>Example: changing the rounding mode</h5>
<p>The default rounding mode is <a href="../enum.RoundMode.html#variant.HalfExpand" title="variant devela::_dep::jiff::RoundMode::HalfExpand"><code>RoundMode::HalfExpand</code></a>, which
breaks ties by rounding away from zero. But other modes like
<a href="../enum.RoundMode.html#variant.Trunc" title="variant devela::_dep::jiff::RoundMode::Trunc"><code>RoundMode::Trunc</code></a> can be used too:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{TimeRound, time}, RoundMode, Unit};

<span class="kw">let </span>t = time(<span class="number">15</span>, <span class="number">45</span>, <span class="number">10</span>, <span class="number">999_999_999</span>);
<span class="macro">assert_eq!</span>(
    t.round(Unit::Second)<span class="question-mark">?</span>,
    time(<span class="number">15</span>, <span class="number">45</span>, <span class="number">11</span>, <span class="number">0</span>),
);
<span class="comment">// The default will round up to the next second for any fraction
// greater than or equal to 0.5. But truncation will always round
// toward zero.
</span><span class="macro">assert_eq!</span>(
    t.round(
        TimeRound::new().smallest(Unit::Second).mode(RoundMode::Trunc),
    )<span class="question-mark">?</span>,
    time(<span class="number">15</span>, <span class="number">45</span>, <span class="number">10</span>, <span class="number">0</span>),
);
</code></pre></div>
<h5 id="example-rounding-to-the-nearest-5-minute-increment"><a class="doc-anchor" href="#example-rounding-to-the-nearest-5-minute-increment">§</a>Example: rounding to the nearest 5 minute increment</h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, Unit};

<span class="comment">// rounds down
</span><span class="kw">let </span>t = time(<span class="number">15</span>, <span class="number">27</span>, <span class="number">29</span>, <span class="number">999_999_999</span>);
<span class="macro">assert_eq!</span>(t.round((Unit::Minute, <span class="number">5</span>))<span class="question-mark">?</span>, time(<span class="number">15</span>, <span class="number">25</span>, <span class="number">0</span>, <span class="number">0</span>));
<span class="comment">// rounds up
</span><span class="kw">let </span>t = time(<span class="number">15</span>, <span class="number">27</span>, <span class="number">30</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(t.round((Unit::Minute, <span class="number">5</span>))<span class="question-mark">?</span>, time(<span class="number">15</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>));
</code></pre></div>
<h5 id="example-rounding-wraps-around-on-overflow"><a class="doc-anchor" href="#example-rounding-wraps-around-on-overflow">§</a>Example: rounding wraps around on overflow</h5>
<p>This example demonstrates that it’s possible for this operation to
overflow, and as a result, have the time wrap around.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::Time, Unit};

<span class="kw">let </span>t = Time::MAX;
<span class="macro">assert_eq!</span>(t.round(Unit::Hour)<span class="question-mark">?</span>, Time::MIN);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.series" class="method"><h4 class="code-header">pub fn <a href="#method.series" class="fn">series</a>(self, period: <a class="struct" href="../struct.Span.html" title="struct devela::_dep::jiff::Span">Span</a>) -&gt; <a class="struct" href="struct.TimeSeries.html" title="struct devela::_dep::jiff::civil::TimeSeries">TimeSeries</a> <a href="#" class="tooltip" data-notable-ty="TimeSeries">ⓘ</a></h4></section></summary><div class="docblock"><p>Return an iterator of periodic times determined by the given span.</p>
<p>The given span may be negative, in which case, the iterator will move
backwards through time. The iterator won’t stop until either the span
itself overflows, or it would otherwise exceed the minimum or maximum
<code>Time</code> value.</p>
<h5 id="example-visiting-every-third-hour"><a class="doc-anchor" href="#example-visiting-every-third-hour">§</a>Example: visiting every third hour</h5>
<p>This shows how to visit each third hour of a 24 hour time interval:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{Time, time}, ToSpan};

<span class="kw">let </span>start = Time::MIN;
<span class="kw">let </span><span class="kw-2">mut </span>every_third_hour = <span class="macro">vec!</span>[];
<span class="kw">for </span>t <span class="kw">in </span>start.series(<span class="number">3</span>.hours()) {
    every_third_hour.push(t);
}
<span class="macro">assert_eq!</span>(every_third_hour, <span class="macro">vec!</span>[
    time(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">12</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">18</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">21</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
]);</code></pre></div>
<p>Or go backwards every 6.5 hours:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::{Time, time}, ToSpan};

<span class="kw">let </span>start = time(<span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="kw">let </span>times: Vec&lt;Time&gt; = start.series(-<span class="number">6</span>.hours().minutes(<span class="number">30</span>)).collect();
<span class="macro">assert_eq!</span>(times, <span class="macro">vec!</span>[
    time(<span class="number">23</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">16</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),
    time(<span class="number">3</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">0</span>),
]);</code></pre></div>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Time-1" class="impl"><a href="#impl-Time-1" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3><div class="docblock"><p>Parsing and formatting using a “printf”-style API.</p>
</div></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.strptime" class="method"><h4 class="code-header">pub fn <a href="#method.strptime" class="fn">strptime</a>(
    format: impl <a class="trait" href="../../../code/trait.AsRef.html" title="trait devela::code::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;,
    input: impl <a class="trait" href="../../../code/trait.AsRef.html" title="trait devela::code::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt;,
) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;<a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a>, <a class="struct" href="../struct.Error.html" title="struct devela::_dep::jiff::Error">Error</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;Time, Error&gt;">ⓘ</a></h4></section></summary><div class="docblock"><p>Parses a civil time in <code>input</code> matching the given <code>format</code>.</p>
<p>The format string uses a “printf”-style API where conversion
specifiers can be used as place holders to match components of
a datetime. For details on the specifiers supported, see the
<a href="../fmt/strtime/index.html" title="mod devela::_dep::jiff::fmt::strtime"><code>fmt::strtime</code></a> module documentation.</p>
<h5 id="errors-6"><a class="doc-anchor" href="#errors-6">§</a>Errors</h5>
<p>This returns an error when parsing failed. This might happen because
the format string itself was invalid, or because the input didn’t match
the format string.</p>
<p>This also returns an error if there wasn’t sufficient information to
construct a civil time. For example, if an offset wasn’t parsed.</p>
<h5 id="example-21"><a class="doc-anchor" href="#example-21">§</a>Example</h5>
<p>This example shows how to parse a civil time:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::Time;

<span class="comment">// Parse with a 12-hour clock.
</span><span class="kw">let </span>time = Time::strptime(<span class="string">"%I:%M%P"</span>, <span class="string">"4:30pm"</span>)<span class="question-mark">?</span>;
<span class="macro">assert_eq!</span>(time.to_string(), <span class="string">"16:30:00"</span>);
</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.strftime" class="method"><h4 class="code-header">pub fn <a href="#method.strftime" class="fn">strftime</a>&lt;'f, F&gt;(&amp;self, format: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'f F</a>) -&gt; <a class="struct" href="../fmt/strtime/struct.Display.html" title="struct devela::_dep::jiff::fmt::strtime::Display">Display</a>&lt;'f&gt;<div class="where">where
    F: 'f + <a class="trait" href="../../../code/trait.AsRef.html" title="trait devela::code::AsRef">AsRef</a>&lt;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]&gt; + ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class="docblock"><p>Formats this civil time according to the given <code>format</code>.</p>
<p>The format string uses a “printf”-style API where conversion
specifiers can be used as place holders to format components of
a datetime. For details on the specifiers supported, see the
<a href="../fmt/strtime/index.html" title="mod devela::_dep::jiff::fmt::strtime"><code>fmt::strtime</code></a> module documentation.</p>
<h5 id="errors-and-panics"><a class="doc-anchor" href="#errors-and-panics">§</a>Errors and panics</h5>
<p>While this routine itself does not error or panic, using the value
returned may result in a panic if formatting fails. See the
documentation on <a href="../fmt/strtime/struct.Display.html" title="struct devela::_dep::jiff::fmt::strtime::Display"><code>fmt::strtime::Display</code></a> for more information.</p>
<p>To format in a way that surfaces errors without panicking, use either
<a href="../fmt/strtime/fn.format.html" title="fn devela::_dep::jiff::fmt::strtime::format"><code>fmt::strtime::format</code></a> or <a href="../fmt/strtime/struct.BrokenDownTime.html#method.format" title="method devela::_dep::jiff::fmt::strtime::BrokenDownTime::format"><code>fmt::strtime::BrokenDownTime::format</code></a>.</p>
<h5 id="example-22"><a class="doc-anchor" href="#example-22">§</a>Example</h5>
<p>This example shows how to format a civil time in a 12 hour clock with
no padding for the hour:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">16</span>, <span class="number">30</span>, <span class="number">59</span>, <span class="number">0</span>);
<span class="kw">let </span>string = t.strftime(<span class="string">"%-I:%M%P"</span>).to_string();
<span class="macro">assert_eq!</span>(string, <span class="string">"4:30pm"</span>);</code></pre></div>
<p>Note that one can round a <code>Time</code> before formatting. For example, to
round to the nearest minute:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::{civil::time, Unit};

<span class="kw">let </span>t = time(<span class="number">16</span>, <span class="number">30</span>, <span class="number">59</span>, <span class="number">0</span>);
<span class="kw">let </span>string = t.round(Unit::Minute)<span class="question-mark">?</span>.strftime(<span class="string">"%-I:%M%P"</span>).to_string();
<span class="macro">assert_eq!</span>(string, <span class="string">"4:31pm"</span>);
</code></pre></div>
</div></details></div></details><section id="impl-Time-2" class="impl"><a href="#impl-Time-2" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3><div class="item-info"><div class="stab empty-impl">This impl block contains no items.</div></div><div class="docblock"><p>Crate internal APIs.</p>
</div></section><div class="docblock"><p>Many of these are mirrors of the public API, but on ranged types. These
are often much more convenient to use in composition with other parts of
the crate that also use ranged integer types. And this often permits the
routines to be infallible and (possibly) zero-cost.</p>
</div></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CDuration%3E-for-Time" class="impl"><a href="#impl-Add%3CDuration%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.Add.html" title="trait devela::all::Add">Add</a>&lt;<a class="struct" href="../../../all/struct.Duration.html" title="struct devela::all::Duration">Duration</a>&gt; for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3><div class="docblock"><p>Adds an unsigned duration of time. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_add" title="method devela::_dep::jiff::civil::Time::checked_add"><code>Time::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-2" class="associatedtype trait-impl"><a href="#associatedtype.Output-2" class="anchor">§</a><h4 class="code-header">type <a href="../../../all/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-2" class="method trait-impl"><a href="#method.add-2" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="../../../all/struct.Duration.html" title="struct devela::all::Duration">Duration</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="../../../all/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CSignedDuration%3E-for-Time" class="impl"><a href="#impl-Add%3CSignedDuration%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.Add.html" title="trait devela::all::Add">Add</a>&lt;<a class="struct" href="../struct.SignedDuration.html" title="struct devela::_dep::jiff::SignedDuration">SignedDuration</a>&gt; for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3><div class="docblock"><p>Adds a signed duration of time. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_add" title="method devela::_dep::jiff::civil::Time::checked_add"><code>Time::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-1" class="associatedtype trait-impl"><a href="#associatedtype.Output-1" class="anchor">§</a><h4 class="code-header">type <a href="../../../all/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add-1" class="method trait-impl"><a href="#method.add-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="../struct.SignedDuration.html" title="struct devela::_dep::jiff::SignedDuration">SignedDuration</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="../../../all/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Add%3CSpan%3E-for-Time" class="impl"><a href="#impl-Add%3CSpan%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.Add.html" title="trait devela::all::Add">Add</a>&lt;<a class="struct" href="../struct.Span.html" title="struct devela::_dep::jiff::Span">Span</a>&gt; for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3><div class="docblock"><p>Adds a span of time. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_add" title="method devela::_dep::jiff::civil::Time::checked_add"><code>Time::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output" class="associatedtype trait-impl"><a href="#associatedtype.Output" class="anchor">§</a><h4 class="code-header">type <a href="../../../all/trait.Add.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>+</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.add" class="method trait-impl"><a href="#method.add" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.Add.html#tymethod.add" class="fn">add</a>(self, rhs: <a class="struct" href="../struct.Span.html" title="struct devela::_dep::jiff::Span">Span</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>Performs the <code>+</code> operation. <a href="../../../all/trait.Add.html#tymethod.add">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CDuration%3E-for-Time" class="impl"><a href="#impl-AddAssign%3CDuration%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.AddAssign.html" title="trait devela::all::AddAssign">AddAssign</a>&lt;<a class="struct" href="../../../all/struct.Duration.html" title="struct devela::all::Duration">Duration</a>&gt; for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3><div class="docblock"><p>Adds an unsigned duration of time in place. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_add" title="method devela::_dep::jiff::civil::Time::checked_add"><code>Time::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign-2" class="method trait-impl"><a href="#method.add_assign-2" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: <a class="struct" href="../../../all/struct.Duration.html" title="struct devela::all::Duration">Duration</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="../../../all/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CSignedDuration%3E-for-Time" class="impl"><a href="#impl-AddAssign%3CSignedDuration%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.AddAssign.html" title="trait devela::all::AddAssign">AddAssign</a>&lt;<a class="struct" href="../struct.SignedDuration.html" title="struct devela::_dep::jiff::SignedDuration">SignedDuration</a>&gt; for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3><div class="docblock"><p>Adds a signed duration of time in place. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_add" title="method devela::_dep::jiff::civil::Time::checked_add"><code>Time::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign-1" class="method trait-impl"><a href="#method.add_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: <a class="struct" href="../struct.SignedDuration.html" title="struct devela::_dep::jiff::SignedDuration">SignedDuration</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="../../../all/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-AddAssign%3CSpan%3E-for-Time" class="impl"><a href="#impl-AddAssign%3CSpan%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.AddAssign.html" title="trait devela::all::AddAssign">AddAssign</a>&lt;<a class="struct" href="../struct.Span.html" title="struct devela::_dep::jiff::Span">Span</a>&gt; for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3><div class="docblock"><p>Adds a span of time in place. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_add" title="method devela::_dep::jiff::civil::Time::checked_add"><code>Time::checked_add</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.add_assign" class="method trait-impl"><a href="#method.add_assign" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.AddAssign.html#tymethod.add_assign" class="fn">add_assign</a>(&amp;mut self, rhs: <a class="struct" href="../struct.Span.html" title="struct devela::_dep::jiff::Span">Span</a>)</h4></section></summary><div class='docblock'>Performs the <code>+=</code> operation. <a href="../../../all/trait.AddAssign.html#tymethod.add_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Time" class="impl"><a href="#impl-Clone-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../code/trait.Clone.html" title="trait devela::code::Clone">Clone</a> for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="../../../code/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>Returns a duplicate of the value. <a href="../../../code/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#246-248">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="../../../code/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="../../../code/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Time" class="impl"><a href="#impl-Debug-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.Debug.html" title="trait devela::all::Debug">Debug</a> for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3><div class="docblock"><p>Converts a <code>Time</code> into a human readable time string.</p>
</div></section></summary><div class="docblock"><p>(This <code>Debug</code> representation currently emits the same string as the
<code>Display</code> representation, but this is not a guarantee.)</p>
<p>Options currently supported:</p>
<ul>
<li><a href="../../../all/struct.Formatter.html#method.precision" title="method devela::all::Formatter::precision"><code>std::fmt::Formatter::precision</code></a> can be set to control the precision
of the fractional second component.</li>
</ul>
<h4 id="example-23"><a class="doc-anchor" href="#example-23">§</a>Example</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">123_000_000</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{t:.6?}"</span>), <span class="string">"07:00:00.123000"</span>);
<span class="comment">// Precision values greater than 9 are clamped to 9.
</span><span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{t:.300?}"</span>), <span class="string">"07:00:00.123000000"</span>);
<span class="comment">// A precision of 0 implies the entire fractional
// component is always truncated.
</span><span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{t:.0?}"</span>), <span class="string">"07:00:00"</span>);
</code></pre></div>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../../../all/struct.Formatter.html" title="struct devela::all::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="../../../all/struct.FmtError.html" title="struct devela::all::FmtError">Error</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;(), Error&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="../../../all/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Default-for-Time" class="impl"><a href="#impl-Default-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../code/trait.Default.html" title="trait devela::code::Default">Default</a> for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.default" class="method trait-impl"><a href="#method.default" class="anchor">§</a><h4 class="code-header">fn <a href="../../../code/trait.Default.html#tymethod.default" class="fn">default</a>() -&gt; <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>Returns the “default value” for a type. <a href="../../../code/trait.Default.html#tymethod.default">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Display-for-Time" class="impl"><a href="#impl-Display-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.Display.html" title="trait devela::all::Display">Display</a> for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3><div class="docblock"><p>Converts a <code>Time</code> into an ISO 8601 compliant string.</p>
</div></section></summary><div class="docblock"><h4 id="formatting-options-supported"><a class="doc-anchor" href="#formatting-options-supported">§</a>Formatting options supported</h4>
<ul>
<li><a href="../../../all/struct.Formatter.html#method.precision" title="method devela::all::Formatter::precision"><code>std::fmt::Formatter::precision</code></a> can be set to control the precision
of the fractional second component. When not set, the minimum precision
required to losslessly render the value is used.</li>
</ul>
<h4 id="example-24"><a class="doc-anchor" href="#example-24">§</a>Example</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="comment">// No fractional seconds:
</span><span class="kw">let </span>t = time(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{t}"</span>), <span class="string">"07:00:00"</span>);

<span class="comment">// With fractional seconds:
</span><span class="kw">let </span>t = time(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">123_000_000</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{t}"</span>), <span class="string">"07:00:00.123"</span>);
</code></pre></div>
<h4 id="example-setting-the-precision"><a class="doc-anchor" href="#example-setting-the-precision">§</a>Example: setting the precision</h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>jiff::civil::time;

<span class="kw">let </span>t = time(<span class="number">7</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">123_000_000</span>);
<span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{t:.6}"</span>), <span class="string">"07:00:00.123000"</span>);
<span class="comment">// Precision values greater than 9 are clamped to 9.
</span><span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{t:.300}"</span>), <span class="string">"07:00:00.123000000"</span>);
<span class="comment">// A precision of 0 implies the entire fractional
// component is always truncated.
</span><span class="macro">assert_eq!</span>(<span class="macro">format!</span>(<span class="string">"{t:.0}"</span>), <span class="string">"07:00:00"</span>);
</code></pre></div>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt-1" class="method trait-impl"><a href="#method.fmt-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.Display.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../../../all/struct.Formatter.html" title="struct devela::all::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="../../../all/struct.FmtError.html" title="struct devela::all::FmtError">Error</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;(), Error&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="../../../all/trait.Display.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3C%26Zoned%3E-for-Time" class="impl"><a href="#impl-From%3C%26Zoned%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl&lt;'a&gt; <a class="trait" href="../../../code/trait.From.html" title="trait devela::code::From">From</a>&lt;&amp;'a <a class="struct" href="../struct.Zoned.html" title="struct devela::_dep::jiff::Zoned">Zoned</a>&gt; for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-2" class="method trait-impl"><a href="#method.from-2" class="anchor">§</a><h4 class="code-header">fn <a href="../../../code/trait.From.html#tymethod.from" class="fn">from</a>(zdt: &amp;'a <a class="struct" href="../struct.Zoned.html" title="struct devela::_dep::jiff::Zoned">Zoned</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CDateTime%3E-for-Time" class="impl"><a href="#impl-From%3CDateTime%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../code/trait.From.html" title="trait devela::code::From">From</a>&lt;<a class="struct" href="struct.DateTime.html" title="struct devela::_dep::jiff::civil::DateTime">DateTime</a>&gt; for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="../../../code/trait.From.html#tymethod.from" class="fn">from</a>(dt: <a class="struct" href="struct.DateTime.html" title="struct devela::_dep::jiff::civil::DateTime">DateTime</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CTime%3E-for-BrokenDownTime" class="impl"><a href="#impl-From%3CTime%3E-for-BrokenDownTime" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../code/trait.From.html" title="trait devela::code::From">From</a>&lt;<a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a>&gt; for <a class="struct" href="../fmt/strtime/struct.BrokenDownTime.html" title="struct devela::_dep::jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-4" class="method trait-impl"><a href="#method.from-4" class="anchor">§</a><h4 class="code-header">fn <a href="../../../code/trait.From.html#tymethod.from" class="fn">from</a>(t: <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a>) -&gt; <a class="struct" href="../fmt/strtime/struct.BrokenDownTime.html" title="struct devela::_dep::jiff::fmt::strtime::BrokenDownTime">BrokenDownTime</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CTime%3E-for-Meridiem" class="impl"><a href="#impl-From%3CTime%3E-for-Meridiem" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../code/trait.From.html" title="trait devela::code::From">From</a>&lt;<a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a>&gt; for <a class="enum" href="../fmt/strtime/enum.Meridiem.html" title="enum devela::_dep::jiff::fmt::strtime::Meridiem">Meridiem</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-5" class="method trait-impl"><a href="#method.from-5" class="anchor">§</a><h4 class="code-header">fn <a href="../../../code/trait.From.html#tymethod.from" class="fn">from</a>(t: <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a>) -&gt; <a class="enum" href="../fmt/strtime/enum.Meridiem.html" title="enum devela::_dep::jiff::fmt::strtime::Meridiem">Meridiem</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CTime%3E-for-TimeDifference" class="impl"><a href="#impl-From%3CTime%3E-for-TimeDifference" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../code/trait.From.html" title="trait devela::code::From">From</a>&lt;<a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a>&gt; for <a class="struct" href="struct.TimeDifference.html" title="struct devela::_dep::jiff::civil::TimeDifference">TimeDifference</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-3" class="method trait-impl"><a href="#method.from-3" class="anchor">§</a><h4 class="code-header">fn <a href="../../../code/trait.From.html#tymethod.from" class="fn">from</a>(time: <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a>) -&gt; <a class="struct" href="struct.TimeDifference.html" title="struct devela::_dep::jiff::civil::TimeDifference">TimeDifference</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CZoned%3E-for-Time" class="impl"><a href="#impl-From%3CZoned%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../code/trait.From.html" title="trait devela::code::From">From</a>&lt;<a class="struct" href="../struct.Zoned.html" title="struct devela::_dep::jiff::Zoned">Zoned</a>&gt; for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../../code/trait.From.html#tymethod.from" class="fn">from</a>(zdt: <a class="struct" href="../struct.Zoned.html" title="struct devela::_dep::jiff::Zoned">Zoned</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromPyObject%3C'py%3E-for-Time" class="impl"><a href="#impl-FromPyObject%3C'py%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl&lt;'py&gt; <a class="trait" href="../../pyo3/trait.FromPyObject.html" title="trait devela::_dep::pyo3::FromPyObject">FromPyObject</a>&lt;'py&gt; for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.extract_bound" class="method trait-impl"><a href="#method.extract_bound" class="anchor">§</a><h4 class="code-header">fn <a href="../../pyo3/trait.FromPyObject.html#tymethod.extract_bound" class="fn">extract_bound</a>(ob: &amp;<a class="struct" href="../../pyo3/struct.Bound.html" title="struct devela::_dep::pyo3::Bound">Bound</a>&lt;'py, <a class="struct" href="../../pyo3/struct.PyAny.html" title="struct devela::_dep::pyo3::PyAny">PyAny</a>&gt;) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;<a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a>, <a class="struct" href="../../pyo3/struct.PyErr.html" title="struct devela::_dep::pyo3::PyErr">PyErr</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;Time, PyErr&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Extracts <code>Self</code> from the bound smart pointer <code>obj</code>. <a href="../../pyo3/trait.FromPyObject.html#tymethod.extract_bound">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-FromStr-for-Time" class="impl"><a href="#impl-FromStr-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.FromStr.html" title="trait devela::all::FromStr">FromStr</a> for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Err" class="associatedtype trait-impl"><a href="#associatedtype.Err" class="anchor">§</a><h4 class="code-header">type <a href="../../../all/trait.FromStr.html#associatedtype.Err" class="associatedtype">Err</a> = <a class="struct" href="../struct.Error.html" title="struct devela::_dep::jiff::Error">Error</a></h4></section></summary><div class='docblock'>The associated error which can be returned from parsing.</div></details><details class="toggle method-toggle" open><summary><section id="method.from_str" class="method trait-impl"><a href="#method.from_str" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.FromStr.html#tymethod.from_str" class="fn">from_str</a>(string: &amp;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;<a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a>, <a class="struct" href="../struct.Error.html" title="struct devela::_dep::jiff::Error">Error</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;Time, Error&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Parses a string <code>s</code> to return a value of this type. <a href="../../../all/trait.FromStr.html#tymethod.from_str">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Hash-for-Time" class="impl"><a href="#impl-Hash-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.Hash.html" title="trait devela::all::Hash">Hash</a> for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hash" class="method trait-impl"><a href="#method.hash" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.Hash.html#tymethod.hash" class="fn">hash</a>&lt;__H&gt;(&amp;self, state: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut __H</a>)<div class="where">where
    __H: <a class="trait" href="../../../all/trait.Hasher.html" title="trait devela::all::Hasher">Hasher</a>,</div></h4></section></summary><div class='docblock'>Feeds this value into the given <a href="../../../all/trait.Hasher.html" title="trait devela::all::Hasher"><code>Hasher</code></a>. <a href="../../../all/trait.Hash.html#tymethod.hash">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.hash_slice" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.3.0">1.3.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/hash/mod.rs.html#235-237">Source</a></span><a href="#method.hash_slice" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.Hash.html#method.hash_slice" class="fn">hash_slice</a>&lt;H&gt;(data: &amp;[Self], state: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut H</a>)<div class="where">where
    H: <a class="trait" href="../../../all/trait.Hasher.html" title="trait devela::all::Hasher">Hasher</a>,
    Self: <a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Feeds a slice of this type into the given <a href="../../../all/trait.Hasher.html" title="trait devela::all::Hasher"><code>Hasher</code></a>. <a href="../../../all/trait.Hash.html#method.hash_slice">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-IntoPyObject%3C'py%3E-for-%26Time" class="impl"><a href="#impl-IntoPyObject%3C'py%3E-for-%26Time" class="anchor">§</a><h3 class="code-header">impl&lt;'py&gt; <a class="trait" href="../../pyo3/trait.IntoPyObject.html" title="trait devela::_dep::pyo3::IntoPyObject">IntoPyObject</a>&lt;'py&gt; for &amp;<a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Target-1" class="associatedtype trait-impl"><a href="#associatedtype.Target-1" class="anchor">§</a><h4 class="code-header">type <a href="../../pyo3/trait.IntoPyObject.html#associatedtype.Target" class="associatedtype">Target</a> = <a class="struct" href="../../pyo3/types/struct.PyTime.html" title="struct devela::_dep::pyo3::types::PyTime">PyTime</a></h4></section></summary><div class='docblock'>The Python output type</div></details><details class="toggle" open><summary><section id="associatedtype.Output-8" class="associatedtype trait-impl"><a href="#associatedtype.Output-8" class="anchor">§</a><h4 class="code-header">type <a href="../../pyo3/trait.IntoPyObject.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="../../pyo3/struct.Bound.html" title="struct devela::_dep::pyo3::Bound">Bound</a>&lt;'py, &lt;&amp;<a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a> as <a class="trait" href="../../pyo3/trait.IntoPyObject.html" title="trait devela::_dep::pyo3::IntoPyObject">IntoPyObject</a>&lt;'py&gt;&gt;::<a class="associatedtype" href="../../pyo3/trait.IntoPyObject.html#associatedtype.Target" title="type devela::_dep::pyo3::IntoPyObject::Target">Target</a>&gt;</h4></section></summary><div class='docblock'>The smart pointer type to use. <a href="../../pyo3/trait.IntoPyObject.html#associatedtype.Output">Read more</a></div></details><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="../../pyo3/trait.IntoPyObject.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="struct" href="../../pyo3/struct.PyErr.html" title="struct devela::_dep::pyo3::PyErr">PyErr</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.into_pyobject-1" class="method trait-impl"><a href="#method.into_pyobject-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../pyo3/trait.IntoPyObject.html#tymethod.into_pyobject" class="fn">into_pyobject</a>(
    self,
    py: <a class="struct" href="../../pyo3/struct.Python.html" title="struct devela::_dep::pyo3::Python">Python</a>&lt;'py&gt;,
) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;&lt;&amp;<a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a> as <a class="trait" href="../../pyo3/trait.IntoPyObject.html" title="trait devela::_dep::pyo3::IntoPyObject">IntoPyObject</a>&lt;'py&gt;&gt;::<a class="associatedtype" href="../../pyo3/trait.IntoPyObject.html#associatedtype.Output" title="type devela::_dep::pyo3::IntoPyObject::Output">Output</a>, &lt;&amp;<a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a> as <a class="trait" href="../../pyo3/trait.IntoPyObject.html" title="trait devela::_dep::pyo3::IntoPyObject">IntoPyObject</a>&lt;'py&gt;&gt;::<a class="associatedtype" href="../../pyo3/trait.IntoPyObject.html#associatedtype.Error" title="type devela::_dep::pyo3::IntoPyObject::Error">Error</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;&lt;&amp;Time as IntoPyObject&lt;&#39;py&gt;&gt;::Output, &lt;&amp;Time as IntoPyObject&lt;&#39;py&gt;&gt;::Error&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-IntoPyObject%3C'py%3E-for-Time" class="impl"><a href="#impl-IntoPyObject%3C'py%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl&lt;'py&gt; <a class="trait" href="../../pyo3/trait.IntoPyObject.html" title="trait devela::_dep::pyo3::IntoPyObject">IntoPyObject</a>&lt;'py&gt; for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Target" class="associatedtype trait-impl"><a href="#associatedtype.Target" class="anchor">§</a><h4 class="code-header">type <a href="../../pyo3/trait.IntoPyObject.html#associatedtype.Target" class="associatedtype">Target</a> = <a class="struct" href="../../pyo3/types/struct.PyTime.html" title="struct devela::_dep::pyo3::types::PyTime">PyTime</a></h4></section></summary><div class='docblock'>The Python output type</div></details><details class="toggle" open><summary><section id="associatedtype.Output-7" class="associatedtype trait-impl"><a href="#associatedtype.Output-7" class="anchor">§</a><h4 class="code-header">type <a href="../../pyo3/trait.IntoPyObject.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="../../pyo3/struct.Bound.html" title="struct devela::_dep::pyo3::Bound">Bound</a>&lt;'py, &lt;<a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a> as <a class="trait" href="../../pyo3/trait.IntoPyObject.html" title="trait devela::_dep::pyo3::IntoPyObject">IntoPyObject</a>&lt;'py&gt;&gt;::<a class="associatedtype" href="../../pyo3/trait.IntoPyObject.html#associatedtype.Target" title="type devela::_dep::pyo3::IntoPyObject::Target">Target</a>&gt;</h4></section></summary><div class='docblock'>The smart pointer type to use. <a href="../../pyo3/trait.IntoPyObject.html#associatedtype.Output">Read more</a></div></details><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="../../pyo3/trait.IntoPyObject.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="struct" href="../../pyo3/struct.PyErr.html" title="struct devela::_dep::pyo3::PyErr">PyErr</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.into_pyobject" class="method trait-impl"><a href="#method.into_pyobject" class="anchor">§</a><h4 class="code-header">fn <a href="../../pyo3/trait.IntoPyObject.html#tymethod.into_pyobject" class="fn">into_pyobject</a>(
    self,
    py: <a class="struct" href="../../pyo3/struct.Python.html" title="struct devela::_dep::pyo3::Python">Python</a>&lt;'py&gt;,
) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;&lt;<a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a> as <a class="trait" href="../../pyo3/trait.IntoPyObject.html" title="trait devela::_dep::pyo3::IntoPyObject">IntoPyObject</a>&lt;'py&gt;&gt;::<a class="associatedtype" href="../../pyo3/trait.IntoPyObject.html#associatedtype.Output" title="type devela::_dep::pyo3::IntoPyObject::Output">Output</a>, &lt;<a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a> as <a class="trait" href="../../pyo3/trait.IntoPyObject.html" title="trait devela::_dep::pyo3::IntoPyObject">IntoPyObject</a>&lt;'py&gt;&gt;::<a class="associatedtype" href="../../pyo3/trait.IntoPyObject.html#associatedtype.Error" title="type devela::_dep::pyo3::IntoPyObject::Error">Error</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;&lt;Time as IntoPyObject&lt;&#39;py&gt;&gt;::Output, &lt;Time as IntoPyObject&lt;&#39;py&gt;&gt;::Error&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Ord-for-Time" class="impl"><a href="#impl-Ord-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.Ord.html" title="trait devela::all::Ord">Ord</a> for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.cmp" class="method trait-impl"><a href="#method.cmp" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.Ord.html#tymethod.cmp" class="fn">cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a>) -&gt; <a class="enum" href="../../../all/enum.Ordering.html" title="enum devela::all::Ordering">Ordering</a></h4></section></summary><div class='docblock'>This method returns an <a href="../../../all/enum.Ordering.html" title="enum devela::all::Ordering"><code>Ordering</code></a> between <code>self</code> and <code>other</code>. <a href="../../../all/trait.Ord.html#tymethod.cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.max" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1013-1015">Source</a></span><a href="#method.max" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.Ord.html#method.max" class="fn">max</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the maximum of two values. <a href="../../../all/trait.Ord.html#method.max">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.min" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.21.0">1.21.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1052-1054">Source</a></span><a href="#method.min" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.Ord.html#method.min" class="fn">min</a>(self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Compares and returns the minimum of two values. <a href="../../../all/trait.Ord.html#method.min">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clamp" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.50.0">1.50.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1078-1080">Source</a></span><a href="#method.clamp" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.Ord.html#method.clamp" class="fn">clamp</a>(self, min: Self, max: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Restrict a value to a certain interval. <a href="../../../all/trait.Ord.html#method.clamp">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialEq-for-Time" class="impl"><a href="#impl-PartialEq-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.PartialEq.html" title="trait devela::all::PartialEq">PartialEq</a> for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.eq" class="method trait-impl"><a href="#method.eq" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialEq.html#tymethod.eq" class="fn">eq</a>(&amp;self, other: &amp;<a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.ne" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#265">Source</a></span><a href="#method.ne" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialEq.html#method.ne" class="fn">ne</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests for <code>!=</code>. The default implementation is almost always sufficient,
and should not be overridden without very good reason.</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-PartialOrd-for-Time" class="impl"><a href="#impl-PartialOrd-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.PartialOrd.html" title="trait devela::all::PartialOrd">PartialOrd</a> for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.partial_cmp" class="method trait-impl"><a href="#method.partial_cmp" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialOrd.html#tymethod.partial_cmp" class="fn">partial_cmp</a>(&amp;self, other: &amp;<a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a>) -&gt; <a class="enum" href="../../../all/enum.Option.html" title="enum devela::all::Option">Option</a>&lt;<a class="enum" href="../../../all/enum.Ordering.html" title="enum devela::all::Ordering">Ordering</a>&gt; <a href="#" class="tooltip" data-notable-ty="Option&lt;Ordering&gt;">ⓘ</a></h4></section></summary><div class='docblock'>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../../../all/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.lt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1387">Source</a></span><a href="#method.lt" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialOrd.html#method.lt" class="fn">lt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../../../all/trait.PartialOrd.html#method.lt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.le" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1405">Source</a></span><a href="#method.le" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialOrd.html#method.le" class="fn">le</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the
<code>&lt;=</code> operator. <a href="../../../all/trait.PartialOrd.html#method.le">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.gt" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1423">Source</a></span><a href="#method.gt" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialOrd.html#method.gt" class="fn">gt</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code>
operator. <a href="../../../all/trait.PartialOrd.html#method.gt">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ge" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/cmp.rs.html#1441">Source</a></span><a href="#method.ge" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.PartialOrd.html#method.ge" class="fn">ge</a>(&amp;self, other: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Rhs</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by
the <code>&gt;=</code> operator. <a href="../../../all/trait.PartialOrd.html#method.ge">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CDuration%3E-for-Time" class="impl"><a href="#impl-Sub%3CDuration%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.Sub.html" title="trait devela::all::Sub">Sub</a>&lt;<a class="struct" href="../../../all/struct.Duration.html" title="struct devela::all::Duration">Duration</a>&gt; for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3><div class="docblock"><p>Subtracts an unsigned duration of time. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_sub" title="method devela::_dep::jiff::civil::Time::checked_sub"><code>Time::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-6" class="associatedtype trait-impl"><a href="#associatedtype.Output-6" class="anchor">§</a><h4 class="code-header">type <a href="../../../all/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-3" class="method trait-impl"><a href="#method.sub-3" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="../../../all/struct.Duration.html" title="struct devela::all::Duration">Duration</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="../../../all/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CSignedDuration%3E-for-Time" class="impl"><a href="#impl-Sub%3CSignedDuration%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.Sub.html" title="trait devela::all::Sub">Sub</a>&lt;<a class="struct" href="../struct.SignedDuration.html" title="struct devela::_dep::jiff::SignedDuration">SignedDuration</a>&gt; for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3><div class="docblock"><p>Subtracts a signed duration of time. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_sub" title="method devela::_dep::jiff::civil::Time::checked_sub"><code>Time::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-5" class="associatedtype trait-impl"><a href="#associatedtype.Output-5" class="anchor">§</a><h4 class="code-header">type <a href="../../../all/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-2" class="method trait-impl"><a href="#method.sub-2" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="../struct.SignedDuration.html" title="struct devela::_dep::jiff::SignedDuration">SignedDuration</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="../../../all/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub%3CSpan%3E-for-Time" class="impl"><a href="#impl-Sub%3CSpan%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.Sub.html" title="trait devela::all::Sub">Sub</a>&lt;<a class="struct" href="../struct.Span.html" title="struct devela::_dep::jiff::Span">Span</a>&gt; for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3><div class="docblock"><p>Subtracts a span of time. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_sub" title="method devela::_dep::jiff::civil::Time::checked_sub"><code>Time::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-3" class="associatedtype trait-impl"><a href="#associatedtype.Output-3" class="anchor">§</a><h4 class="code-header">type <a href="../../../all/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub" class="method trait-impl"><a href="#method.sub" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="../struct.Span.html" title="struct devela::_dep::jiff::Span">Span</a>) -&gt; <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="../../../all/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Sub-for-Time" class="impl"><a href="#impl-Sub-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.Sub.html" title="trait devela::all::Sub">Sub</a> for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3><div class="docblock"><p>Computes the span of time between two times.</p>
</div></section></summary><div class="docblock"><p>This will return a negative span when the time being subtracted is greater.</p>
<p>Since this uses the default configuration for calculating a span between
two times (no rounding and largest units is hours), this will never panic
or fail in any way.</p>
<p>To configure the largest unit or enable rounding, use <a href="struct.Time.html#method.since" title="method devela::_dep::jiff::civil::Time::since"><code>Time::since</code></a>.</p>
</div><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Output-4" class="associatedtype trait-impl"><a href="#associatedtype.Output-4" class="anchor">§</a><h4 class="code-header">type <a href="../../../all/trait.Sub.html#associatedtype.Output" class="associatedtype">Output</a> = <a class="struct" href="../struct.Span.html" title="struct devela::_dep::jiff::Span">Span</a></h4></section></summary><div class='docblock'>The resulting type after applying the <code>-</code> operator.</div></details><details class="toggle method-toggle" open><summary><section id="method.sub-1" class="method trait-impl"><a href="#method.sub-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.Sub.html#tymethod.sub" class="fn">sub</a>(self, rhs: <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a>) -&gt; <a class="struct" href="../struct.Span.html" title="struct devela::_dep::jiff::Span">Span</a></h4></section></summary><div class='docblock'>Performs the <code>-</code> operation. <a href="../../../all/trait.Sub.html#tymethod.sub">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CDuration%3E-for-Time" class="impl"><a href="#impl-SubAssign%3CDuration%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.SubAssign.html" title="trait devela::all::SubAssign">SubAssign</a>&lt;<a class="struct" href="../../../all/struct.Duration.html" title="struct devela::all::Duration">Duration</a>&gt; for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3><div class="docblock"><p>Subtracts an unsigned duration of time in place. This uses wrapping
arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_sub" title="method devela::_dep::jiff::civil::Time::checked_sub"><code>Time::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign-2" class="method trait-impl"><a href="#method.sub_assign-2" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, rhs: <a class="struct" href="../../../all/struct.Duration.html" title="struct devela::all::Duration">Duration</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="../../../all/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CSignedDuration%3E-for-Time" class="impl"><a href="#impl-SubAssign%3CSignedDuration%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.SubAssign.html" title="trait devela::all::SubAssign">SubAssign</a>&lt;<a class="struct" href="../struct.SignedDuration.html" title="struct devela::_dep::jiff::SignedDuration">SignedDuration</a>&gt; for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3><div class="docblock"><p>Subtracts a signed duration of time in place. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_sub" title="method devela::_dep::jiff::civil::Time::checked_sub"><code>Time::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign-1" class="method trait-impl"><a href="#method.sub_assign-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, rhs: <a class="struct" href="../struct.SignedDuration.html" title="struct devela::_dep::jiff::SignedDuration">SignedDuration</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="../../../all/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-SubAssign%3CSpan%3E-for-Time" class="impl"><a href="#impl-SubAssign%3CSpan%3E-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.SubAssign.html" title="trait devela::all::SubAssign">SubAssign</a>&lt;<a class="struct" href="../struct.Span.html" title="struct devela::_dep::jiff::Span">Span</a>&gt; for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3><div class="docblock"><p>Subtracts a span of time in place. This uses wrapping arithmetic.</p>
</div></section></summary><div class="docblock"><p>For checked arithmetic, see <a href="struct.Time.html#method.checked_sub" title="method devela::_dep::jiff::civil::Time::checked_sub"><code>Time::checked_sub</code></a>.</p>
</div><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.sub_assign" class="method trait-impl"><a href="#method.sub_assign" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.SubAssign.html#tymethod.sub_assign" class="fn">sub_assign</a>(&amp;mut self, rhs: <a class="struct" href="../struct.Span.html" title="struct devela::_dep::jiff::Span">Span</a>)</h4></section></summary><div class='docblock'>Performs the <code>-=</code> operation. <a href="../../../all/trait.SubAssign.html#tymethod.sub_assign">Read more</a></div></details></div></details><section id="impl-Copy-for-Time" class="impl"><a href="#impl-Copy-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.Copy.html" title="trait devela::all::Copy">Copy</a> for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3></section><section id="impl-Eq-for-Time" class="impl"><a href="#impl-Eq-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.Eq.html" title="trait devela::all::Eq">Eq</a> for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3></section><section id="impl-StructuralPartialEq-for-Time" class="impl"><a href="#impl-StructuralPartialEq-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../_core/marker/trait.StructuralPartialEq.html" title="trait devela::_core::marker::StructuralPartialEq">StructuralPartialEq</a> for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Time" class="impl"><a href="#impl-Freeze-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../_core/marker/trait.Freeze.html" title="trait devela::_core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3></section><section id="impl-RefUnwindSafe-for-Time" class="impl"><a href="#impl-RefUnwindSafe-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.PanicRefUnwindSafe.html" title="trait devela::all::PanicRefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3></section><section id="impl-Send-for-Time" class="impl"><a href="#impl-Send-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.Send.html" title="trait devela::all::Send">Send</a> for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3></section><section id="impl-Sync-for-Time" class="impl"><a href="#impl-Sync-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.Sync.html" title="trait devela::all::Sync">Sync</a> for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3></section><section id="impl-Unpin-for-Time" class="impl"><a href="#impl-Unpin-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.Unpin.html" title="trait devela::all::Unpin">Unpin</a> for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3></section><section id="impl-UnwindSafe-for-Time" class="impl"><a href="#impl-UnwindSafe-for-Time" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="../../../all/trait.PanicUnwindSafe.html" title="trait devela::all::PanicUnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Time.html" title="struct devela::_dep::jiff::civil::Time">Time</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../code/trait.Any.html" title="trait devela::code::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#139">Source</a><a href="#method.type_id-1" class="anchor">§</a><h4 class="code-header">fn <a href="../../../code/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="../../../code/struct.TypeId.html" title="struct devela::code::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="../../../code/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../all/trait.Borrow.html" title="trait devela::all::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="../../../all/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../all/trait.BorrowMut.html" title="trait devela::all::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="../../../all/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ByteSized-for-T" class="impl"><a class="src rightside" href="../../../../src/devela/sys/mem/size/byte.rs.html#8">Source</a><a href="#impl-ByteSized-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../all/trait.ByteSized.html" title="trait devela::all::ByteSized">ByteSized</a> for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.BYTE_ALIGN" class="associatedconstant trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/size/byte.rs.html#16">Source</a><a href="#associatedconstant.BYTE_ALIGN" class="anchor">§</a><h4 class="code-header">const <a href="../../../all/trait.ByteSized.html#associatedconstant.BYTE_ALIGN" class="constant">BYTE_ALIGN</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a> = _</h4></section></summary><div class='docblock'>The alignment of this type in bytes.</div></details><details class="toggle" open><summary><section id="associatedconstant.BYTE_SIZE" class="associatedconstant trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/size/byte.rs.html#18">Source</a><a href="#associatedconstant.BYTE_SIZE" class="anchor">§</a><h4 class="code-header">const <a href="../../../all/trait.ByteSized.html#associatedconstant.BYTE_SIZE" class="constant">BYTE_SIZE</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a> = _</h4></section></summary><div class='docblock'>The size of this type in bytes.</div></details><details class="toggle method-toggle" open><summary><section id="method.byte_align" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/size/byte.rs.html#21-23">Source</a><a href="#method.byte_align" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.ByteSized.html#method.byte_align" class="fn">byte_align</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the alignment of this type in bytes.</div></details><details class="toggle method-toggle" open><summary><section id="method.byte_size" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/size/byte.rs.html#28-30">Source</a><a href="#method.byte_size" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.ByteSized.html#method.byte_size" class="fn">byte_size</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the size of this type in bytes. <a href="../../../all/trait.ByteSized.html#method.byte_size">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.ptr_size_ratio" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/size/byte.rs.html#61-63">Source</a><a href="#method.ptr_size_ratio" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.ByteSized.html#method.ptr_size_ratio" class="fn">ptr_size_ratio</a>(&amp;self) -&gt; [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.array.html">2</a>]</h4></section></summary><div class='docblock'>Returns the size ratio between <a href="../../../all/struct.Ptr.html#associatedconstant.BYTES" title="associated constant devela::all::Ptr::BYTES"><code>Ptr::BYTES</code></a>
and <a href="../../../all/trait.ByteSized.html#associatedconstant.BYTE_SIZE" title="trait devela::all::ByteSized"><code>BYTE_SIZE</code></a>. <a href="../../../all/trait.ByteSized.html#method.ptr_size_ratio">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Chain%3CR%3E-for-T" class="impl"><a class="src rightside" href="../../../../src/devela/code/result/chain_hook.rs.html#62">Source</a><a href="#impl-Chain%3CR%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, R&gt; <a class="trait" href="../../../all/trait.Chain.html" title="trait devela::all::Chain">Chain</a>&lt;R&gt; for T<div class="where">where
    T: ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.chain" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/result/chain_hook.rs.html#36-42">Source</a><a href="#method.chain" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.Chain.html#method.chain" class="fn">chain</a>&lt;F&gt;(self, f: F) -&gt; R<div class="where">where
    F: <a class="trait" href="../../../all/trait.FnOnce.html" title="trait devela::all::FnOnce">FnOnce</a>(Self) -&gt; R,
    Self: <a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Chain a function which takes the parameter by value.</div></details><details class="toggle method-toggle" open><summary><section id="method.chain_ref" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/result/chain_hook.rs.html#46-51">Source</a><a href="#method.chain_ref" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.Chain.html#method.chain_ref" class="fn">chain_ref</a>&lt;F&gt;(&amp;self, f: F) -&gt; R<div class="where">where
    F: <a class="trait" href="../../../all/trait.FnOnce.html" title="trait devela::all::FnOnce">FnOnce</a>(&amp;Self) -&gt; R,</div></h4></section></summary><div class='docblock'>Chain a function which takes the parameter by shared reference.</div></details><details class="toggle method-toggle" open><summary><section id="method.chain_mut" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/result/chain_hook.rs.html#55-60">Source</a><a href="#method.chain_mut" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.Chain.html#method.chain_mut" class="fn">chain_mut</a>&lt;F&gt;(&amp;mut self, f: F) -&gt; R<div class="where">where
    F: <a class="trait" href="../../../all/trait.FnOnce.html" title="trait devela::all::FnOnce">FnOnce</a>(&amp;mut Self) -&gt; R,</div></h4></section></summary><div class='docblock'>Chain a function which takes the parameter by exclusive reference.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#516">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../_core/clone/trait.CloneToUninit.html" title="trait devela::_core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="../../../code/trait.Clone.html" title="trait devela::code::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#518">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="../../../_core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dest: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dest</code>. <a href="../../../_core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Comparable%3CK%3E-for-Q" class="impl"><a href="#impl-Comparable%3CK%3E-for-Q" class="anchor">§</a><h3 class="code-header">impl&lt;Q, K&gt; Comparable&lt;K&gt; for Q<div class="where">where
    Q: <a class="trait" href="../../../all/trait.Ord.html" title="trait devela::all::Ord">Ord</a> + ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,
    K: <a class="trait" href="../../../all/trait.Borrow.html" title="trait devela::all::Borrow">Borrow</a>&lt;Q&gt; + ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.compare" class="method trait-impl"><a href="#method.compare" class="anchor">§</a><h4 class="code-header">fn <a class="fn">compare</a>(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;K</a>) -&gt; <a class="enum" href="../../../all/enum.Ordering.html" title="enum devela::all::Ordering">Ordering</a></h4></section></summary><div class='docblock'>Compare self to <code>key</code> and return their ordering.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Equivalent%3CK%3E-for-Q" class="impl"><a href="#impl-Equivalent%3CK%3E-for-Q" class="anchor">§</a><h3 class="code-header">impl&lt;Q, K&gt; <a class="trait" href="../../hashbrown/trait.Equivalent.html" title="trait devela::_dep::hashbrown::Equivalent">Equivalent</a>&lt;K&gt; for Q<div class="where">where
    Q: <a class="trait" href="../../../all/trait.Eq.html" title="trait devela::all::Eq">Eq</a> + ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,
    K: <a class="trait" href="../../../all/trait.Borrow.html" title="trait devela::all::Borrow">Borrow</a>&lt;Q&gt; + ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.equivalent" class="method trait-impl"><a href="#method.equivalent" class="anchor">§</a><h4 class="code-header">fn <a href="../../hashbrown/trait.Equivalent.html#tymethod.equivalent" class="fn">equivalent</a>(&amp;self, key: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;K</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Compare self to <code>key</code> and return <code>true</code> if they are equal.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ExtAny-for-T" class="impl"><a class="src rightside" href="../../../../src/devela/code/any/ext.rs.html#17">Source</a><a href="#impl-ExtAny-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../code/trait.ExtAny.html" title="trait devela::code::ExtAny">ExtAny</a> for T<div class="where">where
    T: <a class="trait" href="../../../code/trait.Any.html" title="trait devela::code::Any">Any</a> + ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/any/ext.rs.html#39">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="../../../code/trait.ExtAny.html#method.type_id" class="fn">type_id</a>() -&gt; <a class="struct" href="../../../code/struct.TypeId.html" title="struct devela::code::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Returns the <code>TypeId</code> of <code>Self</code>. <a href="../../../code/trait.ExtAny.html#method.type_id">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.type_of" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/any/ext.rs.html#51">Source</a><a href="#method.type_of" class="anchor">§</a><h4 class="code-header">fn <a href="../../../code/trait.ExtAny.html#method.type_of" class="fn">type_of</a>(&amp;self) -&gt; <a class="struct" href="../../../code/struct.TypeId.html" title="struct devela::code::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Returns the <code>TypeId</code> of <code>self</code>. <a href="../../../code/trait.ExtAny.html#method.type_of">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.type_name" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/any/ext.rs.html#65">Source</a><a href="#method.type_name" class="anchor">§</a><h4 class="code-header">fn <a href="../../../code/trait.ExtAny.html#method.type_name" class="fn">type_name</a>(&amp;self) -&gt; &amp;'static <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a> <a href="#" class="tooltip" data-notable-ty="&amp;&#39;static str">ⓘ</a></h4></section></summary><div class='docblock'>Returns the type name of <code>self</code>. <a href="../../../code/trait.ExtAny.html#method.type_name">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.type_is" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/any/ext.rs.html#84">Source</a><a href="#method.type_is" class="anchor">§</a><h4 class="code-header">fn <a href="../../../code/trait.ExtAny.html#method.type_is" class="fn">type_is</a>&lt;T: 'static&gt;(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns <code>true</code> if <code>Self</code> is of type <code>T</code>. <a href="../../../code/trait.ExtAny.html#method.type_is">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.type_hash" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/any/ext.rs.html#87-90">Source</a><a href="#method.type_hash" class="anchor">§</a><h4 class="code-header">fn <a href="../../../code/trait.ExtAny.html#method.type_hash" class="fn">type_hash</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a></h4></section></summary><div class='docblock'>Returns a deterministic hash of the <code>TypeId</code> of <code>Self</code>.</div></details><details class="toggle method-toggle" open><summary><section id="method.type_hash_with" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/any/ext.rs.html#93-96">Source</a><a href="#method.type_hash_with" class="anchor">§</a><h4 class="code-header">fn <a href="../../../code/trait.ExtAny.html#method.type_hash_with" class="fn">type_hash_with</a>&lt;H: <a class="trait" href="../../../all/trait.Hasher.html" title="trait devela::all::Hasher">Hasher</a>&gt;(&amp;self, hasher: H) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a></h4></section></summary><div class='docblock'>Returns a deterministic hash of the <code>TypeId</code> of <code>Self</code> using a custom hasher.</div></details><details class="toggle method-toggle" open><summary><section id="method.as_any_ref" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/any/ext.rs.html#111">Source</a><a href="#method.as_any_ref" class="anchor">§</a><h4 class="code-header">fn <a href="../../../code/trait.ExtAny.html#method.as_any_ref" class="fn">as_any_ref</a>(&amp;self) -&gt; &amp;dyn <a class="trait" href="../../../code/trait.Any.html" title="trait devela::code::Any">Any</a><div class="where">where
    Self: <a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Upcasts <code>&amp;self</code> as <code>&amp;dyn Any</code>. <a href="../../../code/trait.ExtAny.html#method.as_any_ref">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.as_any_mut" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/any/ext.rs.html#124">Source</a><a href="#method.as_any_mut" class="anchor">§</a><h4 class="code-header">fn <a href="../../../code/trait.ExtAny.html#method.as_any_mut" class="fn">as_any_mut</a>(&amp;mut self) -&gt; &amp;mut dyn <a class="trait" href="../../../code/trait.Any.html" title="trait devela::code::Any">Any</a><div class="where">where
    Self: <a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Upcasts <code>&amp;mut self</code> as <code>&amp;mut dyn Any</code>. <a href="../../../code/trait.ExtAny.html#method.as_any_mut">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.as_any_box" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/any/ext.rs.html#138">Source</a><a href="#method.as_any_box" class="anchor">§</a><h4 class="code-header">fn <a href="../../../code/trait.ExtAny.html#method.as_any_box" class="fn">as_any_box</a>(self: <a class="struct" href="../../../all/struct.Box.html" title="struct devela::all::Box">Box</a>&lt;Self&gt;) -&gt; <a class="struct" href="../../../all/struct.Box.html" title="struct devela::all::Box">Box</a>&lt;dyn <a class="trait" href="../../../code/trait.Any.html" title="trait devela::code::Any">Any</a>&gt;<div class="where">where
    Self: <a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Upcasts <code>Box&lt;self&gt;</code> as <code>Box&lt;dyn Any&gt;</code>. <a href="../../../code/trait.ExtAny.html#method.as_any_box">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.downcast_ref" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/any/ext.rs.html#196-199">Source</a><a href="#method.downcast_ref" class="anchor">§</a><h4 class="code-header">fn <a href="../../../code/trait.ExtAny.html#method.downcast_ref" class="fn">downcast_ref</a>&lt;T: 'static&gt;(&amp;self) -&gt; <a class="enum" href="../../../all/enum.Option.html" title="enum devela::all::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a>&gt; <a href="#" class="tooltip" data-notable-ty="Option&lt;&amp;T&gt;">ⓘ</a></h4></section></summary><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>unsafe_layout</code> and non-crate feature <code>safe_code</code></strong> only.</div></span><div class='docblock'>Returns some shared reference to the inner value if it is of type <code>T</code>. <a href="../../../code/trait.ExtAny.html#method.downcast_ref">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.downcast_mut" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/any/ext.rs.html#208-211">Source</a><a href="#method.downcast_mut" class="anchor">§</a><h4 class="code-header">fn <a href="../../../code/trait.ExtAny.html#method.downcast_mut" class="fn">downcast_mut</a>&lt;T: 'static&gt;(&amp;mut self) -&gt; <a class="enum" href="../../../all/enum.Option.html" title="enum devela::all::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>&gt; <a href="#" class="tooltip" data-notable-ty="Option&lt;&amp;mut T&gt;">ⓘ</a></h4></section></summary><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>unsafe_layout</code> and non-crate feature <code>safe_code</code></strong> only.</div></span><div class='docblock'>Returns some exclusive reference to the inner value if it is of type <code>T</code>. <a href="../../../code/trait.ExtAny.html#method.downcast_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ExtMem-for-T" class="impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#8">Source</a><a href="#impl-ExtMem-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../all/trait.ExtMem.html" title="trait devela::all::ExtMem">ExtMem</a> for T<div class="where">where
    T: ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.NEEDS_DROP" class="associatedconstant trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#18">Source</a><a href="#associatedconstant.NEEDS_DROP" class="anchor">§</a><h4 class="code-header">const <a href="../../../all/trait.ExtMem.html#associatedconstant.NEEDS_DROP" class="constant">NEEDS_DROP</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a> = _</h4></section></summary><div class='docblock'>Know whether dropping values of this type matters, in compile-time.</div></details><details class="toggle method-toggle" open><summary><section id="method.mem_align_of" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#24">Source</a><a href="#method.mem_align_of" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.ExtMem.html#method.mem_align_of" class="fn">mem_align_of</a>&lt;T&gt;() -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the minimum alignment of the type in bytes. <a href="../../../all/trait.ExtMem.html#method.mem_align_of">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_align_of_val" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#30">Source</a><a href="#method.mem_align_of_val" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.ExtMem.html#method.mem_align_of_val" class="fn">mem_align_of_val</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the alignment of the pointed-to value in bytes. <a href="../../../all/trait.ExtMem.html#method.mem_align_of_val">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_size_of" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#36">Source</a><a href="#method.mem_size_of" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.ExtMem.html#method.mem_size_of" class="fn">mem_size_of</a>&lt;T&gt;() -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the size of a type in bytes. <a href="../../../all/trait.ExtMem.html#method.mem_size_of">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_size_of_val" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#42">Source</a><a href="#method.mem_size_of_val" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.ExtMem.html#method.mem_size_of_val" class="fn">mem_size_of_val</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Returns the size of the pointed-to value in bytes. <a href="../../../all/trait.ExtMem.html#method.mem_size_of_val">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_copy" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#51">Source</a><a href="#method.mem_copy" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.ExtMem.html#method.mem_copy" class="fn">mem_copy</a>(&amp;self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="../../../all/trait.Copy.html" title="trait devela::all::Copy">Copy</a>,</div></h4></section></summary><div class='docblock'>Bitwise-copies a value. <a href="../../../all/trait.ExtMem.html#method.mem_copy">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_needs_drop" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#57">Source</a><a href="#method.mem_needs_drop" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.ExtMem.html#method.mem_needs_drop" class="fn">mem_needs_drop</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class='docblock'>Returns <code>true</code> if dropping values of this type matters. <a href="../../../all/trait.ExtMem.html#method.mem_needs_drop">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_drop" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#62">Source</a><a href="#method.mem_drop" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.ExtMem.html#method.mem_drop" class="fn">mem_drop</a>(self)<div class="where">where
    Self: <a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Drops <code>self</code> by running its destructor. <a href="../../../all/trait.ExtMem.html#method.mem_drop">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_forget" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#67">Source</a><a href="#method.mem_forget" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.ExtMem.html#method.mem_forget" class="fn">mem_forget</a>(self)<div class="where">where
    Self: <a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Forgets about <code>self</code> <em>without running its destructor</em>. <a href="../../../all/trait.ExtMem.html#method.mem_forget">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_replace" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#73">Source</a><a href="#method.mem_replace" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.ExtMem.html#method.mem_replace" class="fn">mem_replace</a>(&amp;mut self, other: Self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Replaces <code>self</code> with other, returning the previous value of <code>self</code>. <a href="../../../all/trait.ExtMem.html#method.mem_replace">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_take" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#79">Source</a><a href="#method.mem_take" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.ExtMem.html#method.mem_take" class="fn">mem_take</a>(&amp;mut self) -&gt; Self<div class="where">where
    Self: <a class="trait" href="../../../code/trait.Default.html" title="trait devela::code::Default">Default</a>,</div></h4></section></summary><div class='docblock'>Replaces <code>self</code> with its default value, returning the previous value of <code>self</code>. <a href="../../../all/trait.ExtMem.html#method.mem_take">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_swap" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#84">Source</a><a href="#method.mem_swap" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.ExtMem.html#method.mem_swap" class="fn">mem_swap</a>(&amp;mut self, other: &amp;mut Self)<div class="where">where
    Self: <a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h4></section></summary><div class='docblock'>Swaps the value of <code>self</code> and <code>other</code> without deinitializing either one. <a href="../../../all/trait.ExtMem.html#method.mem_swap">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_zeroed" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#93">Source</a><a href="#method.mem_zeroed" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="../../../all/trait.ExtMem.html#method.mem_zeroed" class="fn">mem_zeroed</a>&lt;T&gt;() -&gt; T</h4></section></summary><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>unsafe_layout</code></strong> only.</div></span><div class='docblock'>Returns the value of type <code>T</code> represented by the all-zero byte-pattern. <a href="../../../all/trait.ExtMem.html#method.mem_zeroed">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_transmute_copy" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#102-104">Source</a><a href="#method.mem_transmute_copy" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="../../../all/trait.ExtMem.html#method.mem_transmute_copy" class="fn">mem_transmute_copy</a>&lt;Src, Dst&gt;(src: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Src</a>) -&gt; Dst</h4></section></summary><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>unsafe_layout</code></strong> only.</div></span><div class='docblock'>Returns the value of type <code>T</code> represented by the all-zero byte-pattern. <a href="../../../all/trait.ExtMem.html#method.mem_transmute_copy">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_as_bytes" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#113">Source</a><a href="#method.mem_as_bytes" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.ExtMem.html#method.mem_as_bytes" class="fn">mem_as_bytes</a>(&amp;self) -&gt; &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;[u8]">ⓘ</a><div class="where">where
    Self: <a class="trait" href="../../../all/trait.Sync.html" title="trait devela::all::Sync">Sync</a> + <a class="trait" href="../../../all/trait.Unpin.html" title="trait devela::all::Unpin">Unpin</a>,</div></h4></section></summary><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>unsafe_slice</code></strong> only.</div></span><div class='docblock'>View a <code>Sync + Unpin</code> <code>self</code> as <code>&amp;[u8]</code>. <a href="../../../all/trait.ExtMem.html#method.mem_as_bytes">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.mem_as_bytes_mut" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/sys/mem/ext.rs.html#121">Source</a><a href="#method.mem_as_bytes_mut" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.ExtMem.html#method.mem_as_bytes_mut" class="fn">mem_as_bytes_mut</a>(&amp;mut self) -&gt; &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;mut [u8]">ⓘ</a><div class="where">where
    Self: <a class="trait" href="../../../all/trait.Sync.html" title="trait devela::all::Sync">Sync</a> + <a class="trait" href="../../../all/trait.Unpin.html" title="trait devela::all::Unpin">Unpin</a>,</div></h4></section></summary><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>unsafe_slice</code></strong> only.</div></span><div class='docblock'>View a <code>Sync + Unpin</code> <code>self</code> as <code>&amp;mut [u8]</code>. <a href="../../../all/trait.ExtMem.html#method.mem_as_bytes_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#791">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../code/trait.From.html" title="trait devela::code::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-6" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#794">Source</a><a href="#method.from-6" class="anchor">§</a><h4 class="code-header">fn <a href="../../../code/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-FromPyObjectBound%3C'_,+'py%3E-for-T" class="impl"><a href="#impl-FromPyObjectBound%3C'_,+'py%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;'py, T&gt; <a class="trait" href="../../pyo3/conversion/trait.FromPyObjectBound.html" title="trait devela::_dep::pyo3::conversion::FromPyObjectBound">FromPyObjectBound</a>&lt;'_, 'py&gt; for T<div class="where">where
    T: <a class="trait" href="../../pyo3/trait.FromPyObject.html" title="trait devela::_dep::pyo3::FromPyObject">FromPyObject</a>&lt;'py&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_py_object_bound" class="method trait-impl"><a href="#method.from_py_object_bound" class="anchor">§</a><h4 class="code-header">fn <a href="../../pyo3/conversion/trait.FromPyObjectBound.html#tymethod.from_py_object_bound" class="fn">from_py_object_bound</a>(ob: <a class="struct" href="../../pyo3/struct.Borrowed.html" title="struct devela::_dep::pyo3::Borrowed">Borrowed</a>&lt;'_, 'py, <a class="struct" href="../../pyo3/struct.PyAny.html" title="struct devela::_dep::pyo3::PyAny">PyAny</a>&gt;) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;T, <a class="struct" href="../../pyo3/struct.PyErr.html" title="struct devela::_dep::pyo3::PyErr">PyErr</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;T, PyErr&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Extracts <code>Self</code> from the bound smart pointer <code>obj</code>. <a href="../../pyo3/conversion/trait.FromPyObjectBound.html#tymethod.from_py_object_bound">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-FromSample%3CS%3E-for-S" class="impl"><a href="#impl-FromSample%3CS%3E-for-S" class="anchor">§</a><h3 class="code-header">impl&lt;S&gt; FromSample&lt;S&gt; for S</h3></section></summary><div class="impl-items"><section id="method.from_sample_" class="method trait-impl"><a href="#method.from_sample_" class="anchor">§</a><h4 class="code-header">fn <a class="fn">from_sample_</a>(s: S) -&gt; S</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Hook-for-T" class="impl"><a class="src rightside" href="../../../../src/devela/code/result/chain_hook.rs.html#121">Source</a><a href="#impl-Hook-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../all/trait.Hook.html" title="trait devela::all::Hook">Hook</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.hook_ref" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/result/chain_hook.rs.html#97-103">Source</a><a href="#method.hook_ref" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.Hook.html#method.hook_ref" class="fn">hook_ref</a>&lt;F&gt;(self, f: F) -&gt; Self<div class="where">where
    F: <a class="trait" href="../../../all/trait.FnOnce.html" title="trait devela::all::FnOnce">FnOnce</a>(&amp;Self),</div></h4></section></summary><div class='docblock'>Applies a function which takes the parameter by shared reference,
and then returns the (possibly) modified owned value. <a href="../../../all/trait.Hook.html#method.hook_ref">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.hook_mut" class="method trait-impl"><a class="src rightside" href="../../../../src/devela/code/result/chain_hook.rs.html#113-119">Source</a><a href="#method.hook_mut" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.Hook.html#method.hook_mut" class="fn">hook_mut</a>&lt;F&gt;(self, f: F) -&gt; Self<div class="where">where
    F: <a class="trait" href="../../../all/trait.FnOnce.html" title="trait devela::all::FnOnce">FnOnce</a>(&amp;mut Self),</div></h4></section></summary><div class='docblock'>Applies a function which takes the parameter by exclusive reference,
and then returns the (possibly) modified owned value. <a href="../../../all/trait.Hook.html#method.hook_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#773-775">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../../../code/trait.Into.html" title="trait devela::code::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="../../../code/trait.From.html" title="trait devela::code::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#783">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="../../../code/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="../../../code/trait.From.html" title="trait devela::code::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-IntoEither-for-T" class="impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#64">Source</a><a href="#impl-IntoEither-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html" title="trait either::into_either::IntoEither">IntoEither</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_either" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#29">Source</a><a href="#method.into_either" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either" class="fn">into_either</a>(self, into_left: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="enum" href="../../itertools/enum.Either.html" title="enum devela::_dep::itertools::Either">Either</a>&lt;Self, Self&gt; <a href="#" class="tooltip" data-notable-ty="Either&lt;Self, Self&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="../../itertools/enum.Either.html#variant.Left" title="variant devela::_dep::itertools::Either::Left"><code>Left</code></a> variant of <a href="../../itertools/enum.Either.html" title="enum devela::_dep::itertools::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left</code> is <code>true</code>.
Converts <code>self</code> into a <a href="../../itertools/enum.Either.html#variant.Right" title="variant devela::_dep::itertools::Either::Right"><code>Right</code></a> variant of <a href="../../itertools/enum.Either.html" title="enum devela::_dep::itertools::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.into_either_with" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#55-57">Source</a><a href="#method.into_either_with" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with" class="fn">into_either_with</a>&lt;F&gt;(self, into_left: F) -&gt; <a class="enum" href="../../itertools/enum.Either.html" title="enum devela::_dep::itertools::Either">Either</a>&lt;Self, Self&gt; <a href="#" class="tooltip" data-notable-ty="Either&lt;Self, Self&gt;">ⓘ</a><div class="where">where
    F: <a class="trait" href="../../../all/trait.FnOnce.html" title="trait devela::all::FnOnce">FnOnce</a>(&amp;Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="../../itertools/enum.Either.html#variant.Left" title="variant devela::_dep::itertools::Either::Left"><code>Left</code></a> variant of <a href="../../itertools/enum.Either.html" title="enum devela::_dep::itertools::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left(&amp;self)</code> returns <code>true</code>.
Converts <code>self</code> into a <a href="../../itertools/enum.Either.html#variant.Right" title="variant devela::_dep::itertools::Either::Right"><code>Right</code></a> variant of <a href="../../itertools/enum.Either.html" title="enum devela::_dep::itertools::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-IntoPyObjectExt%3C'py%3E-for-T" class="impl"><a href="#impl-IntoPyObjectExt%3C'py%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;'py, T&gt; <a class="trait" href="../../pyo3/trait.IntoPyObjectExt.html" title="trait devela::_dep::pyo3::IntoPyObjectExt">IntoPyObjectExt</a>&lt;'py&gt; for T<div class="where">where
    T: <a class="trait" href="../../pyo3/trait.IntoPyObject.html" title="trait devela::_dep::pyo3::IntoPyObject">IntoPyObject</a>&lt;'py&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_bound_py_any" class="method trait-impl"><a href="#method.into_bound_py_any" class="anchor">§</a><h4 class="code-header">fn <a href="../../pyo3/trait.IntoPyObjectExt.html#method.into_bound_py_any" class="fn">into_bound_py_any</a>(self, py: <a class="struct" href="../../pyo3/struct.Python.html" title="struct devela::_dep::pyo3::Python">Python</a>&lt;'py&gt;) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;<a class="struct" href="../../pyo3/struct.Bound.html" title="struct devela::_dep::pyo3::Bound">Bound</a>&lt;'py, <a class="struct" href="../../pyo3/struct.PyAny.html" title="struct devela::_dep::pyo3::PyAny">PyAny</a>&gt;, <a class="struct" href="../../pyo3/struct.PyErr.html" title="struct devela::_dep::pyo3::PyErr">PyErr</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;Bound&lt;&#39;py, PyAny&gt;, PyErr&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Converts <code>self</code> into an owned Python object, dropping type information.</div></details><details class="toggle method-toggle" open><summary><section id="method.into_py_any" class="method trait-impl"><a href="#method.into_py_any" class="anchor">§</a><h4 class="code-header">fn <a href="../../pyo3/trait.IntoPyObjectExt.html#method.into_py_any" class="fn">into_py_any</a>(self, py: <a class="struct" href="../../pyo3/struct.Python.html" title="struct devela::_dep::pyo3::Python">Python</a>&lt;'py&gt;) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;<a class="struct" href="../../pyo3/struct.Py.html" title="struct devela::_dep::pyo3::Py">Py</a>&lt;<a class="struct" href="../../pyo3/struct.PyAny.html" title="struct devela::_dep::pyo3::PyAny">PyAny</a>&gt;, <a class="struct" href="../../pyo3/struct.PyErr.html" title="struct devela::_dep::pyo3::PyErr">PyErr</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;Py&lt;PyAny&gt;, PyErr&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Converts <code>self</code> into an owned Python object, dropping type information and unbinding it
from the <code>'py</code> lifetime.</div></details><details class="toggle method-toggle" open><summary><section id="method.into_pyobject_or_pyerr" class="method trait-impl"><a href="#method.into_pyobject_or_pyerr" class="anchor">§</a><h4 class="code-header">fn <a href="../../pyo3/trait.IntoPyObjectExt.html#method.into_pyobject_or_pyerr" class="fn">into_pyobject_or_pyerr</a>(self, py: <a class="struct" href="../../pyo3/struct.Python.html" title="struct devela::_dep::pyo3::Python">Python</a>&lt;'py&gt;) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;Self::<a class="associatedtype" href="../../pyo3/trait.IntoPyObject.html#associatedtype.Output" title="type devela::_dep::pyo3::IntoPyObject::Output">Output</a>, <a class="struct" href="../../pyo3/struct.PyErr.html" title="struct devela::_dep::pyo3::PyErr">PyErr</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;Self::Output, PyErr&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Converts <code>self</code> into a Python object. <a href="../../pyo3/trait.IntoPyObjectExt.html#method.into_pyobject_or_pyerr">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-IntoSample%3CT%3E-for-F" class="impl"><a href="#impl-IntoSample%3CT%3E-for-F" class="anchor">§</a><h3 class="code-header">impl&lt;F, T&gt; <a class="trait" href="../../symphonia/core/conv/trait.IntoSample.html" title="trait devela::_dep::symphonia::core::conv::IntoSample">IntoSample</a>&lt;T&gt; for F<div class="where">where
    T: <a class="trait" href="../../symphonia/core/conv/trait.FromSample.html" title="trait devela::_dep::symphonia::core::conv::FromSample">FromSample</a>&lt;F&gt;,</div></h3></section></summary><div class="impl-items"><section id="method.into_sample" class="method trait-impl"><a href="#method.into_sample" class="anchor">§</a><h4 class="code-header">fn <a href="../../symphonia/core/conv/trait.IntoSample.html#tymethod.into_sample" class="fn">into_sample</a>(self) -&gt; T</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Pointable-for-T" class="impl"><a href="#impl-Pointable-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Pointable for T</h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedconstant.ALIGN" class="associatedconstant trait-impl"><a href="#associatedconstant.ALIGN" class="anchor">§</a><h4 class="code-header">const <a class="constant">ALIGN</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>The alignment of pointer.</div></details><details class="toggle" open><summary><section id="associatedtype.Init" class="associatedtype trait-impl"><a href="#associatedtype.Init" class="anchor">§</a><h4 class="code-header">type <a class="associatedtype">Init</a> = T</h4></section></summary><div class='docblock'>The type for initializers.</div></details><details class="toggle method-toggle" open><summary><section id="method.init" class="method trait-impl"><a href="#method.init" class="anchor">§</a><h4 class="code-header">unsafe fn <a class="fn">init</a>(init: &lt;T as Pointable&gt;::Init) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class='docblock'>Initializes a with the given initializer. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.deref" class="method trait-impl"><a href="#method.deref" class="anchor">§</a><h4 class="code-header">unsafe fn <a class="fn">deref</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a T</a></h4></section></summary><div class='docblock'>Dereferences the given pointer. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.deref_mut" class="method trait-impl"><a href="#method.deref_mut" class="anchor">§</a><h4 class="code-header">unsafe fn <a class="fn">deref_mut</a>&lt;'a&gt;(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a mut T</a></h4></section></summary><div class='docblock'>Mutably dereferences the given pointer. <a>Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.drop" class="method trait-impl"><a href="#method.drop" class="anchor">§</a><h4 class="code-header">unsafe fn <a class="fn">drop</a>(ptr: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>)</h4></section></summary><div class='docblock'>Drops the object pointed to by the given pointer. <a>Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-PyErrArguments-for-T" class="impl"><a href="#impl-PyErrArguments-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../pyo3/trait.PyErrArguments.html" title="trait devela::_dep::pyo3::PyErrArguments">PyErrArguments</a> for T<div class="where">where
    T: for&lt;'py&gt; <a class="trait" href="../../pyo3/trait.IntoPyObject.html" title="trait devela::_dep::pyo3::IntoPyObject">IntoPyObject</a>&lt;'py&gt; + <a class="trait" href="../../../all/trait.Send.html" title="trait devela::all::Send">Send</a> + <a class="trait" href="../../../all/trait.Sync.html" title="trait devela::all::Sync">Sync</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.arguments" class="method trait-impl"><a href="#method.arguments" class="anchor">§</a><h4 class="code-header">fn <a href="../../pyo3/trait.PyErrArguments.html#tymethod.arguments" class="fn">arguments</a>(self, py: <a class="struct" href="../../pyo3/struct.Python.html" title="struct devela::_dep::pyo3::Python">Python</a>&lt;'_&gt;) -&gt; <a class="struct" href="../../pyo3/struct.Py.html" title="struct devela::_dep::pyo3::Py">Py</a>&lt;<a class="struct" href="../../pyo3/struct.PyAny.html" title="struct devela::_dep::pyo3::PyAny">PyAny</a>&gt;</h4></section></summary><div class='docblock'>Arguments for exception</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#82-84">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../all/trait.ToOwned.html" title="trait devela::all::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="../../../code/trait.Clone.html" title="trait devela::code::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#86">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="../../../all/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#87">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="../../../all/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#91">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="../../../all/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToSample%3CU%3E-for-T" class="impl"><a href="#impl-ToSample%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; ToSample&lt;U&gt; for T<div class="where">where
    U: FromSample&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><section id="method.to_sample_" class="method trait-impl"><a href="#method.to_sample_" class="anchor">§</a><h4 class="code-header">fn <a class="fn">to_sample_</a>(self) -&gt; U</h4></section></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToString-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/string.rs.html#2796">Source</a><a href="#impl-ToString-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../../all/trait.ToString.html" title="trait devela::all::ToString">ToString</a> for T<div class="where">where
    T: <a class="trait" href="../../../all/trait.Display.html" title="trait devela::all::Display">Display</a> + ?<a class="trait" href="../../../all/trait.Sized.html" title="trait devela::all::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.to_string" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/string.rs.html#2798">Source</a><a href="#method.to_string" class="anchor">§</a><h4 class="code-header">fn <a href="../../../all/trait.ToString.html#tymethod.to_string" class="fn">to_string</a>(&amp;self) -&gt; <a class="struct" href="../../../all/struct.String.html" title="struct devela::all::String">String</a> <a href="#" class="tooltip" data-notable-ty="String">ⓘ</a></h4></section></summary><div class='docblock'>Converts the given value to a <code>String</code>. <a href="../../../all/trait.ToString.html#tymethod.to_string">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#833-835">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../../../code/trait.TryFrom.html" title="trait devela::code::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="../../../code/trait.Into.html" title="trait devela::code::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-3" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#837">Source</a><a href="#associatedtype.Error-3" class="anchor">§</a><h4 class="code-header">type <a href="../../../code/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="../../../code/enum.Infallible.html" title="enum devela::code::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#840">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="../../../code/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="../../../code/trait.TryFrom.html" title="trait devela::code::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="../../../code/trait.TryFrom.html#associatedtype.Error" title="type devela::code::TryFrom::Error">Error</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;T, &lt;T as TryFrom&lt;U&gt;&gt;::Error&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#817-819">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="../../../code/trait.TryInto.html" title="trait devela::code::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="../../../code/trait.TryFrom.html" title="trait devela::code::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-2" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#821">Source</a><a href="#associatedtype.Error-2" class="anchor">§</a><h4 class="code-header">type <a href="../../../code/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="../../../code/trait.TryFrom.html" title="trait devela::code::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="../../../code/trait.TryFrom.html#associatedtype.Error" title="type devela::code::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#824">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="../../../code/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="../../../code/trait.TryFrom.html" title="trait devela::code::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="../../../code/trait.TryFrom.html#associatedtype.Error" title="type devela::code::TryFrom::Error">Error</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;U, &lt;U as TryFrom&lt;T&gt;&gt;::Error&gt;">ⓘ</a></h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><section id="impl-Duplex%3CS%3E-for-T" class="impl"><a href="#impl-Duplex%3CS%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;S, T&gt; Duplex&lt;S&gt; for T<div class="where">where
    T: FromSample&lt;S&gt; + ToSample&lt;S&gt;,</div></h3></section><section id="impl-Ungil-for-T" class="impl"><a href="#impl-Ungil-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="../../pyo3/marker/trait.Ungil.html" title="trait devela::_dep::pyo3::marker::Ungil">Ungil</a> for T<div class="where">where
    T: <a class="trait" href="../../../all/trait.Send.html" title="trait devela::all::Send">Send</a>,</div></h3></section></div><script type="text/json" id="notable-traits-data">{"&'static str":"<h3>Notable traits for <code><a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a></code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"../../../all/trait.ExtStr.html\" title=\"trait devela::all::ExtStr\">ExtStr</a> for <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.str.html\">str</a></div>","&[u8]":"<h3>Notable traits for <code>&amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"../../../all/trait.IoRead.html\" title=\"trait devela::all::IoRead\">Read</a> for &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>]</div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtSlice.html\" title=\"trait devela::all::ExtSlice\">ExtSlice</a>&lt;T&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtSliceMut.html\" title=\"trait devela::all::ExtSliceMut\">ExtSliceMut</a>&lt;T&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtSlice.html\" title=\"trait devela::all::ExtSlice\">ExtSlice</a>&lt;T&gt; for &amp;<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div>","&mut [u8]":"<h3>Notable traits for <code>&amp;mut [<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"../../../all/trait.IoWrite.html\" title=\"trait devela::all::IoWrite\">Write</a> for &amp;mut [<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>]</div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtSlice.html\" title=\"trait devela::all::ExtSlice\">ExtSlice</a>&lt;T&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtSliceMut.html\" title=\"trait devela::all::ExtSliceMut\">ExtSliceMut</a>&lt;T&gt; for <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtSlice.html\" title=\"trait devela::all::ExtSlice\">ExtSlice</a>&lt;T&gt; for &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtSliceMut.html\" title=\"trait devela::all::ExtSliceMut\">ExtSliceMut</a>&lt;T&gt; for &amp;mut <a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.slice.html\">[T]</a></div>","Either<Self, Self>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../itertools/enum.Either.html\" title=\"enum devela::_dep::itertools::Either\">Either</a>&lt;L, R&gt;</code></h3><pre><code><div class=\"where\">impl&lt;L, R&gt; <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"enum\" href=\"../../itertools/enum.Either.html\" title=\"enum devela::_dep::itertools::Either\">Either</a>&lt;L, R&gt;<div class=\"where\">where\n    L: <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a>,\n    R: <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a>&lt;Item = &lt;L as <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"../../../all/trait.Iterator.html#associatedtype.Item\" title=\"type devela::all::Iterator::Item\">Item</a>&gt;,</div></div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = &lt;L as <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a>&gt;::<a class=\"associatedtype\" href=\"../../../all/trait.Iterator.html#associatedtype.Item\" title=\"type devela::all::Iterator::Item\">Item</a>;</div><div class=\"where\">impl&lt;L, R&gt; <a class=\"trait\" href=\"../../../all/trait.Future.html\" title=\"trait devela::all::Future\">Future</a> for <a class=\"enum\" href=\"../../itertools/enum.Either.html\" title=\"enum devela::_dep::itertools::Either\">Either</a>&lt;L, R&gt;<div class=\"where\">where\n    L: <a class=\"trait\" href=\"../../../all/trait.Future.html\" title=\"trait devela::all::Future\">Future</a>,\n    R: <a class=\"trait\" href=\"../../../all/trait.Future.html\" title=\"trait devela::all::Future\">Future</a>&lt;Output = &lt;L as <a class=\"trait\" href=\"../../../all/trait.Future.html\" title=\"trait devela::all::Future\">Future</a>&gt;::<a class=\"associatedtype\" href=\"../../../all/trait.Future.html#associatedtype.Output\" title=\"type devela::all::Future::Output\">Output</a>&gt;,</div></div><div class=\"where\">    type <a href=\"../../../all/trait.Future.html#associatedtype.Output\" class=\"associatedtype\">Output</a> = &lt;L as <a class=\"trait\" href=\"../../../all/trait.Future.html\" title=\"trait devela::all::Future\">Future</a>&gt;::<a class=\"associatedtype\" href=\"../../../all/trait.Future.html#associatedtype.Output\" title=\"type devela::all::Future::Output\">Output</a>;</div><div class=\"where\">impl&lt;L, R&gt; <a class=\"trait\" href=\"../../../all/trait.IoRead.html\" title=\"trait devela::all::IoRead\">Read</a> for <a class=\"enum\" href=\"../../itertools/enum.Either.html\" title=\"enum devela::_dep::itertools::Either\">Either</a>&lt;L, R&gt;<div class=\"where\">where\n    L: <a class=\"trait\" href=\"../../../all/trait.IoRead.html\" title=\"trait devela::all::IoRead\">Read</a>,\n    R: <a class=\"trait\" href=\"../../../all/trait.IoRead.html\" title=\"trait devela::all::IoRead\">Read</a>,</div></div><div class=\"where\">impl&lt;L, R&gt; <a class=\"trait\" href=\"../../../all/trait.IoWrite.html\" title=\"trait devela::all::IoWrite\">Write</a> for <a class=\"enum\" href=\"../../itertools/enum.Either.html\" title=\"enum devela::_dep::itertools::Either\">Either</a>&lt;L, R&gt;<div class=\"where\">where\n    L: <a class=\"trait\" href=\"../../../all/trait.IoWrite.html\" title=\"trait devela::all::IoWrite\">Write</a>,\n    R: <a class=\"trait\" href=\"../../../all/trait.IoWrite.html\" title=\"trait devela::all::IoWrite\">Write</a>,</div></div>","Option<&T>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtOption.html\" title=\"trait devela::all::ExtOption\">ExtOption</a>&lt;T&gt; for <a class=\"enum\" href=\"../../../all/enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</div>","Option<&mut T>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtOption.html\" title=\"trait devela::all::ExtOption\">ExtOption</a>&lt;T&gt; for <a class=\"enum\" href=\"../../../all/enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</div>","Option<Ordering>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T&gt; <a class=\"trait\" href=\"../../../all/trait.ExtOption.html\" title=\"trait devela::all::ExtOption\">ExtOption</a>&lt;T&gt; for <a class=\"enum\" href=\"../../../all/enum.Option.html\" title=\"enum devela::all::Option\">Option</a>&lt;T&gt;</div>","Result<(), Error>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"../../../all/trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>","Result<<&Time as IntoPyObject<'py>>::Output, <&Time as IntoPyObject<'py>>::Error>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"../../../all/trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>","Result<<Time as IntoPyObject<'py>>::Output, <Time as IntoPyObject<'py>>::Error>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"../../../all/trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>","Result<Bound<'py, PyAny>, PyErr>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"../../../all/trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>","Result<Py<PyAny>, PyErr>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"../../../all/trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>","Result<Self::Output, PyErr>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"../../../all/trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>","Result<Span, Error>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"../../../all/trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>","Result<T, <T as TryFrom<U>>::Error>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"../../../all/trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>","Result<T, PyErr>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"../../../all/trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>","Result<Time, Error>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"../../../all/trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>","Result<Time, PyErr>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"../../../all/trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>","Result<U, <U as TryFrom<T>>::Error>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"../../../all/trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>","String":"<h3>Notable traits for <code><a class=\"struct\" href=\"../../../all/struct.String.html\" title=\"struct devela::all::String\">String</a></code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"../../../all/trait.ExtString.html\" title=\"trait devela::all::ExtString\">ExtString</a> for <a class=\"struct\" href=\"../../../all/struct.String.html\" title=\"struct devela::all::String\">String</a></div>","TimeSeries":"<h3>Notable traits for <code><a class=\"struct\" href=\"struct.TimeSeries.html\" title=\"struct devela::_dep::jiff::civil::TimeSeries\">TimeSeries</a></code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"../../../all/trait.Iterator.html\" title=\"trait devela::all::Iterator\">Iterator</a> for <a class=\"struct\" href=\"struct.TimeSeries.html\" title=\"struct devela::_dep::jiff::civil::TimeSeries\">TimeSeries</a></div><div class=\"where\">    type <a href=\"../../../all/trait.Iterator.html#associatedtype.Item\" class=\"associatedtype\">Item</a> = <a class=\"struct\" href=\"struct.Time.html\" title=\"struct devela::_dep::jiff::civil::Time\">Time</a>;</div>"}</script></section></div></main></body></html>