<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Terminates the current process with the specified exit code."><title>exit in devela::_dep::_std::process - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="devela" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-nightly (f2824da98 2025-08-28)" data-channel="nightly" data-search-js="search-03d23683.js" data-stringdex-js="stringdex-0e748618.js" data-settings-js="settings-c38705f0.js" ><script src="../../../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-044be391.svg"><script>
  document.addEventListener("DOMContentLoaded", async function() {
    // Ensure this script runs only once per page load
    if (window.scriptLoaderInitialized) return;
    window.scriptLoaderInitialized = true;

    /* settings */

    const crateName = "devela";
    const allowedKatex = ["/all", "/media/color", "/num/", "/phys/"];
    const allowedKatexChem = ["/all/", "/phys/"];

    // Find the LAST occurrence of `/devela/` in the path
    const path = window.location.pathname;
    const lastCrateIndex = path.lastIndexOf(`/${crateName}/`);
    if (lastCrateIndex === -1) return;
    // Extract everything after the last `/devela/`
    const relativePath = path.slice(lastCrateIndex + crateName.length + 1);

    /* load resources */

    try {
      if (allowedKatex.some(prefix => relativePath.startsWith(prefix))) {
        await loadKatex().catch(handleMathError);
      }
      if (allowedKatexChem.some(prefix => relativePath.startsWith(prefix))) {
        await loadKatexChem().catch(handleMathError);
      }
    } catch (error) {
      handleMathError(error);
    }

    /* resource loading functions */

    // INFO: https://katex.org/docs/browser.html#starter-template
    // INFO: https://github.com/KaTeX/KaTeX/tree/main/contrib/copy-tex
    async function loadKatex() {
      console.log("Loading KaTeX for:", relativePath);

      // Load CSS, and scripts sequentially
      const katexCSS = document.createElement("link");
      katexCSS.rel = "stylesheet";
      katexCSS.href = "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css";
      katexCSS.integrity = "sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib";
      katexCSS.crossOrigin = "anonymous";
      document.head.appendChild(katexCSS);

      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js",
        integrity: "sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh"
      });
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js",
        integrity: "sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh"
      });
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/copy-tex.min.js",
        integrity: "sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi"
      });

      // Initialize KaTeX
      renderMathInElement(document.body, {
        delimiters: [
          {left: "$$", right: "$$", display: true},
          {left: "$", right: "$", display: false},
          {left: "\\(", right: "\\)", display: false},
          {left: "\\[", right: "\\]", display: true}
        ],
        trust: (context) => context.command === "\\href"
      });
      // Add custom styles: https://katex.org/docs/issues.html#css-customization
      const katexStyle = document.createElement("style");
      katexStyle.textContent = `
        .katex-display { overflow: hidden; }
        .docblock p { overflow-y: hidden; }
      `;
      document.head.appendChild(katexStyle);
    }

    // INFO: https://github.com/KaTeX/KaTeX/blob/main/contrib/mhchem/README.md
    async function loadKatexChem() {
      console.log("Loading KaTeX MhChem plugin for:", relativePath);
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/mhchem.min.js",
        integrity: "sha384-F2ptQFZqNJuqfGGl28mIXyQ5kXH48spn7rcoS0Y9psqIKAcZPLd1NzwFlm/bl1mH"
      });
    }

    /* helper functions */

    function loadScript(config) {
      return new Promise((resolve, reject) => {
        const script = document.createElement("script");
        script.src = config.src;
        if (config.integrity) {
          script.integrity = config.integrity;
          script.crossOrigin = "anonymous";
        }
        script.onload = resolve;
        script.onerror = () => reject(new Error(`Failed to load script: ${config.src}`));
        document.head.appendChild(script);
      });
    }
    function handleMathError(error) {
      console.error("Math rendering error:", error);
    }
  });
</script>

</head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">exit</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../devela/index.html">devela</a><span class="version">0.25.0-wip</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">exit</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#platform-specific-behavior" title="Platform-specific behavior">Platform-specific behavior</a><ul><li><a href="#safe-interop-with-c-code" title="Safe interop with C code">Safe interop with C code</a></li></ul></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In devela::<wbr>_<wbr>dep::<wbr>_<wbr>std::<wbr>process</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../../index.html">devela</a>::<wbr><a href="../../index.html">_dep</a>::<wbr><a href="../index.html">_std</a>::<wbr><a href="index.html">process</a></div><h1>Function <span class="fn">exit</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/process.rs.html#2432">Source</a> </span></div><pre class="rust item-decl"><code>pub fn exit(code: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.i32.html">i32</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.never.html">!</a></code></pre><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>std</code></strong> only.</div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Terminates the current process with the specified exit code.</p>
<p>This function will never return and will immediately terminate the current
process. The exit code is passed through to the underlying OS and will be
available for consumption by another process.</p>
<p>Note that because this function never returns, and that it terminates the
process, no destructors on the current stack or any other thread’s stack
will be run. If a clean shutdown is needed it is recommended to only call
this function at a known point where there are no more destructors left
to run; or, preferably, simply return a type implementing <a href="../../../all/trait.ProcessTermination.html" title="trait devela::all::ProcessTermination"><code>Termination</code></a>
(such as <a href="../../../all/struct.ProcessExitCode.html" title="struct devela::all::ProcessExitCode"><code>ExitCode</code></a> or <code>Result</code>) from the <code>main</code> function and avoid this
function altogether:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), MyError&gt; {
    <span class="comment">// ...
    </span><span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>In its current implementation, this function will execute exit handlers registered with <code>atexit</code>
as well as other platform-specific exit handlers (e.g. <code>fini</code> sections of ELF shared objects).
This means that Rust requires that all exit handlers are safe to execute at any time. In
particular, if an exit handler cleans up some state that might be concurrently accessed by other
threads, it is required that the exit handler performs suitable synchronization with those
threads. (The alternative to this requirement would be to not run exit handlers at all, which is
considered undesirable. Note that returning from <code>main</code> also calls <code>exit</code>, so making <code>exit</code> an
unsafe operation is not an option.)</p>
<h3 id="platform-specific-behavior"><a class="doc-anchor" href="#platform-specific-behavior">§</a>Platform-specific behavior</h3>
<p><strong>Unix</strong>: On Unix-like platforms, it is unlikely that all 32 bits of <code>exit</code>
will be visible to a parent process inspecting the exit code. On most
Unix-like platforms, only the eight least-significant bits are considered.</p>
<p>For example, the exit code for this example will be <code>0</code> on Linux, but <code>256</code>
on Windows:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::process;

process::exit(<span class="number">0x0100</span>);</code></pre></div>
<h4 id="safe-interop-with-c-code"><a class="doc-anchor" href="#safe-interop-with-c-code">§</a>Safe interop with C code</h4>
<p>On Unix, this function is currently implemented using the <code>exit</code> C function <a href="https://en.cppreference.com/w/c/program/exit"><code>exit</code></a>. As
of C23, the C standard does not permit multiple threads to call <code>exit</code> concurrently. Rust
mitigates this with a lock, but if C code calls <code>exit</code>, that can still cause undefined behavior.
Note that returning from <code>main</code> is equivalent to calling <code>exit</code>.</p>
<p>Therefore, it is undefined behavior to have two concurrent threads perform the following
without synchronization:</p>
<ul>
<li>One thread calls Rust’s <code>exit</code> function or returns from Rust’s <code>main</code> function</li>
<li>Another thread calls the C function <code>exit</code> or <code>quick_exit</code>, or returns from C’s <code>main</code> function</li>
</ul>
<p>Note that if a binary contains multiple copies of the Rust runtime (e.g., when combining
multiple <code>cdylib</code> or <code>staticlib</code>), they each have their own separate lock, so from the
perspective of code running in one of the Rust runtimes, the “outside” Rust code is basically C
code, and concurrent <code>exit</code> again causes undefined behavior.</p>
<p>Individual C implementations might provide more guarantees than the standard and permit concurrent
calls to <code>exit</code>; consult the documentation of your C implementation for details.</p>
<p>For some of the on-going discussion to make <code>exit</code> thread-safe in C, see:</p>
<ul>
<li><a href="https://github.com/rust-lang/rust/issues/126600">Rust issue #126600</a></li>
<li><a href="https://austingroupbugs.net/view.php?id=1845">Austin Group Bugzilla (for POSIX)</a></li>
<li><a href="https://sourceware.org/bugzilla/show_bug.cgi?id=31997">GNU C library Bugzilla</a></li>
</ul>
</div></details></section></div></main></body></html>