<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Swaps the values at two mutable locations of the same type, without deinitializing either."><title>swap in devela::_dep::_std::ptr - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="devela" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-nightly (fe5536432 2025-08-29)" data-channel="nightly" data-search-js="search-03d23683.js" data-stringdex-js="stringdex-0e748618.js" data-settings-js="settings-c38705f0.js" ><script src="../../../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-044be391.svg"><script>
  document.addEventListener("DOMContentLoaded", async function() {
    // Ensure this script runs only once per page load
    if (window.scriptLoaderInitialized) return;
    window.scriptLoaderInitialized = true;

    /* settings */

    const crateName = "devela";
    const allowedKatex = ["/all", "/media/color", "/num/", "/phys/"];
    const allowedKatexChem = ["/all/", "/phys/"];

    // Find the LAST occurrence of `/devela/` in the path
    const path = window.location.pathname;
    const lastCrateIndex = path.lastIndexOf(`/${crateName}/`);
    if (lastCrateIndex === -1) return;
    // Extract everything after the last `/devela/`
    const relativePath = path.slice(lastCrateIndex + crateName.length + 1);

    /* load resources */

    try {
      if (allowedKatex.some(prefix => relativePath.startsWith(prefix))) {
        await loadKatex().catch(handleMathError);
      }
      if (allowedKatexChem.some(prefix => relativePath.startsWith(prefix))) {
        await loadKatexChem().catch(handleMathError);
      }
    } catch (error) {
      handleMathError(error);
    }

    /* resource loading functions */

    // INFO: https://katex.org/docs/browser.html#starter-template
    // INFO: https://github.com/KaTeX/KaTeX/tree/main/contrib/copy-tex
    async function loadKatex() {
      console.log("Loading KaTeX for:", relativePath);

      // Load CSS, and scripts sequentially
      const katexCSS = document.createElement("link");
      katexCSS.rel = "stylesheet";
      katexCSS.href = "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css";
      katexCSS.integrity = "sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib";
      katexCSS.crossOrigin = "anonymous";
      document.head.appendChild(katexCSS);

      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js",
        integrity: "sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh"
      });
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js",
        integrity: "sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh"
      });
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/copy-tex.min.js",
        integrity: "sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi"
      });

      // Initialize KaTeX
      renderMathInElement(document.body, {
        delimiters: [
          {left: "$$", right: "$$", display: true},
          {left: "$", right: "$", display: false},
          {left: "\\(", right: "\\)", display: false},
          {left: "\\[", right: "\\]", display: true}
        ],
        trust: (context) => context.command === "\\href"
      });
      // Add custom styles: https://katex.org/docs/issues.html#css-customization
      const katexStyle = document.createElement("style");
      katexStyle.textContent = `
        .katex-display { overflow: hidden; }
        .docblock p { overflow-y: hidden; }
      `;
      document.head.appendChild(katexStyle);
    }

    // INFO: https://github.com/KaTeX/KaTeX/blob/main/contrib/mhchem/README.md
    async function loadKatexChem() {
      console.log("Loading KaTeX MhChem plugin for:", relativePath);
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/mhchem.min.js",
        integrity: "sha384-F2ptQFZqNJuqfGGl28mIXyQ5kXH48spn7rcoS0Y9psqIKAcZPLd1NzwFlm/bl1mH"
      });
    }

    /* helper functions */

    function loadScript(config) {
      return new Promise((resolve, reject) => {
        const script = document.createElement("script");
        script.src = config.src;
        if (config.integrity) {
          script.integrity = config.integrity;
          script.crossOrigin = "anonymous";
        }
        script.onload = resolve;
        script.onerror = () => reject(new Error(`Failed to load script: ${config.src}`));
        document.head.appendChild(script);
      });
    }
    function handleMathError(error) {
      console.error("Math rendering error:", error);
    }
  });
</script>

</head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">swap</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../devela/index.html">devela</a><span class="version">0.25.0-wip</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">swap</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#safety" title="Safety">Safety</a></li><li><a href="#examples" title="Examples">Examples</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In devela::<wbr>_<wbr>dep::<wbr>_<wbr>std::<wbr>ptr</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../../index.html">devela</a>::<wbr><a href="../../index.html">_dep</a>::<wbr><a href="../index.html">_std</a>::<wbr><a href="index.html">ptr</a></div><h1>Function <span class="fn">swap</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><span class="since" title="Stable since Rust version 1.0.0, const since 1.85.0">1.0.0 (const: 1.85.0)</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/ptr/mod.rs.html#1293">Source</a> </span></div><pre class="rust item-decl"><code>pub const unsafe fn swap&lt;T&gt;(x: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut T</a>, y: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut T</a>)</code></pre><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>std</code></strong> only.</div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Swaps the values at two mutable locations of the same type, without
deinitializing either.</p>
<p>But for the following exceptions, this function is semantically
equivalent to <a href="../../../_core/mem/fn.swap.html" title="fn devela::_core::mem::swap"><code>mem::swap</code></a>:</p>
<ul>
<li>
<p>It operates on raw pointers instead of references. When references are
available, <a href="../../../_core/mem/fn.swap.html" title="fn devela::_core::mem::swap"><code>mem::swap</code></a> should be preferred.</p>
</li>
<li>
<p>The two pointed-to values may overlap. If the values do overlap, then the
overlapping region of memory from <code>x</code> will be used. This is demonstrated
in the second example below.</p>
</li>
<li>
<p>The operation is “untyped” in the sense that data may be uninitialized or otherwise violate
the requirements of <code>T</code>. The initialization state is preserved exactly.</p>
</li>
</ul>
<h2 id="safety"><a class="doc-anchor" href="#safety">§</a>Safety</h2>
<p>Behavior is undefined if any of the following conditions are violated:</p>
<ul>
<li>
<p>Both <code>x</code> and <code>y</code> must be <a href="../../../_core/ptr/index.html#safety" title="mod devela::_core::ptr">valid</a> for both reads and writes. They must remain valid even when the
other pointer is written. (This means if the memory ranges overlap, the two pointers must not
be subject to aliasing restrictions relative to each other.)</p>
</li>
<li>
<p>Both <code>x</code> and <code>y</code> must be properly aligned.</p>
</li>
</ul>
<p>Note that even if <code>T</code> has size <code>0</code>, the pointers must be properly aligned.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<p>Swapping two non-overlapping regions:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::ptr;

<span class="kw">let </span><span class="kw-2">mut </span>array = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

<span class="kw">let </span>(x, y) = array.split_at_mut(<span class="number">2</span>);
<span class="kw">let </span>x = x.as_mut_ptr().cast::&lt;[u32; <span class="number">2</span>]&gt;(); <span class="comment">// this is `array[0..2]`
</span><span class="kw">let </span>y = y.as_mut_ptr().cast::&lt;[u32; <span class="number">2</span>]&gt;(); <span class="comment">// this is `array[2..4]`

</span><span class="kw">unsafe </span>{
    ptr::swap(x, y);
    <span class="macro">assert_eq!</span>([<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>], array);
}</code></pre></div>
<p>Swapping two overlapping regions:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::ptr;

<span class="kw">let </span><span class="kw-2">mut </span>array: [i32; <span class="number">4</span>] = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

<span class="kw">let </span>array_ptr: <span class="kw-2">*mut </span>i32 = array.as_mut_ptr();

<span class="kw">let </span>x = array_ptr <span class="kw">as </span><span class="kw-2">*mut </span>[i32; <span class="number">3</span>]; <span class="comment">// this is `array[0..3]`
</span><span class="kw">let </span>y = <span class="kw">unsafe </span>{ array_ptr.add(<span class="number">1</span>) } <span class="kw">as </span><span class="kw-2">*mut </span>[i32; <span class="number">3</span>]; <span class="comment">// this is `array[1..4]`

</span><span class="kw">unsafe </span>{
    ptr::swap(x, y);
    <span class="comment">// The indices `1..3` of the slice overlap between `x` and `y`.
    // Reasonable results would be for to them be `[2, 3]`, so that indices `0..3` are
    // `[1, 2, 3]` (matching `y` before the `swap`); or for them to be `[0, 1]`
    // so that indices `1..4` are `[0, 1, 2]` (matching `x` before the `swap`).
    // This implementation is defined to make the latter choice.
    </span><span class="macro">assert_eq!</span>([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], array);
}</code></pre></div>
</div></details></section></div></main></body></html>