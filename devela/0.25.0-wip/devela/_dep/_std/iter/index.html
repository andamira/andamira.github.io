<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Composable external iteration."><title>devela::_dep::_std::iter - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="devela" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-nightly (f2824da98 2025-08-28)" data-channel="nightly" data-search-js="search-03d23683.js" data-stringdex-js="stringdex-0e748618.js" data-settings-js="settings-c38705f0.js" ><script src="../../../../static.files/storage-e2aeef58.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-044be391.svg"><script>
  document.addEventListener("DOMContentLoaded", async function() {
    // Ensure this script runs only once per page load
    if (window.scriptLoaderInitialized) return;
    window.scriptLoaderInitialized = true;

    /* settings */

    const crateName = "devela";
    const allowedKatex = ["/all", "/media/color", "/num/", "/phys/"];
    const allowedKatexChem = ["/all/", "/phys/"];

    // Find the LAST occurrence of `/devela/` in the path
    const path = window.location.pathname;
    const lastCrateIndex = path.lastIndexOf(`/${crateName}/`);
    if (lastCrateIndex === -1) return;
    // Extract everything after the last `/devela/`
    const relativePath = path.slice(lastCrateIndex + crateName.length + 1);

    /* load resources */

    try {
      if (allowedKatex.some(prefix => relativePath.startsWith(prefix))) {
        await loadKatex().catch(handleMathError);
      }
      if (allowedKatexChem.some(prefix => relativePath.startsWith(prefix))) {
        await loadKatexChem().catch(handleMathError);
      }
    } catch (error) {
      handleMathError(error);
    }

    /* resource loading functions */

    // INFO: https://katex.org/docs/browser.html#starter-template
    // INFO: https://github.com/KaTeX/KaTeX/tree/main/contrib/copy-tex
    async function loadKatex() {
      console.log("Loading KaTeX for:", relativePath);

      // Load CSS, and scripts sequentially
      const katexCSS = document.createElement("link");
      katexCSS.rel = "stylesheet";
      katexCSS.href = "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css";
      katexCSS.integrity = "sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib";
      katexCSS.crossOrigin = "anonymous";
      document.head.appendChild(katexCSS);

      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js",
        integrity: "sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh"
      });
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js",
        integrity: "sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh"
      });
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/copy-tex.min.js",
        integrity: "sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi"
      });

      // Initialize KaTeX
      renderMathInElement(document.body, {
        delimiters: [
          {left: "$$", right: "$$", display: true},
          {left: "$", right: "$", display: false},
          {left: "\\(", right: "\\)", display: false},
          {left: "\\[", right: "\\]", display: true}
        ],
        trust: (context) => context.command === "\\href"
      });
      // Add custom styles: https://katex.org/docs/issues.html#css-customization
      const katexStyle = document.createElement("style");
      katexStyle.textContent = `
        .katex-display { overflow: hidden; }
        .docblock p { overflow-y: hidden; }
      `;
      document.head.appendChild(katexStyle);
    }

    // INFO: https://github.com/KaTeX/KaTeX/blob/main/contrib/mhchem/README.md
    async function loadKatexChem() {
      console.log("Loading KaTeX MhChem plugin for:", relativePath);
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/mhchem.min.js",
        integrity: "sha384-F2ptQFZqNJuqfGGl28mIXyQ5kXH48spn7rcoS0Y9psqIKAcZPLd1NzwFlm/bl1mH"
      });
    }

    /* helper functions */

    function loadScript(config) {
      return new Promise((resolve, reject) => {
        const script = document.createElement("script");
        script.src = config.src;
        if (config.integrity) {
          script.integrity = config.integrity;
          script.crossOrigin = "anonymous";
        }
        script.onload = resolve;
        script.onerror = () => reject(new Error(`Failed to load script: ${config.src}`));
        document.head.appendChild(script);
      });
    }
    function handleMathError(error) {
      console.error("Math rendering error:", error);
    }
  });
</script>

</head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Module iter</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../devela/index.html">devela</a><span class="version">0.25.0-wip</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module iter</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#organization" title="Organization">Organization</a></li><li><a href="#iterator" title="Iterator">Iterator</a></li><li><a href="#the-three-forms-of-iteration" title="The three forms of iteration">The three forms of iteration</a></li><li><a href="#implementing-iterator" title="Implementing Iterator">Implementing Iterator</a></li><li><a href="#for-loops-and-intoiterator" title="`for` loops and `IntoIterator`"><code>for</code> loops and <code>IntoIterator</code></a></li><li><a href="#iterating-by-reference" title="Iterating by reference">Iterating by reference</a></li><li><a href="#adapters" title="Adapters">Adapters</a></li><li><a href="#laziness" title="Laziness">Laziness</a></li><li><a href="#infinity" title="Infinity">Infinity</a></li></ul><h3><a href="#macros">Module Items</a></h3><ul class="block"><li><a href="#macros" title="Macros">Macros</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In devela::<wbr>_<wbr>dep::<wbr>_<wbr>std</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../../index.html">devela</a>::<wbr><a href="../../index.html">_dep</a>::<wbr><a href="../index.html">_std</a></div><h1>Module <span>iter</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/lib.rs.html#343">Source</a> </span></div><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>std</code></strong> only.</div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Composable external iteration.</p>
<p>If you’ve found yourself with a collection of some kind, and needed to
perform an operation on the elements of said collection, you’ll quickly run
into ‘iterators’. Iterators are heavily used in idiomatic Rust code, so
it’s worth becoming familiar with them.</p>
<p>Before explaining more, let’s talk about how this module is structured:</p>
<h2 id="organization"><a class="doc-anchor" href="#organization">§</a>Organization</h2>
<p>This module is largely organized by type:</p>
<ul>
<li><a href="#traits">Traits</a> are the core portion: these traits define what kind of iterators
exist and what you can do with them. The methods of these traits are worth
putting some extra study time into.</li>
<li><a href="#functions">Functions</a> provide some helpful ways to create some basic iterators.</li>
<li><a href="#structs">Structs</a> are often the return types of the various methods on this
module’s traits. You’ll usually want to look at the method that creates
the <code>struct</code>, rather than the <code>struct</code> itself. For more detail about why,
see ‘<a href="#implementing-iterator">Implementing Iterator</a>’.</li>
</ul>
<p>That’s it! Let’s dig into iterators.</p>
<h2 id="iterator"><a class="doc-anchor" href="#iterator">§</a>Iterator</h2>
<p>The heart and soul of this module is the <a href="../../../all/trait.Iterator.html" title="trait devela::all::Iterator"><code>Iterator</code></a> trait. The core of
<a href="../../../all/trait.Iterator.html" title="trait devela::all::Iterator"><code>Iterator</code></a> looks like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">trait </span>Iterator {
    <span class="kw">type </span>Item;
    <span class="kw">fn </span>next(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; <span class="prelude-ty">Option</span>&lt;<span class="self">Self</span>::Item&gt;;
}</code></pre></div>
<p>An iterator has a method, <a href="../../../all/trait.Iterator.html#tymethod.next" title="method devela::all::Iterator::next"><code>next</code></a>, which when called, returns an
<code><a href="../../../all/enum.Option.html" title="enum devela::all::Option">Option</a>&lt;Item&gt;</code>. Calling <a href="../../../all/trait.Iterator.html#tymethod.next" title="method devela::all::Iterator::next"><code>next</code></a> will return <a href="../../../all/enum.Option.html#variant.Some" title="variant devela::all::Option::Some"><code>Some(Item)</code></a> as long as there
are elements, and once they’ve all been exhausted, will return <code>None</code> to
indicate that iteration is finished. Individual iterators may choose to
resume iteration, and so calling <a href="../../../all/trait.Iterator.html#tymethod.next" title="method devela::all::Iterator::next"><code>next</code></a> again may or may not eventually
start returning <a href="../../../all/enum.Option.html#variant.Some" title="variant devela::all::Option::Some"><code>Some(Item)</code></a> again at some point (for example, see <a href="../../std/sync/mpsc/struct.TryIter.html"><code>TryIter</code></a>).</p>
<p><a href="../../../all/trait.Iterator.html" title="trait devela::all::Iterator"><code>Iterator</code></a>’s full definition includes a number of other methods as well,
but they are default methods, built on top of <a href="../../../all/trait.Iterator.html#tymethod.next" title="method devela::all::Iterator::next"><code>next</code></a>, and so you get
them for free.</p>
<p>Iterators are also composable, and it’s common to chain them together to do
more complex forms of processing. See the <a href="#adapters">Adapters</a> section
below for more details.</p>
<h2 id="the-three-forms-of-iteration"><a class="doc-anchor" href="#the-three-forms-of-iteration">§</a>The three forms of iteration</h2>
<p>There are three common methods which can create iterators from a collection:</p>
<ul>
<li><code>iter()</code>, which iterates over <code>&amp;T</code>.</li>
<li><code>iter_mut()</code>, which iterates over <code>&amp;mut T</code>.</li>
<li><code>into_iter()</code>, which iterates over <code>T</code>.</li>
</ul>
<p>Various things in the standard library may implement one or more of the
three, where appropriate.</p>
<h2 id="implementing-iterator"><a class="doc-anchor" href="#implementing-iterator">§</a>Implementing Iterator</h2>
<p>Creating an iterator of your own involves two steps: creating a <code>struct</code> to
hold the iterator’s state, and then implementing <a href="../../../all/trait.Iterator.html" title="trait devela::all::Iterator"><code>Iterator</code></a> for that <code>struct</code>.
This is why there are so many <code>struct</code>s in this module: there is one for
each iterator and iterator adapter.</p>
<p>Let’s make an iterator named <code>Counter</code> which counts from <code>1</code> to <code>5</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// First, the struct:

</span><span class="doccomment">/// An iterator which counts from one to five
</span><span class="kw">struct </span>Counter {
    count: usize,
}

<span class="comment">// we want our count to start at one, so let's add a new() method to help.
// This isn't strictly necessary, but is convenient. Note that we start
// `count` at zero, we'll see why in `next()`'s implementation below.
</span><span class="kw">impl </span>Counter {
    <span class="kw">fn </span>new() -&gt; Counter {
        Counter { count: <span class="number">0 </span>}
    }
}

<span class="comment">// Then, we implement `Iterator` for our `Counter`:

</span><span class="kw">impl </span>Iterator <span class="kw">for </span>Counter {
    <span class="comment">// we will be counting with usize
    </span><span class="kw">type </span>Item = usize;

    <span class="comment">// next() is the only required method
    </span><span class="kw">fn </span>next(<span class="kw-2">&amp;mut </span><span class="self">self</span>) -&gt; <span class="prelude-ty">Option</span>&lt;<span class="self">Self</span>::Item&gt; {
        <span class="comment">// Increment our count. This is why we started at zero.
        </span><span class="self">self</span>.count += <span class="number">1</span>;

        <span class="comment">// Check to see if we've finished counting or not.
        </span><span class="kw">if </span><span class="self">self</span>.count &lt; <span class="number">6 </span>{
            <span class="prelude-val">Some</span>(<span class="self">self</span>.count)
        } <span class="kw">else </span>{
            <span class="prelude-val">None
        </span>}
    }
}

<span class="comment">// And now we can use it!

</span><span class="kw">let </span><span class="kw-2">mut </span>counter = Counter::new();

<span class="macro">assert_eq!</span>(counter.next(), <span class="prelude-val">Some</span>(<span class="number">1</span>));
<span class="macro">assert_eq!</span>(counter.next(), <span class="prelude-val">Some</span>(<span class="number">2</span>));
<span class="macro">assert_eq!</span>(counter.next(), <span class="prelude-val">Some</span>(<span class="number">3</span>));
<span class="macro">assert_eq!</span>(counter.next(), <span class="prelude-val">Some</span>(<span class="number">4</span>));
<span class="macro">assert_eq!</span>(counter.next(), <span class="prelude-val">Some</span>(<span class="number">5</span>));
<span class="macro">assert_eq!</span>(counter.next(), <span class="prelude-val">None</span>);</code></pre></div>
<p>Calling <a href="../../../all/trait.Iterator.html#tymethod.next" title="method devela::all::Iterator::next"><code>next</code></a> this way gets repetitive. Rust has a construct which can
call <a href="../../../all/trait.Iterator.html#tymethod.next" title="method devela::all::Iterator::next"><code>next</code></a> on your iterator, until it reaches <code>None</code>. Let’s go over that
next.</p>
<p>Also note that <code>Iterator</code> provides a default implementation of methods such as <code>nth</code> and <code>fold</code>
which call <code>next</code> internally. However, it is also possible to write a custom implementation of
methods like <code>nth</code> and <code>fold</code> if an iterator can compute them more efficiently without calling
<code>next</code>.</p>
<h2 id="for-loops-and-intoiterator"><a class="doc-anchor" href="#for-loops-and-intoiterator">§</a><code>for</code> loops and <code>IntoIterator</code></h2>
<p>Rust’s <code>for</code> loop syntax is actually sugar for iterators. Here’s a basic
example of <code>for</code>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>values = <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];

<span class="kw">for </span>x <span class="kw">in </span>values {
    <span class="macro">println!</span>(<span class="string">"{x}"</span>);
}</code></pre></div>
<p>This will print the numbers one through five, each on their own line. But
you’ll notice something here: we never called anything on our vector to
produce an iterator. What gives?</p>
<p>There’s a trait in the standard library for converting something into an
iterator: <a href="../../../all/trait.IteratorInto.html" title="trait devela::all::IteratorInto"><code>IntoIterator</code></a>. This trait has one method, <a href="../../../all/trait.IteratorInto.html#tymethod.into_iter" title="method devela::all::IteratorInto::into_iter"><code>into_iter</code></a>,
which converts the thing implementing <a href="../../../all/trait.IteratorInto.html" title="trait devela::all::IteratorInto"><code>IntoIterator</code></a> into an iterator.
Let’s take a look at that <code>for</code> loop again, and what the compiler converts
it into:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>values = <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];

<span class="kw">for </span>x <span class="kw">in </span>values {
    <span class="macro">println!</span>(<span class="string">"{x}"</span>);
}</code></pre></div>
<p>Rust de-sugars this into:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>values = <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
{
    <span class="kw">let </span>result = <span class="kw">match </span>IntoIterator::into_iter(values) {
        <span class="kw-2">mut </span>iter =&gt; <span class="kw">loop </span>{
            <span class="kw">let </span>next;
            <span class="kw">match </span>iter.next() {
                <span class="prelude-val">Some</span>(val) =&gt; next = val,
                <span class="prelude-val">None </span>=&gt; <span class="kw">break</span>,
            };
            <span class="kw">let </span>x = next;
            <span class="kw">let </span>() = { <span class="macro">println!</span>(<span class="string">"{x}"</span>); };
        },
    };
    result
}</code></pre></div>
<p>First, we call <code>into_iter()</code> on the value. Then, we match on the iterator
that returns, calling <a href="../../../all/trait.Iterator.html#tymethod.next" title="method devela::all::Iterator::next"><code>next</code></a> over and over until we see a <code>None</code>. At
that point, we <code>break</code> out of the loop, and we’re done iterating.</p>
<p>There’s one more subtle bit here: the standard library contains an
interesting implementation of <a href="../../../all/trait.IteratorInto.html" title="trait devela::all::IteratorInto"><code>IntoIterator</code></a>:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">impl</span>&lt;I: Iterator&gt; IntoIterator <span class="kw">for </span>I</code></pre></div>
<p>In other words, all <a href="../../../all/trait.Iterator.html" title="trait devela::all::Iterator"><code>Iterator</code></a>s implement <a href="../../../all/trait.IteratorInto.html" title="trait devela::all::IteratorInto"><code>IntoIterator</code></a>, by just
returning themselves. This means two things:</p>
<ol>
<li>If you’re writing an <a href="../../../all/trait.Iterator.html" title="trait devela::all::Iterator"><code>Iterator</code></a>, you can use it with a <code>for</code> loop.</li>
<li>If you’re creating a collection, implementing <a href="../../../all/trait.IteratorInto.html" title="trait devela::all::IteratorInto"><code>IntoIterator</code></a> for it
will allow your collection to be used with the <code>for</code> loop.</li>
</ol>
<h2 id="iterating-by-reference"><a class="doc-anchor" href="#iterating-by-reference">§</a>Iterating by reference</h2>
<p>Since <a href="../../../all/trait.IteratorInto.html#tymethod.into_iter" title="method devela::all::IteratorInto::into_iter"><code>into_iter()</code></a> takes <code>self</code> by value, using a <code>for</code> loop to iterate
over a collection consumes that collection. Often, you may want to iterate
over a collection without consuming it. Many collections offer methods that
provide iterators over references, conventionally called <code>iter()</code> and
<code>iter_mut()</code> respectively:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>values = <span class="macro">vec!</span>[<span class="number">41</span>];
<span class="kw">for </span>x <span class="kw">in </span>values.iter_mut() {
    <span class="kw-2">*</span>x += <span class="number">1</span>;
}
<span class="kw">for </span>x <span class="kw">in </span>values.iter() {
    <span class="macro">assert_eq!</span>(<span class="kw-2">*</span>x, <span class="number">42</span>);
}
<span class="macro">assert_eq!</span>(values.len(), <span class="number">1</span>); <span class="comment">// `values` is still owned by this function.</span></code></pre></div>
<p>If a collection type <code>C</code> provides <code>iter()</code>, it usually also implements
<code>IntoIterator</code> for <code>&amp;C</code>, with an implementation that just calls <code>iter()</code>.
Likewise, a collection <code>C</code> that provides <code>iter_mut()</code> generally implements
<code>IntoIterator</code> for <code>&amp;mut C</code> by delegating to <code>iter_mut()</code>. This enables a
convenient shorthand:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>values = <span class="macro">vec!</span>[<span class="number">41</span>];
<span class="kw">for </span>x <span class="kw">in </span><span class="kw-2">&amp;mut </span>values {
    <span class="comment">//   ^ same as `values.iter_mut()`
    </span><span class="kw-2">*</span>x += <span class="number">1</span>;
}
<span class="kw">for </span>x <span class="kw">in </span><span class="kw-2">&amp;</span>values {
    <span class="comment">//   ^ same as `values.iter()`
    </span><span class="macro">assert_eq!</span>(<span class="kw-2">*</span>x, <span class="number">42</span>);
}
<span class="macro">assert_eq!</span>(values.len(), <span class="number">1</span>);</code></pre></div>
<p>While many collections offer <code>iter()</code>, not all offer <code>iter_mut()</code>. For
example, mutating the keys of a <a href="../../std/collections/struct.HashSet.html"><code>HashSet&lt;T&gt;</code></a> could put the collection
into an inconsistent state if the key hashes change, so this collection
only offers <code>iter()</code>.</p>
<h2 id="adapters"><a class="doc-anchor" href="#adapters">§</a>Adapters</h2>
<p>Functions which take an <a href="../../../all/trait.Iterator.html" title="trait devela::all::Iterator"><code>Iterator</code></a> and return another <a href="../../../all/trait.Iterator.html" title="trait devela::all::Iterator"><code>Iterator</code></a> are
often called ‘iterator adapters’, as they’re a form of the ‘adapter
pattern’.</p>
<p>Common iterator adapters include <a href="../../../all/trait.Iterator.html#method.map" title="method devela::all::Iterator::map"><code>map</code></a>, <a href="../../../all/trait.Iterator.html#method.take" title="method devela::all::Iterator::take"><code>take</code></a>, and <a href="../../../all/trait.Iterator.html#method.filter" title="method devela::all::Iterator::filter"><code>filter</code></a>.
For more, see their documentation.</p>
<p>If an iterator adapter panics, the iterator will be in an unspecified (but
memory safe) state.  This state is also not guaranteed to stay the same
across versions of Rust, so you should avoid relying on the exact values
returned by an iterator which panicked.</p>
<h2 id="laziness"><a class="doc-anchor" href="#laziness">§</a>Laziness</h2>
<p>Iterators (and iterator <a href="#adapters">adapters</a>) are <em>lazy</em>. This means that
just creating an iterator doesn’t <em>do</em> a whole lot. Nothing really happens
until you call <a href="../../../all/trait.Iterator.html#tymethod.next" title="method devela::all::Iterator::next"><code>next</code></a>. This is sometimes a source of confusion when
creating an iterator solely for its side effects. For example, the <a href="../../../all/trait.Iterator.html#method.map" title="method devela::all::Iterator::map"><code>map</code></a>
method calls a closure on each element it iterates over:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v = <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
v.iter().map(|x| <span class="macro">println!</span>(<span class="string">"{x}"</span>));</code></pre></div>
<p>This will not print any values, as we only created an iterator, rather than
using it. The compiler will warn us about this kind of behavior:</p>
<div class="example-wrap"><pre class="language-text"><code>warning: unused result that must be used: iterators are lazy and
do nothing unless consumed</code></pre></div>
<p>The idiomatic way to write a <a href="../../../all/trait.Iterator.html#method.map" title="method devela::all::Iterator::map"><code>map</code></a> for its side effects is to use a
<code>for</code> loop or call the <a href="../../../all/trait.Iterator.html#method.for_each" title="method devela::all::Iterator::for_each"><code>for_each</code></a> method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>v = <span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];

v.iter().for_each(|x| <span class="macro">println!</span>(<span class="string">"{x}"</span>));
<span class="comment">// or
</span><span class="kw">for </span>x <span class="kw">in </span><span class="kw-2">&amp;</span>v {
    <span class="macro">println!</span>(<span class="string">"{x}"</span>);
}</code></pre></div>
<p>Another common way to evaluate an iterator is to use the <a href="../../../all/trait.Iterator.html#method.collect" title="method devela::all::Iterator::collect"><code>collect</code></a>
method to produce a new collection.</p>
<h2 id="infinity"><a class="doc-anchor" href="#infinity">§</a>Infinity</h2>
<p>Iterators do not have to be finite. As an example, an open-ended range is
an infinite iterator:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>numbers = <span class="number">0</span>..;</code></pre></div>
<p>It is common to use the <a href="../../../all/trait.Iterator.html#method.take" title="method devela::all::Iterator::take"><code>take</code></a> iterator adapter to turn an infinite
iterator into a finite one:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>numbers = <span class="number">0</span>..;
<span class="kw">let </span>five_numbers = numbers.take(<span class="number">5</span>);

<span class="kw">for </span>number <span class="kw">in </span>five_numbers {
    <span class="macro">println!</span>(<span class="string">"{number}"</span>);
}</code></pre></div>
<p>This will print the numbers <code>0</code> through <code>4</code>, each on their own line.</p>
<p>Bear in mind that methods on infinite iterators, even those for which a
result can be determined mathematically in finite time, might not terminate.
Specifically, methods such as <a href="../../../all/trait.Iterator.html#method.min" title="method devela::all::Iterator::min"><code>min</code></a>, which in the general case require
traversing every element in the iterator, are likely not to return
successfully for any infinite iterators.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>ones = std::iter::repeat(<span class="number">1</span>);
<span class="kw">let </span>least = ones.min().unwrap(); <span class="comment">// Oh no! An infinite loop!
// `ones.min()` causes an infinite loop, so we won't reach this point!
</span><span class="macro">println!</span>(<span class="string">"The smallest number one is {least}."</span>);</code></pre></div>
</div></details><h2 id="macros" class="section-header">Macros<a href="#macros" class="anchor">§</a></h2><dl class="item-table"><dt><a class="macro" href="macro.iter.html" title="macro devela::_dep::_std::iter::iter">iter</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>Creates a new closure that returns an iterator where each iteration steps the given
generator to the next <code>yield</code> statement.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Chain.html" title="struct devela::_dep::_std::iter::Chain">Chain</a></dt><dd>An iterator that links two iterators together, in a chain.</dd><dt><a class="struct" href="struct.Cloned.html" title="struct devela::_dep::_std::iter::Cloned">Cloned</a></dt><dd>An iterator that clones the elements of an underlying iterator.</dd><dt><a class="struct" href="struct.Copied.html" title="struct devela::_dep::_std::iter::Copied">Copied</a></dt><dd>An iterator that copies the elements of an underlying iterator.</dd><dt><a class="struct" href="struct.Cycle.html" title="struct devela::_dep::_std::iter::Cycle">Cycle</a></dt><dd>An iterator that repeats endlessly.</dd><dt><a class="struct" href="struct.Empty.html" title="struct devela::_dep::_std::iter::Empty">Empty</a></dt><dd>An iterator that yields nothing.</dd><dt><a class="struct" href="struct.Enumerate.html" title="struct devela::_dep::_std::iter::Enumerate">Enumerate</a></dt><dd>An iterator that yields the current count and the element during iteration.</dd><dt><a class="struct" href="struct.Filter.html" title="struct devela::_dep::_std::iter::Filter">Filter</a></dt><dd>An iterator that filters the elements of <code>iter</code> with <code>predicate</code>.</dd><dt><a class="struct" href="struct.FilterMap.html" title="struct devela::_dep::_std::iter::FilterMap">Filter<wbr>Map</a></dt><dd>An iterator that uses <code>f</code> to both filter and map elements from <code>iter</code>.</dd><dt><a class="struct" href="struct.FlatMap.html" title="struct devela::_dep::_std::iter::FlatMap">FlatMap</a></dt><dd>An iterator that maps each element to an iterator, and yields the elements
of the produced iterators.</dd><dt><a class="struct" href="struct.Flatten.html" title="struct devela::_dep::_std::iter::Flatten">Flatten</a></dt><dd>An iterator that flattens one level of nesting in an iterator of things
that can be turned into iterators.</dd><dt><a class="struct" href="struct.FromFn.html" title="struct devela::_dep::_std::iter::FromFn">FromFn</a></dt><dd>An iterator where each iteration calls the provided closure <code>F: FnMut() -&gt; Option&lt;T&gt;</code>.</dd><dt><a class="struct" href="struct.Fuse.html" title="struct devela::_dep::_std::iter::Fuse">Fuse</a></dt><dd>An iterator that yields <code>None</code> forever after the underlying iterator
yields <code>None</code> once.</dd><dt><a class="struct" href="struct.Inspect.html" title="struct devela::_dep::_std::iter::Inspect">Inspect</a></dt><dd>An iterator that calls a function with a reference to each element before
yielding it.</dd><dt><a class="struct" href="struct.Map.html" title="struct devela::_dep::_std::iter::Map">Map</a></dt><dd>An iterator that maps the values of <code>iter</code> with <code>f</code>.</dd><dt><a class="struct" href="struct.MapWhile.html" title="struct devela::_dep::_std::iter::MapWhile">MapWhile</a></dt><dd>An iterator that only accepts elements while <code>predicate</code> returns <code>Some(_)</code>.</dd><dt><a class="struct" href="struct.Once.html" title="struct devela::_dep::_std::iter::Once">Once</a></dt><dd>An iterator that yields an element exactly once.</dd><dt><a class="struct" href="struct.OnceWith.html" title="struct devela::_dep::_std::iter::OnceWith">Once<wbr>With</a></dt><dd>An iterator that yields a single element of type <code>A</code> by
applying the provided closure <code>F: FnOnce() -&gt; A</code>.</dd><dt><a class="struct" href="struct.Peekable.html" title="struct devela::_dep::_std::iter::Peekable">Peekable</a></dt><dd>An iterator with a <code>peek()</code> that returns an optional reference to the next
element.</dd><dt><a class="struct" href="struct.Repeat.html" title="struct devela::_dep::_std::iter::Repeat">Repeat</a></dt><dd>An iterator that repeats an element endlessly.</dd><dt><a class="struct" href="struct.RepeatN.html" title="struct devela::_dep::_std::iter::RepeatN">RepeatN</a></dt><dd>An iterator that repeats an element an exact number of times.</dd><dt><a class="struct" href="struct.RepeatWith.html" title="struct devela::_dep::_std::iter::RepeatWith">Repeat<wbr>With</a></dt><dd>An iterator that repeats elements of type <code>A</code> endlessly by
applying the provided closure <code>F: FnMut() -&gt; A</code>.</dd><dt><a class="struct" href="struct.Rev.html" title="struct devela::_dep::_std::iter::Rev">Rev</a></dt><dd>A double-ended iterator with the direction inverted.</dd><dt><a class="struct" href="struct.Scan.html" title="struct devela::_dep::_std::iter::Scan">Scan</a></dt><dd>An iterator to maintain state while iterating another iterator.</dd><dt><a class="struct" href="struct.Skip.html" title="struct devela::_dep::_std::iter::Skip">Skip</a></dt><dd>An iterator that skips over <code>n</code> elements of <code>iter</code>.</dd><dt><a class="struct" href="struct.SkipWhile.html" title="struct devela::_dep::_std::iter::SkipWhile">Skip<wbr>While</a></dt><dd>An iterator that rejects elements while <code>predicate</code> returns <code>true</code>.</dd><dt><a class="struct" href="struct.StepBy.html" title="struct devela::_dep::_std::iter::StepBy">StepBy</a></dt><dd>An iterator for stepping iterators by a custom amount.</dd><dt><a class="struct" href="struct.Successors.html" title="struct devela::_dep::_std::iter::Successors">Successors</a></dt><dd>An iterator which, starting from an initial item,
computes each successive item from the preceding one.</dd><dt><a class="struct" href="struct.Take.html" title="struct devela::_dep::_std::iter::Take">Take</a></dt><dd>An iterator that only iterates over the first <code>n</code> iterations of <code>iter</code>.</dd><dt><a class="struct" href="struct.TakeWhile.html" title="struct devela::_dep::_std::iter::TakeWhile">Take<wbr>While</a></dt><dd>An iterator that only accepts elements while <code>predicate</code> returns <code>true</code>.</dd><dt><a class="struct" href="struct.Zip.html" title="struct devela::_dep::_std::iter::Zip">Zip</a></dt><dd>An iterator that iterates two other iterators simultaneously.</dd><dt><a class="struct" href="struct.ArrayChunks.html" title="struct devela::_dep::_std::iter::ArrayChunks">Array<wbr>Chunks</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>An iterator over <code>N</code> elements of the iterator at a time.</dd><dt><a class="struct" href="struct.ByRefSized.html" title="struct devela::_dep::_std::iter::ByRefSized">ByRef<wbr>Sized</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>Like <code>Iterator::by_ref</code>, but requiring <code>Sized</code> so it can forward generics.</dd><dt><a class="struct" href="struct.FromCoroutine.html" title="struct devela::_dep::_std::iter::FromCoroutine">From<wbr>Coroutine</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>An iterator over the values yielded by an underlying coroutine.</dd><dt><a class="struct" href="struct.Intersperse.html" title="struct devela::_dep::_std::iter::Intersperse">Intersperse</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>An iterator adapter that places a separator between all elements.</dd><dt><a class="struct" href="struct.IntersperseWith.html" title="struct devela::_dep::_std::iter::IntersperseWith">Intersperse<wbr>With</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>An iterator adapter that places a separator between all elements.</dd><dt><a class="struct" href="struct.MapWindows.html" title="struct devela::_dep::_std::iter::MapWindows">MapWindows</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>An iterator over the mapped windows of another iterator.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.DoubleEndedIterator.html" title="trait devela::_dep::_std::iter::DoubleEndedIterator">Double<wbr>Ended<wbr>Iterator</a></dt><dd>An iterator able to yield elements from both ends.</dd><dt><a class="trait" href="trait.ExactSizeIterator.html" title="trait devela::_dep::_std::iter::ExactSizeIterator">Exact<wbr>Size<wbr>Iterator</a></dt><dd>An iterator that knows its exact length.</dd><dt><a class="trait" href="trait.Extend.html" title="trait devela::_dep::_std::iter::Extend">Extend</a></dt><dd>Extend a collection with the contents of an iterator.</dd><dt><a class="trait" href="trait.FromIterator.html" title="trait devela::_dep::_std::iter::FromIterator">From<wbr>Iterator</a></dt><dd>Conversion from an <a href="../../../all/trait.Iterator.html" title="trait devela::all::Iterator"><code>Iterator</code></a>.</dd><dt><a class="trait" href="trait.FusedIterator.html" title="trait devela::_dep::_std::iter::FusedIterator">Fused<wbr>Iterator</a></dt><dd>An iterator that always continues to yield <code>None</code> when exhausted.</dd><dt><a class="trait" href="trait.IntoIterator.html" title="trait devela::_dep::_std::iter::IntoIterator">Into<wbr>Iterator</a></dt><dd>Conversion into an <a href="../../../all/trait.Iterator.html" title="trait devela::all::Iterator"><code>Iterator</code></a>.</dd><dt><a class="trait" href="trait.Iterator.html" title="trait devela::_dep::_std::iter::Iterator">Iterator</a></dt><dd>A trait for dealing with iterators.</dd><dt><a class="trait" href="trait.Product.html" title="trait devela::_dep::_std::iter::Product">Product</a></dt><dd>Trait to represent types that can be created by multiplying elements of an
iterator.</dd><dt><a class="trait" href="trait.Sum.html" title="trait devela::_dep::_std::iter::Sum">Sum</a></dt><dd>Trait to represent types that can be created by summing up an iterator.</dd><dt><a class="trait" href="trait.Step.html" title="trait devela::_dep::_std::iter::Step">Step</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>Objects that have a notion of <em>successor</em> and <em>predecessor</em> operations.</dd><dt><a class="trait" href="trait.TrustedLen.html" title="trait devela::_dep::_std::iter::TrustedLen">Trusted<wbr>Len</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>An iterator that reports an accurate length using size_hint.</dd><dt><a class="trait" href="trait.TrustedStep.html" title="trait devela::_dep::_std::iter::TrustedStep">Trusted<wbr>Step</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>A type that upholds all invariants of <a href="../../../_core/iter/trait.Step.html" title="trait devela::_core::iter::Step"><code>Step</code></a>.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.chain.html" title="fn devela::_dep::_std::iter::chain">chain</a></dt><dd>Converts the arguments to iterators and links them together, in a chain.</dd><dt><a class="fn" href="fn.empty.html" title="fn devela::_dep::_std::iter::empty">empty</a></dt><dd>Creates an iterator that yields nothing.</dd><dt><a class="fn" href="fn.from_fn.html" title="fn devela::_dep::_std::iter::from_fn">from_fn</a></dt><dd>Creates an iterator with the provided closure
<code>F: FnMut() -&gt; Option&lt;T&gt;</code> as its <a href="../../../all/trait.Iterator.html#tymethod.next" title="method devela::all::Iterator::next"><code>next</code></a> method.</dd><dt><a class="fn" href="fn.once.html" title="fn devela::_dep::_std::iter::once">once</a></dt><dd>Creates an iterator that yields an element exactly once.</dd><dt><a class="fn" href="fn.once_with.html" title="fn devela::_dep::_std::iter::once_with">once_<wbr>with</a></dt><dd>Creates an iterator that lazily generates a value exactly once by invoking
the provided closure.</dd><dt><a class="fn" href="fn.repeat.html" title="fn devela::_dep::_std::iter::repeat">repeat</a></dt><dd>Creates a new iterator that endlessly repeats a single element.</dd><dt><a class="fn" href="fn.repeat_n.html" title="fn devela::_dep::_std::iter::repeat_n">repeat_<wbr>n</a></dt><dd>Creates a new iterator that repeats a single element a given number of times.</dd><dt><a class="fn" href="fn.repeat_with.html" title="fn devela::_dep::_std::iter::repeat_with">repeat_<wbr>with</a></dt><dd>Creates a new iterator that repeats elements of type <code>A</code> endlessly by
applying the provided closure, the repeater, <code>F: FnMut() -&gt; A</code>.</dd><dt><a class="fn" href="fn.successors.html" title="fn devela::_dep::_std::iter::successors">successors</a></dt><dd>Creates an iterator which, starting from an initial item,
computes each successive item from the preceding one.</dd><dt><a class="fn" href="fn.zip.html" title="fn devela::_dep::_std::iter::zip">zip</a></dt><dd>Converts the arguments to iterators and zips them.</dd><dt><a class="fn" href="fn.from_coroutine.html" title="fn devela::_dep::_std::iter::from_coroutine">from_<wbr>coroutine</a><wbr><span class="stab unstable" title="">Experimental</span></dt><dd>Creates a new iterator where each iteration calls the provided coroutine.</dd></dl></section></div></main></body></html>