<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Returns an estimate of the default amount of parallelism a program should use."><title>available_parallelism in devela::_dep::_std::thread - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../../" data-static-root-path="../../../../static.files/" data-current-crate="devela" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-nightly (f2824da98 2025-08-28)" data-channel="nightly" data-search-js="search-03d23683.js" data-stringdex-js="stringdex-0e748618.js" data-settings-js="settings-c38705f0.js" ><script src="../../../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../../static.files/favicon-044be391.svg"><script>
  document.addEventListener("DOMContentLoaded", async function() {
    // Ensure this script runs only once per page load
    if (window.scriptLoaderInitialized) return;
    window.scriptLoaderInitialized = true;

    /* settings */

    const crateName = "devela";
    const allowedKatex = ["/all", "/media/color", "/num/", "/phys/"];
    const allowedKatexChem = ["/all/", "/phys/"];

    // Find the LAST occurrence of `/devela/` in the path
    const path = window.location.pathname;
    const lastCrateIndex = path.lastIndexOf(`/${crateName}/`);
    if (lastCrateIndex === -1) return;
    // Extract everything after the last `/devela/`
    const relativePath = path.slice(lastCrateIndex + crateName.length + 1);

    /* load resources */

    try {
      if (allowedKatex.some(prefix => relativePath.startsWith(prefix))) {
        await loadKatex().catch(handleMathError);
      }
      if (allowedKatexChem.some(prefix => relativePath.startsWith(prefix))) {
        await loadKatexChem().catch(handleMathError);
      }
    } catch (error) {
      handleMathError(error);
    }

    /* resource loading functions */

    // INFO: https://katex.org/docs/browser.html#starter-template
    // INFO: https://github.com/KaTeX/KaTeX/tree/main/contrib/copy-tex
    async function loadKatex() {
      console.log("Loading KaTeX for:", relativePath);

      // Load CSS, and scripts sequentially
      const katexCSS = document.createElement("link");
      katexCSS.rel = "stylesheet";
      katexCSS.href = "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css";
      katexCSS.integrity = "sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib";
      katexCSS.crossOrigin = "anonymous";
      document.head.appendChild(katexCSS);

      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js",
        integrity: "sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh"
      });
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js",
        integrity: "sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh"
      });
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/copy-tex.min.js",
        integrity: "sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi"
      });

      // Initialize KaTeX
      renderMathInElement(document.body, {
        delimiters: [
          {left: "$$", right: "$$", display: true},
          {left: "$", right: "$", display: false},
          {left: "\\(", right: "\\)", display: false},
          {left: "\\[", right: "\\]", display: true}
        ],
        trust: (context) => context.command === "\\href"
      });
      // Add custom styles: https://katex.org/docs/issues.html#css-customization
      const katexStyle = document.createElement("style");
      katexStyle.textContent = `
        .katex-display { overflow: hidden; }
        .docblock p { overflow-y: hidden; }
      `;
      document.head.appendChild(katexStyle);
    }

    // INFO: https://github.com/KaTeX/KaTeX/blob/main/contrib/mhchem/README.md
    async function loadKatexChem() {
      console.log("Loading KaTeX MhChem plugin for:", relativePath);
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/mhchem.min.js",
        integrity: "sha384-F2ptQFZqNJuqfGGl28mIXyQ5kXH48spn7rcoS0Y9psqIKAcZPLd1NzwFlm/bl1mH"
      });
    }

    /* helper functions */

    function loadScript(config) {
      return new Promise((resolve, reject) => {
        const script = document.createElement("script");
        script.src = config.src;
        if (config.integrity) {
          script.integrity = config.integrity;
          script.crossOrigin = "anonymous";
        }
        script.onload = resolve;
        script.onerror = () => reject(new Error(`Failed to load script: ${config.src}`));
        document.head.appendChild(script);
      });
    }
    function handleMathError(error) {
      console.error("Math rendering error:", error);
    }
  });
</script>

</head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">available_parallelism</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../devela/index.html">devela</a><span class="version">0.25.0-wip</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">available_<wbr>parallelism</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#limitations" title="Limitations">Limitations</a></li><li><a href="#errors" title="Errors">Errors</a></li><li><a href="#examples" title="Examples">Examples</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In devela::<wbr>_<wbr>dep::<wbr>_<wbr>std::<wbr>thread</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../../index.html">devela</a>::<wbr><a href="../../index.html">_dep</a>::<wbr><a href="../index.html">_std</a>::<wbr><a href="index.html">thread</a></div><h1>Function <span class="fn">available_<wbr>parallelism</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><span class="since" title="Stable since Rust version 1.59.0">1.59.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/std/thread/mod.rs.html#2056">Source</a> </span></div><pre class="rust item-decl"><code>pub fn available_parallelism() -&gt; <a class="enum" href="../../../all/enum.Result.html" title="enum devela::all::Result">Result</a>&lt;<a class="struct" href="../../../all/struct.NonZero.html" title="struct devela::all::NonZero">NonZero</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>&gt;, <a class="struct" href="../../../all/struct.IoError.html" title="struct devela::all::IoError">Error</a>&gt; <a href="#" class="tooltip" data-notable-ty="Result&lt;NonZero&lt;usize&gt;, Error&gt;">ⓘ</a></code></pre><span class="item-info"><div class="stab portability">Available on <strong>crate feature <code>std</code></strong> only.</div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Returns an estimate of the default amount of parallelism a program should use.</p>
<p>Parallelism is a resource. A given machine provides a certain capacity for
parallelism, i.e., a bound on the number of computations it can perform
simultaneously. This number often corresponds to the amount of CPUs a
computer has, but it may diverge in various cases.</p>
<p>Host environments such as VMs or container orchestrators may want to
restrict the amount of parallelism made available to programs in them. This
is often done to limit the potential impact of (unintentionally)
resource-intensive programs on other programs running on the same machine.</p>
<h2 id="limitations"><a class="doc-anchor" href="#limitations">§</a>Limitations</h2>
<p>The purpose of this API is to provide an easy and portable way to query
the default amount of parallelism the program should use. Among other things it
does not expose information on NUMA regions, does not account for
differences in (co)processor capabilities or current system load,
and will not modify the program’s global state in order to more accurately
query the amount of available parallelism.</p>
<p>Where both fixed steady-state and burst limits are available the steady-state
capacity will be used to ensure more predictable latencies.</p>
<p>Resource limits can be changed during the runtime of a program, therefore the value is
not cached and instead recomputed every time this function is called. It should not be
called from hot code.</p>
<p>The value returned by this function should be considered a simplified
approximation of the actual amount of parallelism available at any given
time. To get a more detailed or precise overview of the amount of
parallelism available to the program, you may wish to use
platform-specific APIs as well. The following platform limitations currently
apply to <code>available_parallelism</code>:</p>
<p>On Windows:</p>
<ul>
<li>It may undercount the amount of parallelism available on systems with more
than 64 logical CPUs. However, programs typically need specific support to
take advantage of more than 64 logical CPUs, and in the absence of such
support, the number returned by this function accurately reflects the
number of logical CPUs the program can use by default.</li>
<li>It may overcount the amount of parallelism available on systems limited by
process-wide affinity masks, or job object limitations.</li>
</ul>
<p>On Linux:</p>
<ul>
<li>It may overcount the amount of parallelism available when limited by a
process-wide affinity mask or cgroup quotas and <code>sched_getaffinity()</code> or cgroup fs can’t be
queried, e.g. due to sandboxing.</li>
<li>It may undercount the amount of parallelism if the current thread’s affinity mask
does not reflect the process’ cpuset, e.g. due to pinned threads.</li>
<li>If the process is in a cgroup v1 cpu controller, this may need to
scan mountpoints to find the corresponding cgroup v1 controller,
which may take time on systems with large numbers of mountpoints.
(This does not apply to cgroup v2, or to processes not in a
cgroup.)</li>
<li>It does not attempt to take <code>ulimit</code> into account. If there is a limit set on the number of
threads, <code>available_parallelism</code> cannot know how much of that limit a Rust program should
take, or know in a reliable and race-free way how much of that limit is already taken.</li>
</ul>
<p>On all targets:</p>
<ul>
<li>It may overcount the amount of parallelism available when running in a VM
with CPU usage limits (e.g. an overcommitted host).</li>
</ul>
<h2 id="errors"><a class="doc-anchor" href="#errors">§</a>Errors</h2>
<p>This function will, but is not limited to, return errors in the following
cases:</p>
<ul>
<li>If the amount of parallelism is not known for the target platform.</li>
<li>If the program lacks permission to query the amount of parallelism made
available to it.</li>
</ul>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::{io, thread};

<span class="kw">fn </span>main() -&gt; io::Result&lt;()&gt; {
    <span class="kw">let </span>count = thread::available_parallelism()<span class="question-mark">?</span>.get();
    <span class="macro">assert!</span>(count &gt;= <span class="number">1_usize</span>);
    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><script type="text/json" id="notable-traits-data">{"Result<NonZero<usize>, Error>":"<h3>Notable traits for <code><a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</code></h3><pre><code><div class=\"where\">impl&lt;T, E&gt; <a class=\"trait\" href=\"../../../all/trait.ExtResult.html\" title=\"trait devela::all::ExtResult\">ExtResult</a>&lt;T, E&gt; for <a class=\"enum\" href=\"../../../all/enum.Result.html\" title=\"enum devela::all::Result\">Result</a>&lt;T, E&gt;</div>"}</script></section></div></main></body></html>