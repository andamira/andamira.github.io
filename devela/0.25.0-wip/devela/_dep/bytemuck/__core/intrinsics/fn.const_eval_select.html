<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Selects which function to call depending on the context."><title>const_eval_select in devela::_dep::bytemuck::__core::intrinsics - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../../../" data-static-root-path="../../../../../static.files/" data-current-crate="devela" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-nightly (f2824da98 2025-08-28)" data-channel="nightly" data-search-js="search-03d23683.js" data-stringdex-js="stringdex-0e748618.js" data-settings-js="settings-c38705f0.js" ><script src="../../../../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../../../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../../../../../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../../../../../static.files/favicon-044be391.svg"><script>
  document.addEventListener("DOMContentLoaded", async function() {
    // Ensure this script runs only once per page load
    if (window.scriptLoaderInitialized) return;
    window.scriptLoaderInitialized = true;

    /* settings */

    const crateName = "devela";
    const allowedKatex = ["/all", "/media/color", "/num/", "/phys/"];
    const allowedKatexChem = ["/all/", "/phys/"];

    // Find the LAST occurrence of `/devela/` in the path
    const path = window.location.pathname;
    const lastCrateIndex = path.lastIndexOf(`/${crateName}/`);
    if (lastCrateIndex === -1) return;
    // Extract everything after the last `/devela/`
    const relativePath = path.slice(lastCrateIndex + crateName.length + 1);

    /* load resources */

    try {
      if (allowedKatex.some(prefix => relativePath.startsWith(prefix))) {
        await loadKatex().catch(handleMathError);
      }
      if (allowedKatexChem.some(prefix => relativePath.startsWith(prefix))) {
        await loadKatexChem().catch(handleMathError);
      }
    } catch (error) {
      handleMathError(error);
    }

    /* resource loading functions */

    // INFO: https://katex.org/docs/browser.html#starter-template
    // INFO: https://github.com/KaTeX/KaTeX/tree/main/contrib/copy-tex
    async function loadKatex() {
      console.log("Loading KaTeX for:", relativePath);

      // Load CSS, and scripts sequentially
      const katexCSS = document.createElement("link");
      katexCSS.rel = "stylesheet";
      katexCSS.href = "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css";
      katexCSS.integrity = "sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib";
      katexCSS.crossOrigin = "anonymous";
      document.head.appendChild(katexCSS);

      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js",
        integrity: "sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh"
      });
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js",
        integrity: "sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh"
      });
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/copy-tex.min.js",
        integrity: "sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi"
      });

      // Initialize KaTeX
      renderMathInElement(document.body, {
        delimiters: [
          {left: "$$", right: "$$", display: true},
          {left: "$", right: "$", display: false},
          {left: "\\(", right: "\\)", display: false},
          {left: "\\[", right: "\\]", display: true}
        ],
        trust: (context) => context.command === "\\href"
      });
      // Add custom styles: https://katex.org/docs/issues.html#css-customization
      const katexStyle = document.createElement("style");
      katexStyle.textContent = `
        .katex-display { overflow: hidden; }
        .docblock p { overflow-y: hidden; }
      `;
      document.head.appendChild(katexStyle);
    }

    // INFO: https://github.com/KaTeX/KaTeX/blob/main/contrib/mhchem/README.md
    async function loadKatexChem() {
      console.log("Loading KaTeX MhChem plugin for:", relativePath);
      await loadScript({
        src: "https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/mhchem.min.js",
        integrity: "sha384-F2ptQFZqNJuqfGGl28mIXyQ5kXH48spn7rcoS0Y9psqIKAcZPLd1NzwFlm/bl1mH"
      });
    }

    /* helper functions */

    function loadScript(config) {
      return new Promise((resolve, reject) => {
        const script = document.createElement("script");
        script.src = config.src;
        if (config.integrity) {
          script.integrity = config.integrity;
          script.crossOrigin = "anonymous";
        }
        script.onload = resolve;
        script.onerror = () => reject(new Error(`Failed to load script: ${config.src}`));
        document.head.appendChild(script);
      });
    }
    function handleMathError(error) {
      console.error("Math rendering error:", error);
    }
  });
</script>

</head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">const_eval_select</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../../../devela/index.html">devela</a><span class="version">0.25.0-wip</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">const_<wbr>eval_<wbr>select</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#type-requirements" title="Type Requirements">Type Requirements</a></li><li><a href="#stability-concerns" title="Stability concerns">Stability concerns</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In devela::<wbr>_<wbr>dep::<wbr>bytemuck::<wbr>__<wbr>core::<wbr>intrinsics</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../../../index.html">devela</a>::<wbr><a href="../../../index.html">_dep</a>::<wbr><a href="../../index.html">bytemuck</a>::<wbr><a href="../index.html">__core</a>::<wbr><a href="index.html">intrinsics</a></div><h1>Function <span class="fn">const_<wbr>eval_<wbr>select</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="https://doc.rust-lang.org/nightly/src/core/intrinsics/mod.rs.html#2309-2316">Source</a> </span></div><pre class="rust item-decl"><code>pub const fn const_eval_select&lt;ARG, F, G, RET&gt;(
    _arg: ARG,
    _called_in_const: F,
    _called_at_rt: G,
) -&gt; RET<div class="where">where
    ARG: <a class="trait" href="../../../../_core/marker/trait.Tuple.html" title="trait devela::_core::marker::Tuple">Tuple</a>,
    G: <a class="trait" href="../../../../all/trait.FnOnce.html" title="trait devela::all::FnOnce">FnOnce</a>&lt;ARG, Output = RET&gt;,
    F: <a class="trait" href="../../../../all/trait.FnOnce.html" title="trait devela::all::FnOnce">FnOnce</a>&lt;ARG, Output = RET&gt;,</div></code></pre><span class="item-info"><div class="stab unstable"><span class="emoji">üî¨</span><span>This is a nightly-only experimental API. (<code>core_intrinsics</code>)</span></div><div class="stab portability">Available on <strong>crate feature <code>dep_bytemuck</code></strong> only.</div></span><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Selects which function to call depending on the context.</p>
<p>If this function is evaluated at compile-time, then a call to this
intrinsic will be replaced with a call to <code>called_in_const</code>. It gets
replaced with a call to <code>called_at_rt</code> otherwise.</p>
<p>This function is safe to call, but note the stability concerns below.</p>
<h2 id="type-requirements"><a class="doc-anchor" href="#type-requirements">¬ß</a>Type Requirements</h2>
<p>The two functions must be both function items. They cannot be function
pointers or closures. The first function must be a <code>const fn</code>.</p>
<p><code>arg</code> will be the tupled arguments that will be passed to either one of
the two functions, therefore, both functions must accept the same type of
arguments. Both functions must return RET.</p>
<h2 id="stability-concerns"><a class="doc-anchor" href="#stability-concerns">¬ß</a>Stability concerns</h2>
<p>Rust has not yet decided that <code>const fn</code> are allowed to tell whether
they run at compile-time or at runtime. Therefore, when using this
intrinsic anywhere that can be reached from stable, it is crucial that
the end-to-end behavior of the stable <code>const fn</code> is the same for both
modes of execution. (Here, Undefined Behavior is considered ‚Äúthe same‚Äù
as any other behavior, so if the function exhibits UB at runtime then
it may do whatever it wants at compile-time.)</p>
<p>Here is an example of how this could cause a problem:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#![feature(const_eval_select)]
#![feature(core_intrinsics)]
</span><span class="kw">use </span>std::intrinsics::const_eval_select;

<span class="comment">// Standard library
</span><span class="kw">pub const fn </span>inconsistent() -&gt; i32 {
    <span class="kw">fn </span>runtime() -&gt; i32 { <span class="number">1 </span>}
    <span class="kw">const fn </span>compiletime() -&gt; i32 { <span class="number">2 </span>}

    <span class="comment">// ‚ö† This code violates the required equivalence of `compiletime`
    // and `runtime`.
    </span>const_eval_select((), compiletime, runtime)
}

<span class="comment">// User Crate
</span><span class="kw">const </span>X: i32 = inconsistent();
<span class="kw">let </span>x = inconsistent();
<span class="macro">assert_eq!</span>(x, X);</code></pre></div>
<p>Currently such an assertion would always succeed; until Rust decides
otherwise, that principle should not be violated.</p>
</div></details></section></div></main></body></html>