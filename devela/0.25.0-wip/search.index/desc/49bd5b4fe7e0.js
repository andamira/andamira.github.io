rd_("ClRound the lower single-precision (32-bit) floating-point \xe2\x80\xa60CkShuffle 32-bit integers in a within 128-bit lanes using \xe2\x80\xa600CiCompute the square root of the lower double-precision \xe2\x80\xa600CgCompute the square root of the lower half-precision \xe2\x80\xa600CiCompute the square root of the lower single-precision \xe2\x80\xa600CnUnpack and interleave 8-bit integers from the high half of \xe2\x80\xa600CmUnpack and interleave 8-bit integers from the low half of \xe2\x80\xa600CjAdd the lower double-precision (64-bit) floating-point \xe2\x80\xa600ChAdd the lower half-precision (16-bit) floating-point \xe2\x80\xa600CjAdd the lower single-precision (32-bit) floating-point \xe2\x80\xa600CnConcatenate a and b into a 32-byte immediate result, shift \xe2\x80\xa600000CnCompute the bitwise NOT of packed 32-bit integers in a and \xe2\x80\xa600CnCompute the bitwise NOT of packed 64-bit integers in a and \xe2\x80\xa600CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa600CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa600000000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000000000000000222222CkConvert packed double-precision (32-bit) floating-point \xe2\x80\xa600333CmDivide the lower double-precision (64-bit) floating-point \xe2\x80\xa600CkDivide the lower half-precision (16-bit) floating-point \xe2\x80\xa600CmDivide the lower single-precision (32-bit) floating-point \xe2\x80\xa600CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa600ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa600CmLoad contiguous active 16-bit integers from a (those with \xe2\x80\xa600CmLoad contiguous active 32-bit integers from a (those with \xe2\x80\xa600CmLoad contiguous active 64-bit integers from a (those with \xe2\x80\xa600CnCompare the lower double-precision (64-bit) floating-point \xe2\x80\xa600ClCompare the lower half-precision (16-bit) floating-point \xe2\x80\xa600CnCompare the lower single-precision (32-bit) floating-point \xe2\x80\xa600222111000C`Multiply the lower double-precision (64-bit) \xe2\x80\xa600CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa600C`Multiply the lower single-precision (32-bit) \xe2\x80\xa600CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa600CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa600CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa600ChFor each packed 16-bit integer maps the value to the \xe2\x80\xa600ChFor each packed 32-bit integer maps the value to the \xe2\x80\xa600ChFor each packed 64-bit integer maps the value to the \xe2\x80\xa600CkShuffle packed 8-bit integers in a according to shuffle \xe2\x80\xa600C`Subtract the lower double-precision (64-bit) \xe2\x80\xa600CmSubtract the lower half-precision (16-bit) floating-point \xe2\x80\xa600C`Subtract the lower single-precision (32-bit) \xe2\x80\xa600CmLoads 2 double-precision (64-bit) floating-point elements \xe2\x80\xa600CmLoads 4 single-precision (32-bit) floating-point elements \xe2\x80\xa600111CmLoads 2 single-precision (32-bit) floating-point elements \xe2\x80\xa600CmShuffle 16-bit integers in a and b across lanes using the \xe2\x80\xa600CmShuffle 32-bit integers in a and b across lanes using the \xe2\x80\xa600CmShuffle 64-bit integers in a and b across lanes using the \xe2\x80\xa600CiBitwise ternary logic that provides the capability to \xe2\x80\xa600000DfPerform the last round of an AES decryption flow on <code>a</code> \xe2\x80\xa60DfPerform the last round of an AES encryption flow on <code>a</code> \xe2\x80\xa60EhAllocates a new slice of size <code>len</code> slice into this <code>Bump</code> and \xe2\x80\xa6CmProvides shared access to the key and owned access to the \xe2\x80\xa60CmCasts <code>self</code> to mutable <code>ArrayOfTables</code>BlApplies automatic gain control to the sound.0CnDefault free callback, which calls av_free() on the buffer \xe2\x80\xa6Cn@defgroup lavfi_buffersink_accessors Buffer sink accessors \xe2\x80\xa6BaAdd a frame to the buffer source.CgGet a human readable string describing a given channel.CgThis is the inverse function of @ref av_channel_name().CkMake a copy of a channel layout. This differs from just \xe2\x80\xa6Bdbprint variant of av_channel_name().Ck@return the name for provided color transfer or NULL if \xe2\x80\xa6CeFlip the input matrix horizontally and/or vertically.BbAdd an element to a dynamic array.CcParse and evaluate an expression. Note, this is \xe2\x80\xa6CkSame behaviour av_fast_padded_malloc except that buffer \xe2\x80\xa6Ci@return a pointer to the side data of a given type on \xe2\x80\xa6CnEnsure that the frame data is writable, avoiding data copy \xe2\x80\xa6AoAdd a new side data to a frame.ClReturn in \xe2\x80\x98buf\xe2\x80\x99 the path with \xe2\x80\x98%d\xe2\x80\x99 replaced by a \xe2\x80\xa6CkReturn the name of sample_fmt, or NULL if sample_fmt is notCeOpen a device of the specified type and create an \xe2\x80\xa6CkFill plane data pointers for an image with pixel format \xe2\x80\xa6CmInitialize or reinitialize an AVMurMur3 hash context with \xe2\x80\xa6CnParse the key-value pairs list in opts. For each key=value \xe2\x80\xa6Ce@return an AVPixelFormat id described by desc, or \xe2\x80\xa6CjProbe a bytestream to determine the input format. Each \xe2\x80\xa6AfGuess the file format.0CjFill plane data pointers and linesize for samples with \xe2\x80\xa6BbFill an audio buffer with silence.BoWrite an uncoded frame to an output media file.ClAllocate an AVCodecContext and set its fields to default \xe2\x80\xa6Cg@return descriptor for given codec ID or NULL if no \xe2\x80\xa6BcRead encoded data from the encoder.C`Return the libavdevice build-time configuration.C`Return the libavfilter build-time configuration.CbInsert a filter in the middle of an existing link.ClAllocate an AVFormatContext. avformat_free_context() can \xe2\x80\xa6C`Return the libavformat build-time configuration.EcFlips the bits in <code>self</code> from the <code>[start..=end]</code> checked \xe2\x80\xa60DiReturns a bitmask of ones from the <code>[start..=end]</code> checked \xe2\x80\xa60DdBlend the <code>i8</code> lanes according to a runtime varying mask.0D`Blend <code>i8</code> lanes according to a runtime varying mask.0BiCancels a request for an animation frame.D`Bit-preserving cast to <code>m128</code> from <code>m256</code>.0CjCLFLUSH line size (Value \xe2\x88\x97 8 = cache line size in bytes)CnReturns the amount of time elapsed from another instant to \xe2\x80\xa6BlThis defines the location of chroma samples.CmReturn an iterator over all windows, wrapping back to the \xe2\x80\xa6000ClCloses the audio device and saves the callback data from \xe2\x80\xa6ClLanewise <code>(!a.is_nan()) &amp;amp; (!b.is_nan())</code>.ChLanewise <code>(!a.is_nan()) &amp; (!b.is_nan())</code>.DdLow lane <code>a.is_nan() | b.is_nan()</code>, other lane unchanged.0DcWrites the color components to a pre-allocated <code>buffer</code>.0ChWhen enabled, commas are written after unit designators.DoCreates a new instance of an <code>RwLock&lt;T&gt;</code> which is unlocked \xe2\x80\xa6ClReturns true if the unsigned 16-bit integer contains one \xe2\x80\xa6ClReturns true if the unsigned 32-bit integer contains one \xe2\x80\xa6ClReturns true if the unsigned 64-bit integer contains one \xe2\x80\xa6CkCheck if the post-condition <code>cond</code> has been met.00DhCopies all audio samples from a source <code>AudioBuffer</code> into \xe2\x80\xa6DkCopies all audio data from a source <code>AudioBuffer</code> that is of \xe2\x80\xa6FkCopies <code>count * size_of::&lt;T&gt;()</code> bytes from <code>self</code> to <code>dest</code>. The \xe2\x80\xa6DjDecrements the strong reference count on the <code>Arc&lt;T&gt;</code> \xe2\x80\xa6DiDecrements the strong reference count on the <code>Rc&lt;T&gt;</code> \xe2\x80\xa61DjHint that the <code>Deserialize</code> type is expecting the name of a \xe2\x80\xa60Aopicture number in display orderD`Forwards to the method defined on the type <code>dyn Any</code>.CjReturns a mutable reference to the inner value as type \xe2\x80\xa6ClForwards to the method defined on the type <code>Any</code>.0DbReturns a reference to the inner value as type <code>dyn T</code>.3DgEnsures that <code>len</code> bytes will be available for backwards \xe2\x80\xa6BaSwitches to the alternate screen.DkCopies all elements in the slice <code>other</code> and appends them to \xe2\x80\xa6CiExtracts an <code>i32</code> lane from <code>m256i</code>0CiExtracts an <code>i64</code> lane from <code>m256i</code>0CdExtracts an <code>m128</code> from <code>m256</code>0BbFlip an image vertically in place.CjConverts with LLVM\xe2\x80\x99s fptoui/fptosi, which may return \xe2\x80\xa600E`Converts the given FFI pointer into <code>Bound&lt;PyType&gt;</code>, to use \xe2\x80\xa6ChReturns a time zone database initialized from a path \xe2\x80\xa6Bg<em>const</em> method equivalent to \xe2\x80\xa6CgConvert an offset to a structured <code>Weekday</code>.01DdLanewise fused <code>(a * b) addsub c</code> (adds odd lanes and \xe2\x80\xa6000BhLanewise fused <code>-(a * b) + c</code>000BhLanewise fused <code>-(a * b) - c</code>000DiLanewise fused <code>(a * b) subadd c</code> (subtracts odd lanes and \xe2\x80\xa6000CiDeterministically generate a KeyPair from a private Seed.DhReturns the number of IDs generated so far with <code>Acquire</code> \xe2\x80\xa6DjAttempts to get mutable references to <code>N</code> values in the map \xe2\x80\xa600CiInformation about how monitor/mwait works on this CPU \xe2\x80\xa6CnReturns an exclusive reference to the element at the given \xe2\x80\xa60CfReturns a reference to the element at the given 2D \xe2\x80\xa60ChQuery information about thermal and power management \xe2\x80\xa6CmCheck if an OpenGL extension is supported for the current \xe2\x80\xa6BhGet the currently active OpenGL context.BmFXSAVE and FXRSTOR instruction optimizations.BiIndicates support for LBR Virtualization.DkVariant of <code>import_exception</code> that does not emit code needed \xe2\x80\xa6EgCreates a mismatch where <code>need</code> is an <code>Interval::empty_with</code>, \xe2\x80\xa6DjIncrements the strong reference count on the <code>Arc&lt;T&gt;</code> \xe2\x80\xa6DiIncrements the strong reference count on the <code>Rc&lt;T&gt;</code> \xe2\x80\xa61DhReturns a mutable reference to the first <code>n</code> bytes of the \xe2\x80\xa6CmInserts a new key-value pair into the map in the gap that \xe2\x80\xa60CjInserts a new element into the set in the gap that the \xe2\x80\xa60DhWrites the proper factors in <code>fbuf</code>, and the unique prime \xe2\x80\xa600BfCalls `NumInt::int_ref_factors_proper.00CmSimilar to int_factors_proper, but operates on references \xe2\x80\xa600BfCalls `NumInt::int_ref_modulo_add_inv.00CmSimilar to int_modulo_add_inv, but operates on references \xe2\x80\xa600BfCalls `NumInt::int_ref_modulo_mul_inv.00CmSimilar to int_modulo_mul_inv, but operates on references \xe2\x80\xa600C`Converts <code>self</code> into a Python object.0BoCount the leading zeroes in a <code>u32</code>.0BoCount the leading zeroes in a <code>u64</code>.0BaSwitches back to the main screen.BoConverts CIE lightness (L*) to linear luminance0DjLoad an <code>m128d</code> and splat it to the lower and upper half of \xe2\x80\xa60CjLoads the reference into a register, replacing the low \xe2\x80\xa60DkReads contiguous elements from <code>slice</code>. Each element is read \xe2\x80\xa6BoConverts linear luminance to CIE lightness (L*)0ChThe maximum supported enclave size in 64-bit mode is \xe2\x80\xa6CkEnables the I/O driver and configures the max number of \xe2\x80\xa6CmMin <code>u16</code> value, position, and other lanes zeroed.0Cm&lt; Time of last modification in microseconds since unix \xe2\x80\xa6EhLanewise <code>a * b</code> with lanes as <code>i16</code>, keep the low bits of the \xe2\x80\xa60DeMultiply the <code>i16</code> lanes and keep the low half of each \xe2\x80\xa60DeMultiply the <code>i32</code> lanes and keep the low half of each \xe2\x80\xa60EoMultiply the lower <code>i32</code> within each <code>i64</code> lane, <code>i64</code> output.0EoMultiply the lower <code>u32</code> within each <code>u64</code> lane, <code>u64</code> output.0DaFlips the bits from the <code>[start..=end]</code> checked range.00BeSets the <code>Variant0</code> field.BeSets the <code>Variant1</code> field.BeSets the <code>Variant2</code> field.BeSets the <code>Variant3</code> field.BeSets the <code>Variant4</code> field.EaGenerates a unique <code>ExampleIdSeqUsize</code> ID with <code>AcqRel</code> \xe2\x80\xa6DhCreate a new <code>Packet</code> with trimming information from a slice.CkSorts the slice in parallel with a key extraction function.0CbPolls for one of the tasks in the set to complete.DhDeposit contiguous low bits from a <code>u32</code> according to a mask.0DhDeposit contiguous low bits from a <code>u64</code> according to a mask.0CiExtract bits from a <code>u32</code> according to a mask.0CiExtract bits from a <code>u64</code> according to a mask.0CnReturn the postions of the minimum and maximum elements of \xe2\x80\xa6000CdType of downmix preferred by the mastering engineer.ClUltra-fast stdout write with newline. Panics if write isn\xe2\x80\xa6DdReturns a subslice starting from the given <code>start</code> index.CmReads up to 32-bits and interprets them as a signed two\xe2\x80\x99\xe2\x80\xa60CmReads up to 64-bits and interprets them as a signed two\xe2\x80\x99\xe2\x80\xa60CnReads exactly the number of bytes requested, and returns a \xe2\x80\xa6BjReads the CPU\xe2\x80\x99s timestamp counter value.0CjReads and returns a unary ones encoded integer that is \xe2\x80\xa6CkReads and returns a unary ones encoded integer or an error.DbLow lane <code>1.0 / sqrt(a)</code> approximation, other lanes \xe2\x80\xa60DgReturns the number of remaining IDs with <code>Acquire</code> ordering.DhRemoves the current element from the <code>LinkedList</code> without \xe2\x80\xa6CkRequest decoder to use this channel layout if it can (0 \xe2\x80\xa6DkReturns <code>true</code> if this permit belongs to the same channel as \xe2\x80\xa6DkCasts <code>self</code> to <code>i16</code> clamping at the numeric bounds.0EaCasts from <code>isize</code> to <code>i16</code> clamping at the numeric bounds.DoCasts from <code>u16</code> to <code>i16</code> clamping at the numeric bounds.DoCasts from <code>u64</code> to <code>i16</code> clamping at the numeric bounds.E`Casts from <code>i128</code> to <code>i16</code> clamping at the numeric bounds.DnCasts from <code>i8</code> to <code>i16</code> clamping at the numeric bounds.DnCasts from <code>u8</code> to <code>i16</code> clamping at the numeric bounds.EaCasts from <code>usize</code> to <code>i16</code> clamping at the numeric bounds.DoCasts from <code>i32</code> to <code>i16</code> clamping at the numeric bounds.DoCasts from <code>i16</code> to <code>i16</code> clamping at the numeric bounds.DoCasts from <code>i64</code> to <code>i16</code> clamping at the numeric bounds.DoCasts from <code>u32</code> to <code>i16</code> clamping at the numeric bounds.E`Casts from <code>u128</code> to <code>i16</code> clamping at the numeric bounds.DkCasts <code>self</code> to <code>i32</code> clamping at the numeric bounds.0E`Casts from <code>u128</code> to <code>i32</code> clamping at the numeric bounds.DoCasts from <code>u32</code> to <code>i32</code> clamping at the numeric bounds.E`Casts from <code>i128</code> to <code>i32</code> clamping at the numeric bounds.DoCasts from <code>u16</code> to <code>i32</code> clamping at the numeric bounds.EaCasts from <code>isize</code> to <code>i32</code> clamping at the numeric bounds.DoCasts from <code>i64</code> to <code>i32</code> clamping at the numeric bounds.DoCasts from <code>u64</code> to <code>i32</code> clamping at the numeric bounds.DoCasts from <code>i32</code> to <code>i32</code> clamping at the numeric bounds.DoCasts from <code>i16</code> to <code>i32</code> clamping at the numeric bounds.DnCasts from <code>u8</code> to <code>i32</code> clamping at the numeric bounds.EaCasts from <code>usize</code> to <code>i32</code> clamping at the numeric bounds.DnCasts from <code>i8</code> to <code>i32</code> clamping at the numeric bounds.DkCasts <code>self</code> to <code>i64</code> clamping at the numeric bounds.0DnCasts from <code>i8</code> to <code>i64</code> clamping at the numeric bounds.DoCasts from <code>u32</code> to <code>i64</code> clamping at the numeric bounds.E`Casts from <code>i128</code> to <code>i64</code> clamping at the numeric bounds.DoCasts from <code>i64</code> to <code>i64</code> clamping at the numeric bounds.DoCasts from <code>u64</code> to <code>i64</code> clamping at the numeric bounds.DoCasts from <code>i32</code> to <code>i64</code> clamping at the numeric bounds.DnCasts from <code>u8</code> to <code>i64</code> clamping at the numeric bounds.E`Casts from <code>u128</code> to <code>i64</code> clamping at the numeric bounds.DoCasts from <code>u16</code> to <code>i64</code> clamping at the numeric bounds.EaCasts from <code>usize</code> to <code>i64</code> clamping at the numeric bounds.DoCasts from <code>i16</code> to <code>i64</code> clamping at the numeric bounds.EaCasts from <code>isize</code> to <code>i64</code> clamping at the numeric bounds.DkCasts <code>self</code> to <code>u16</code> clamping at the numeric bounds.0EaCasts from <code>usize</code> to <code>u16</code> clamping at the numeric bounds.DoCasts from <code>i16</code> to <code>u16</code> clamping at the numeric bounds.DoCasts from <code>i64</code> to <code>u16</code> clamping at the numeric bounds.DnCasts from <code>i8</code> to <code>u16</code> clamping at the numeric bounds.EaCasts from <code>isize</code> to <code>u16</code> clamping at the numeric bounds.E`Casts from <code>i128</code> to <code>u16</code> clamping at the numeric bounds.DoCasts from <code>u32</code> to <code>u16</code> clamping at the numeric bounds.E`Casts from <code>u128</code> to <code>u16</code> clamping at the numeric bounds.DoCasts from <code>u16</code> to <code>u16</code> clamping at the numeric bounds.DoCasts from <code>u64</code> to <code>u16</code> clamping at the numeric bounds.DoCasts from <code>i32</code> to <code>u16</code> clamping at the numeric bounds.DnCasts from <code>u8</code> to <code>u16</code> clamping at the numeric bounds.DkCasts <code>self</code> to <code>u32</code> clamping at the numeric bounds.0DoCasts from <code>u64</code> to <code>u32</code> clamping at the numeric bounds.DnCasts from <code>u8</code> to <code>u32</code> clamping at the numeric bounds.E`Casts from <code>u128</code> to <code>u32</code> clamping at the numeric bounds.EaCasts from <code>isize</code> to <code>u32</code> clamping at the numeric bounds.DoCasts from <code>i16</code> to <code>u32</code> clamping at the numeric bounds.DoCasts from <code>i32</code> to <code>u32</code> clamping at the numeric bounds.EaCasts from <code>usize</code> to <code>u32</code> clamping at the numeric bounds.DoCasts from <code>u16</code> to <code>u32</code> clamping at the numeric bounds.DoCasts from <code>i64</code> to <code>u32</code> clamping at the numeric bounds.E`Casts from <code>i128</code> to <code>u32</code> clamping at the numeric bounds.DoCasts from <code>u32</code> to <code>u32</code> clamping at the numeric bounds.DnCasts from <code>i8</code> to <code>u32</code> clamping at the numeric bounds.DkCasts <code>self</code> to <code>u64</code> clamping at the numeric bounds.0DoCasts from <code>u16</code> to <code>u64</code> clamping at the numeric bounds.E`Casts from <code>u128</code> to <code>u64</code> clamping at the numeric bounds.DoCasts from <code>u32</code> to <code>u64</code> clamping at the numeric bounds.E`Casts from <code>i128</code> to <code>u64</code> clamping at the numeric bounds.DoCasts from <code>i64</code> to <code>u64</code> clamping at the numeric bounds.DoCasts from <code>u64</code> to <code>u64</code> clamping at the numeric bounds.DnCasts from <code>u8</code> to <code>u64</code> clamping at the numeric bounds.DoCasts from <code>i32</code> to <code>u64</code> clamping at the numeric bounds.DnCasts from <code>i8</code> to <code>u64</code> clamping at the numeric bounds.EaCasts from <code>usize</code> to <code>u64</code> clamping at the numeric bounds.DoCasts from <code>i16</code> to <code>u64</code> clamping at the numeric bounds.EaCasts from <code>isize</code> to <code>u64</code> clamping at the numeric bounds.DhScans up-to <code>scan_len</code> bytes from the stream until a byte \xe2\x80\xa6BjBegin to serialize a tuple struct like \xe2\x80\xa60E`Serialize a unit variant like <code>E::A</code> in <code>enum E { A, B }</code>.0Dd<strong>Sets</strong> the attribute: whether to require hardware \xe2\x80\xa6DdSets the args into an <code>m128i</code>, first arg is the low lane.0CjSet <code>i16</code> args into an <code>m256i</code> lane.011CjSet <code>i32</code> args into an <code>m256i</code> lane.0CjSet <code>i64</code> args into an <code>m256i</code> lane.0CeSet <code>m128</code> args into an <code>m256</code>.0CjSets the position of the right ear in 3 dimensional space.BlSet the shape of the window To be effective:ClSign extends an arbitrary, 8-bit or less, signed two\xe2\x80\x99s \xe2\x80\xa6CfExposes a vector of pointers as a vector of addresses.00DjReturns a mutable middle subslice of <code>slice</code> with the given \xe2\x80\xa60CeSort all iterator elements into a new iterator in \xe2\x80\xa6000CgSplat the lowest 8-bit lane across the entire 128 bits.0CeReturns an array of substrings of a string slice, \xe2\x80\xa6D`Stores the <code>i32</code> masked lanes given to the reference.0000000DfConditionally write contiguous elements to <code>slice</code>. The \xe2\x80\xa6DjFinds the index of the last character in <code>self</code> that is not \xe2\x80\xa6CgReturns the first <code>n</code> elements of the slice.ClReturns the slice omitting the last <code>n</code> elements.CeConverts a civil datetime to a possibly ambiguous \xe2\x80\xa6DoReturns the ASCII representation as a <code>&amp;&#39;static str</code>, or \xe2\x80\xa6BmReturns the total number of incoming packets.CnTruncate the <code>f32</code> lanes to <code>i32</code> lanes.0CkTries to acquire <code>n</code> permits from the semaphore.CfReads from the bytes as if they were a <code>T</code>.0CeSets the underline color to <code>DarkMagenta</code>.EoReturn encoded password hash. <strong><strong>Warning</strong></strong>: Should not be used \xe2\x80\xa6BoThis removes all effects registered to channel.CmUnhooks the specified function set before, so no function \xe2\x80\xa6CnWindow has been minimized Right now is only implemented on \xe2\x80\xa6000CmExecutes a closure with a Python critical section held on \xe2\x80\xa6CgProvide a verification code of the final decoded audio.DdCreates a pointer with the given address and no <em>provenance</em>.CkCreates a pointer with the given address and no provenance.00DmCasts <code>self</code> to <code>isize</code> wrapping at the numeric bounds.0EbCasts from <code>i128</code> to <code>isize</code> wrapping at the numeric bounds.EbCasts from <code>u128</code> to <code>isize</code> wrapping at the numeric bounds.EaCasts from <code>i16</code> to <code>isize</code> wrapping at the numeric bounds.EaCasts from <code>u64</code> to <code>isize</code> wrapping at the numeric bounds.EcCasts from <code>usize</code> to <code>isize</code> wrapping at the numeric bounds.EaCasts from <code>i32</code> to <code>isize</code> wrapping at the numeric bounds.E`Casts from <code>i8</code> to <code>isize</code> wrapping at the numeric bounds.EaCasts from <code>i64</code> to <code>isize</code> wrapping at the numeric bounds.EaCasts from <code>u32</code> to <code>isize</code> wrapping at the numeric bounds.E`Casts from <code>u8</code> to <code>isize</code> wrapping at the numeric bounds.EcCasts from <code>isize</code> to <code>isize</code> wrapping at the numeric bounds.EaCasts from <code>u16</code> to <code>isize</code> wrapping at the numeric bounds.DmCasts <code>self</code> to <code>usize</code> wrapping at the numeric bounds.0EbCasts from <code>i128</code> to <code>usize</code> wrapping at the numeric bounds.EaCasts from <code>i64</code> to <code>usize</code> wrapping at the numeric bounds.E`Casts from <code>u8</code> to <code>usize</code> wrapping at the numeric bounds.EaCasts from <code>i32</code> to <code>usize</code> wrapping at the numeric bounds.EaCasts from <code>i16</code> to <code>usize</code> wrapping at the numeric bounds.EaCasts from <code>u32</code> to <code>usize</code> wrapping at the numeric bounds.EcCasts from <code>isize</code> to <code>usize</code> wrapping at the numeric bounds.EaCasts from <code>u16</code> to <code>usize</code> wrapping at the numeric bounds.EbCasts from <code>u128</code> to <code>usize</code> wrapping at the numeric bounds.EaCasts from <code>u64</code> to <code>usize</code> wrapping at the numeric bounds.E`Casts from <code>i8</code> to <code>usize</code> wrapping at the numeric bounds.EcCasts from <code>usize</code> to <code>usize</code> wrapping at the numeric bounds.Bm&lt; Duration accurately estimated from PTSesCnHeader data; this needs to be present for the stream to be \xe2\x80\xa6Bk&lt; Opaque data information usually sparseChThis structure supplies correlation between a packet \xe2\x80\xa6Cl&lt; full parsing and repack with timestamp and position \xe2\x80\xa6CfThe channel order does not correspond to any other \xe2\x80\xa6CjThe native channel order, i.e. the channels are in the \xe2\x80\xa6ClOnly the channel count is specified, without any further \xe2\x80\xa6jSee above.Ac&lt; Not indicated.ClApply the maximum possible cropping, even if it requires \xe2\x80\xa6ChThe data represents the AVSphericalMapping structure \xe2\x80\xa6Bk&lt; hardware decoding through VideotoolboxDh&lt; planar YUV 4:2:0 25bpp, (1 Cr &amp; Cb sample per 2x2 Y &amp; A \xe2\x80\xa60Dh&lt; planar YUV 4:2:0 40bpp, (1 Cr &amp; Cb sample per 2x2 Y &amp; A \xe2\x80\xa60Dh&lt; planar YUV 4:2:2 30bpp, (1 Cr &amp; Cb sample per 2x1 Y &amp; A \xe2\x80\xa60D`&lt; planar YUV 4:2:2,24bpp, (1 Cr &amp; Cb sample per 2x1 Y \xe2\x80\xa60Dh&lt; planar YUV 4:2:2 48bpp, (1 Cr &amp; Cb sample per 2x1 Y &amp; A \xe2\x80\xa60Dh&lt; planar YUV 4:4:4 40bpp, (1 Cr &amp; Cb sample per 1x1 Y &amp; A \xe2\x80\xa60D`&lt; planar YUV 4:4:4,36bpp, (1 Cr &amp; Cb sample per 1x1 Y \xe2\x80\xa60Dh&lt; planar YUV 4:4:4 64bpp, (1 Cr &amp; Cb sample per 1x1 Y &amp; A \xe2\x80\xa60CiICC profile data consisting of an opaque octet buffer \xe2\x80\xa6CnAn AV_PKT_DATA_JP_DUALMONO side data packet indicates that \xe2\x80\xa6B`Frame contains two packed views.DhThe cell was already initialized when <code>OnceCell::set</code> was \xe2\x80\xa6CmA command that instructs the terminal emulator to begin a \xe2\x80\xa6DjA deserializer holding a <code>&amp;str</code> with a lifetime tied to \xe2\x80\xa6AiG.726 ADPCM little-endianAcADPCM IMA QuickTimeCmAllows controlling resources the user agent is allowed to \xe2\x80\xa6CnAn iterator that supports \xe2\x80\x9crandom access\xe2\x80\x9d to its data, \xe2\x80\xa60fU+001F0000fU+001E0000Dg<code>IntoParallelRefIterator</code> implements the conversion to a \xe2\x80\xa60DfAn extension trait for miniquad\xe2\x80\x99s <code>MiniquadEventHandler</code>.0EeThis variant corresponds with <code>METH_VARARGS</code> | <code>METH_KEYWORDS</code>.DcRepresents Python\xe2\x80\x99s <code>UnicodeTranslateError</code> exception.Cf\\brief Game controller axis motion event structure \xe2\x80\xa6Bi&lt; Flash the window until it gets focusBgGet the currently active OpenGL window.CbClose a game controller previously opened with \xe2\x80\xa6BbGet the current assertion handler.BlDetermine the L1 cache line size of the CPU.CjGet the name and preferred format of the default audio \xe2\x80\xa6CiGet the current state of the mouse in relation to the \xe2\x80\xa6ClGet the device information encoded in a SDL_JoystickGUID \xe2\x80\xa6ClGet the number of 2D rendering drivers available for the \xe2\x80\xa6BkGet the number of available video displays.BeReport the user\xe2\x80\x99s preferred locale.ChGet the index of the display primarily containing a rectCiGet info about a specific 2D rendering driver for the \xe2\x80\xa6BjGet a scancode from a human-readable name.BlGet the shape parameters of a shaped window.BlGet the blend mode used for blit operations.CdGet the blend mode used for texture copy operations.CeGet the scale mode used for texture scale operations.CnGet the brightness (gamma multiplier) for a given window\xe2\x80\x99\xe2\x80\xa6CmGet the raw ICC profile data for the screen the window is \xe2\x80\xa6BfDestroy a haptic effect on the device.CcTry to open a haptic device from the current mouse.BhSet the global autocenter of the device.BgGet the status of a specified joystick.BjLoad Dollar Gesture templates from a file.Cb\\brief Scroll direction types for the Scroll eventCb&lt; The display orientation can\xe2\x80\x99t be determinedBa&lt; Plugged in, charging batteryCn&lt; The device has been reset and all textures need to be \xe2\x80\xa6ChGet the CAMetalLayer associated with the given Metal \xe2\x80\xa6CfGet whether clipping is enabled on the given renderer.o&lt; AC Forwardo&lt; AC RefreshAb&lt; AL Calculatorj&lt; Arrowk&lt; I-beamCbGet the implementation dependent name of a sensor.AiGet the type of a sensor.B`Get the instance ID of a sensor.BmSet an application-defined assertion handler.BdSet a hint with a specific priority.BlSet the blend mode used for blit operations.CkSet the blend mode for a texture, used by SDL_RenderCopy().CeSet the scale mode used for texture scale operations.CnSet the brightness (gamma multiplier) for a given window\xe2\x80\x99\xe2\x80\xa6BbSet a window\xe2\x80\x99s fullscreen state.BiExplicitly set input focus to the window.Ci\\brief Extended keyboard text editing event structure \xe2\x80\xa6BfCopy the window surface to the screen.CkThe structure that defines an extended virtual joystick \xe2\x80\xa6Cb&lt; Window has been exposed and should be redrawnBk&lt; Window has been resized to data1xdata2Bn&lt; window should not be added to the taskbarAd&lt; Full range JPEGCj\\brief The formula used for converting between YUV and RGBBiSet the device handle to be non-blocking.BcIterator for SoC vendor attributes.BbStreaming XChaCha20Poly1305 state.DgAn extension trait for <code>TransparentWrapper</code> and alloc types.0Cb506 Variant Also Negotiates [RFC2295, Section 8.1]AkSee <code>_mm_setcsr</code>00000000000BnSearch for the defined substring in the target00E`<strong>Index only</strong>: return the least significant bit <em>(Default)</em>00oNegates results00BhDo not negate results <em>(Default)</em>00EgReturns the bit in position <code>b</code> of the memory addressed by <code>p</code>\xe2\x80\xa600DgBroadcasts the low packed 32-bit integer from <code>a</code> to all \xe2\x80\xa600DgBroadcasts the low packed 64-bit integer from <code>a</code> to all \xe2\x80\xa600CjBroadcasts the low packed 16-bit integer from a to all \xe2\x80\xa600ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa600CkCompare packed 32-bit integers in a and b for equality, \xe2\x80\xa600CkCompare packed 64-bit integers in a and b for equality, \xe2\x80\xa600CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa600CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa600CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa600555ChCompare packed signed 32-bit integers in a and b for \xe2\x80\xa600ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa600444333222777111000444333222777111000444333222777111000444333222CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa600CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa600CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa600ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa600CnStores 8 32-bit integer elements from a to memory starting \xe2\x80\xa600CkScatter 64-bit integers from a into memory using 32-bit \xe2\x80\xa600CnStores 4 32-bit integer elements from a to memory starting \xe2\x80\xa600CnStores 4 64-bit integer elements from a to memory starting \xe2\x80\xa600EcCopies <code>a</code> to result, then inserts 128 bits from <code>b</code> into \xe2\x80\xa600EeCopies <code>a</code> to <code>dst</code>, then insert 128 bits (of integer data) \xe2\x80\xa600CgMultiply packed complex numbers in a by the complex \xe2\x80\xa600CiConcatenate pairs of 16-byte blocks in a and b into a \xe2\x80\xa600CkBlend packed 16-bit integers from a and b using control \xe2\x80\xa600CkBlend packed 32-bit integers from a and b using control \xe2\x80\xa600CkBlend packed 64-bit integers from a and b using control \xe2\x80\xa600CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa600CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa600CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa600CkContiguously store the active double-precision (64-bit) \xe2\x80\xa600CkContiguously store the active single-precision (32-bit) \xe2\x80\xa600ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa600ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600000000ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600000000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa600CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa600000000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000000000000000222222222222ClLoad contiguous active 8-bit integers from a (those with \xe2\x80\xa600CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa600CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa600ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa600CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa600ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa600222111000CmCopy a to tmp, then insert 128 bits (composed of 4 packed \xe2\x80\xa600CmCopy a to tmp, then insert 128 bits (composed of 2 packed \xe2\x80\xa600111000CjLoad packed 16-bit integers from memory into dst using \xe2\x80\xa600CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa600CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa600CiCounts the number of leading zero bits in each packed \xe2\x80\xa600000CcDuplicate odd-indexed single-precision (32-bit) \xe2\x80\xa600CdDuplicate even-indexed single-precision (32-bit) \xe2\x80\xa600CjMultiply the packed signed 16-bit integers in a and b, \xe2\x80\xa600ClMultiply the packed unsigned 16-bit integers in a and b, \xe2\x80\xa600CmMultiply the packed 16-bit integers in a and b, producing \xe2\x80\xa600CmMultiply the packed 32-bit integers in a and b, producing \xe2\x80\xa600EcMultiply packed 64-bit integers in <code>a</code> and <code>b</code>, producing \xe2\x80\xa600CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa600CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa600CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa600CnFor each packed 8-bit integer maps the value to the number \xe2\x80\xa600CnConcatenate packed 16-bit integers in a and b producing an \xe2\x80\xa600CnConcatenate packed 32-bit integers in a and b producing an \xe2\x80\xa600CnConcatenate packed 64-bit integers in a and b producing an \xe2\x80\xa600222111000CnConcatenate packed 16-bit integers in b and a producing an \xe2\x80\xa600CnConcatenate packed 32-bit integers in b and a producing an \xe2\x80\xa600CnConcatenate packed 64-bit integers in b and a producing an \xe2\x80\xa600222111000CiStore packed 32-bit integers from a into memory using \xe2\x80\xa600CiStore packed 64-bit integers from a into memory using \xe2\x80\xa600ChStore packed 8-bit integers from a into memory using \xe2\x80\xa600CcUnpack and interleave double-precision (64-bit) \xe2\x80\xa600CcUnpack and interleave single-precision (32-bit) \xe2\x80\xa600111000CfAdd packed signed 16-bit integers in a and b using \xe2\x80\xa600ChAdd packed unsigned 16-bit integers in a and b using \xe2\x80\xa600CeCompute the sum of absolute differences (SADs) of \xe2\x80\xa600CgMultiply packed complex numbers in a by the complex \xe2\x80\xa600CfNormalize the mantissas of packed double-precision \xe2\x80\xa600CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa600CfNormalize the mantissas of packed single-precision \xe2\x80\xa600CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa600CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa600CiLoad packed 8-bit integers from memory into dst using \xe2\x80\xa600CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa600CdDuplicate even-indexed double-precision (64-bit) \xe2\x80\xa600CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa600CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa600CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa600CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa600111000ClCompute the approximate reciprocal square root of packed \xe2\x80\xa600000CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa600CkBroadcast 32-bit integer a to all elements of dst using \xe2\x80\xa600CkBroadcast 64-bit integer a to all elements of dst using \xe2\x80\xa600777666ChShift packed 16-bit integers in a left by imm8 while \xe2\x80\xa600ChShift packed 32-bit integers in a left by imm8 while \xe2\x80\xa600ChShift packed 64-bit integers in a left by imm8 while \xe2\x80\xa600ChShift packed 16-bit integers in a left by the amount \xe2\x80\xa600ChShift packed 32-bit integers in a left by the amount \xe2\x80\xa600ChShift packed 64-bit integers in a left by the amount \xe2\x80\xa600CiShift packed 16-bit integers in a right by imm8 while \xe2\x80\xa600CiShift packed 32-bit integers in a right by imm8 while \xe2\x80\xa600CiShift packed 64-bit integers in a right by imm8 while \xe2\x80\xa600CiShift packed 16-bit integers in a right by the amount \xe2\x80\xa600CiShift packed 32-bit integers in a right by the amount \xe2\x80\xa600CiShift packed 64-bit integers in a right by the amount \xe2\x80\xa600555444333222111000CkSubtract packed signed 16-bit integers in b from packed \xe2\x80\xa600CmSubtract packed unsigned 16-bit integers in b from packed \xe2\x80\xa600CfShuffle 8-bit integers in a across lanes using the \xe2\x80\xa600CgReduce the packed 16-bit integers in a by addition. \xe2\x80\xa600CjReduce the packed 16-bit integers in a by bitwise AND. \xe2\x80\xa600CnReduce the packed 16-bit integers in a by maximum. Returns \xe2\x80\xa600CfReduce the packed unsigned 16-bit integers in a by \xe2\x80\xa600CnReduce the packed 16-bit integers in a by minimum. Returns \xe2\x80\xa600111CmReduce the packed 16-bit integers in a by multiplication. \xe2\x80\xa600CnThis intrinsic is one of the two SHA512 message scheduling \xe2\x80\xa600000CkCompute the bitwise NAND of packed 16-bit integers in a \xe2\x80\xa600CkCompute the bitwise NAND of packed 32-bit integers in a \xe2\x80\xa600CkCompute the bitwise NAND of packed 64-bit integers in a \xe2\x80\xa600CiBroadcast the low packed 32-bit integer from a to all \xe2\x80\xa600CiBroadcast the low packed 64-bit integer from a to all \xe2\x80\xa600CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa600ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa600CkCompare packed 32-bit integers in a and b for equality, \xe2\x80\xa600CkCompare packed 64-bit integers in a and b for equality, \xe2\x80\xa600CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa600CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa600CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa600555ChCompare packed signed 32-bit integers in a and b for \xe2\x80\xa600ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa600444333222777111000444333222777111000444333222777111000444333222CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa600CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa600CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa600CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa600CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000CgMultiply packed complex numbers in a by the complex \xe2\x80\xa600CfNormalize the mantissas of packed double-precision \xe2\x80\xa600CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa600CfNormalize the mantissas of packed single-precision \xe2\x80\xa600CkScatter 32-bit integers from a into memory using 32-bit \xe2\x80\xa600CkScatter 64-bit integers from a into memory using 32-bit \xe2\x80\xa600CkScatter 32-bit integers from a into memory using 64-bit \xe2\x80\xa600CkScatter 64-bit integers from a into memory using 64-bit \xe2\x80\xa600777CiConcatenate pairs of 16-byte blocks in a and b into a \xe2\x80\xa600CkBlend packed 16-bit integers from a and b using control \xe2\x80\xa600CkBlend packed 32-bit integers from a and b using control \xe2\x80\xa600CkBlend packed 64-bit integers from a and b using control \xe2\x80\xa600???CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa600???CkContiguously store the active double-precision (64-bit) \xe2\x80\xa600CkContiguously store the active single-precision (32-bit) \xe2\x80\xa600ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa600ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600000000ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600000000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600000000CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa600CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa600000000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000000000000000222222222222ClLoad contiguous active 8-bit integers from a (those with \xe2\x80\xa600CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa600CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa600ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa600CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa600ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa600222111000CmCopy a to tmp, then insert 128 bits (composed of 4 packed \xe2\x80\xa600CmCopy a to tmp, then insert 256 bits (composed of 8 packed \xe2\x80\xa600CmCopy a to tmp, then insert 128 bits (composed of 2 packed \xe2\x80\xa600CmCopy a to tmp, then insert 256 bits (composed of 4 packed \xe2\x80\xa600333222111000CjLoad packed 16-bit integers from memory into dst using \xe2\x80\xa600CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa600CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa600CiCounts the number of leading zero bits in each packed \xe2\x80\xa600000CcDuplicate odd-indexed single-precision (32-bit) \xe2\x80\xa600CdDuplicate even-indexed single-precision (32-bit) \xe2\x80\xa600CjMultiply the packed signed 16-bit integers in a and b, \xe2\x80\xa600ClMultiply the packed unsigned 16-bit integers in a and b, \xe2\x80\xa600CmMultiply the packed 16-bit integers in a and b, producing \xe2\x80\xa600CmMultiply the packed 32-bit integers in a and b, producing \xe2\x80\xa600EcMultiply packed 64-bit integers in <code>a</code> and <code>b</code>, producing \xe2\x80\xa600CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa600CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa600CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa600CnFor each packed 8-bit integer maps the value to the number \xe2\x80\xa600CnConcatenate packed 16-bit integers in a and b producing an \xe2\x80\xa600CnConcatenate packed 32-bit integers in a and b producing an \xe2\x80\xa600CnConcatenate packed 64-bit integers in a and b producing an \xe2\x80\xa600222111000CnConcatenate packed 16-bit integers in b and a producing an \xe2\x80\xa600CnConcatenate packed 32-bit integers in b and a producing an \xe2\x80\xa600CnConcatenate packed 64-bit integers in b and a producing an \xe2\x80\xa600222111000CiStore packed 32-bit integers from a into memory using \xe2\x80\xa600CiStore packed 64-bit integers from a into memory using \xe2\x80\xa600ChStore packed 8-bit integers from a into memory using \xe2\x80\xa600CcUnpack and interleave double-precision (64-bit) \xe2\x80\xa600CcUnpack and interleave single-precision (32-bit) \xe2\x80\xa600111000CfAdd packed signed 16-bit integers in a and b using \xe2\x80\xa600ChAdd packed unsigned 16-bit integers in a and b using \xe2\x80\xa600CeCompute the sum of absolute differences (SADs) of \xe2\x80\xa600CgMultiply packed complex numbers in a by the complex \xe2\x80\xa600CfNormalize the mantissas of packed double-precision \xe2\x80\xa600CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa600CfNormalize the mantissas of packed single-precision \xe2\x80\xa600CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa600CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa600CiLoad packed 8-bit integers from memory into dst using \xe2\x80\xa600CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa600CdDuplicate even-indexed double-precision (64-bit) \xe2\x80\xa600CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa600CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa600CmRotate the bits in each packed 32-bit integer in a to the \xe2\x80\xa600CmRotate the bits in each packed 64-bit integer in a to the \xe2\x80\xa600111000ClCompute the approximate reciprocal square root of packed \xe2\x80\xa600000CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa600CkBroadcast 32-bit integer a to all elements of dst using \xe2\x80\xa600CkBroadcast 64-bit integer a to all elements of dst using \xe2\x80\xa600777666ChShift packed 16-bit integers in a left by imm8 while \xe2\x80\xa600ChShift packed 32-bit integers in a left by imm8 while \xe2\x80\xa600ChShift packed 64-bit integers in a left by imm8 while \xe2\x80\xa600ChShift packed 16-bit integers in a left by the amount \xe2\x80\xa600ChShift packed 32-bit integers in a left by the amount \xe2\x80\xa600ChShift packed 64-bit integers in a left by the amount \xe2\x80\xa600CiShift packed 16-bit integers in a right by imm8 while \xe2\x80\xa600CiShift packed 32-bit integers in a right by imm8 while \xe2\x80\xa600CiShift packed 64-bit integers in a right by imm8 while \xe2\x80\xa600CiShift packed 16-bit integers in a right by the amount \xe2\x80\xa600CiShift packed 32-bit integers in a right by the amount \xe2\x80\xa600CiShift packed 64-bit integers in a right by the amount \xe2\x80\xa600555444333222111000CkSubtract packed signed 16-bit integers in b from packed \xe2\x80\xa600CmSubtract packed unsigned 16-bit integers in b from packed \xe2\x80\xa600CgShuffle 32-bit integers in a across lanes using the \xe2\x80\xa600CfShuffle 8-bit integers in a across lanes using the \xe2\x80\xa600CgReduce the packed 32-bit integers in a by addition. \xe2\x80\xa600CgReduce the packed 64-bit integers in a by addition. \xe2\x80\xa600CjReduce the packed 32-bit integers in a by bitwise AND. \xe2\x80\xa600CjReduce the packed 64-bit integers in a by bitwise AND. \xe2\x80\xa600CmReduce the packed signed 32-bit integers in a by maximum. \xe2\x80\xa600CmReduce the packed signed 64-bit integers in a by maximum. \xe2\x80\xa600CfReduce the packed unsigned 32-bit integers in a by \xe2\x80\xa600CfReduce the packed unsigned 64-bit integers in a by \xe2\x80\xa600CmReduce the packed signed 32-bit integers in a by minimum. \xe2\x80\xa600CmReduce the packed signed 64-bit integers in a by minimum. \xe2\x80\xa600333222CmReduce the packed 32-bit integers in a by multiplication. \xe2\x80\xa600CmReduce the packed 64-bit integers in a by multiplication. \xe2\x80\xa600CkCompute the bitwise NAND of packed 16-bit integers in a \xe2\x80\xa600CkCompute the bitwise NAND of packed 32-bit integers in a \xe2\x80\xa600CkCompute the bitwise NAND of packed 64-bit integers in a \xe2\x80\xa600CnBroadcast the low single-precision (32-bit) floating-point \xe2\x80\xa600CmCompare packed signed 16-bit integers in a and b based on \xe2\x80\xa600CmCompare packed signed 32-bit integers in a and b based on \xe2\x80\xa600CmCompare packed signed 64-bit integers in a and b based on \xe2\x80\xa600ClCompare packed unsigned 16-bit integers in a and b based \xe2\x80\xa600ClCompare packed unsigned 32-bit integers in a and b based \xe2\x80\xa600ClCompare packed unsigned 64-bit integers in a and b based \xe2\x80\xa600CjMultiply the lower complex numbers in a by the complex \xe2\x80\xa600CmContiguously store the active 16-bit integers in a (those \xe2\x80\xa600CmContiguously store the active 32-bit integers in a (those \xe2\x80\xa600CmContiguously store the active 64-bit integers in a (those \xe2\x80\xa600CmTest each 32-bit element of a for equality with all other \xe2\x80\xa600CmTest each 64-bit element of a for equality with all other \xe2\x80\xa600CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa600CnConvert the lower double-precision (64-bit) floating-point \xe2\x80\xa600000ClConvert the lower half-precision (16-bit) floating-point \xe2\x80\xa600000CnConvert the lower single-precision (32-bit) floating-point \xe2\x80\xa600000ClSign extend packed 16-bit integers in a to packed 32-bit \xe2\x80\xa600ClSign extend packed 16-bit integers in a to packed 64-bit \xe2\x80\xa600ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa600ClSign extend packed 32-bit integers in a to packed 64-bit \xe2\x80\xa600ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa600ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa600CnZero extend packed unsigned 16-bit integers in a to packed \xe2\x80\xa600ClZero extend packed unsigned 16-bit integers in the low 4 \xe2\x80\xa600CnZero extend packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa600CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa600CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa600CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa600CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa600C`Multiply the lower double-precision (64-bit) \xe2\x80\xa600CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa600C`Multiply the lower single-precision (32-bit) \xe2\x80\xa600222111000ClMultiply the lower complex numbers in a and b, and store \xe2\x80\xa600CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa600000CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa600000CmReduce the packed 8-bit integers in a by bitwise OR using \xe2\x80\xa600CmCompute the bitwise AND of packed 8-bit integers in a and \xe2\x80\xa600ClUnpack and interleave 16-bit integers from the high half \xe2\x80\xa600ClUnpack and interleave 32-bit integers from the high half \xe2\x80\xa600ClUnpack and interleave 64-bit integers from the high half \xe2\x80\xa600CnUnpack and interleave 16-bit integers from the low half of \xe2\x80\xa600CnUnpack and interleave 32-bit integers from the low half of \xe2\x80\xa600CnUnpack and interleave 64-bit integers from the low half of \xe2\x80\xa600ClContiguously store the active 8-bit integers in a (those \xe2\x80\xa600CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa600CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa600CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa600CkSign extend packed 8-bit integers in a to packed 16-bit \xe2\x80\xa600CkSign extend packed 8-bit integers in a to packed 32-bit \xe2\x80\xa600CmSign extend packed 8-bit integers in the low 2 bytes of a \xe2\x80\xa600CmZero extend packed unsigned 8-bit integers in a to packed \xe2\x80\xa600CkZero extend packed unsigned 8-bit integers in th elow 4 \xe2\x80\xa600CkZero extend packed unsigned 8-bit integers in the low 2 \xe2\x80\xa600CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa600ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa600CmPerforms a multiplication in GF(2^8) on the packed bytes. \xe2\x80\xa600CjMultiply packed unsigned 8-bit integers in a by packed \xe2\x80\xa600ClMultiply the lower complex numbers in a and b, and store \xe2\x80\xa600CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa600CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa600CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa600CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa600CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa600ClRound the lower double-precision (64-bit) floating-point \xe2\x80\xa600CjRound the lower half-precision (16-bit) floating-point \xe2\x80\xa600ClRound the lower single-precision (32-bit) floating-point \xe2\x80\xa600CkShuffle 32-bit integers in a within 128-bit lanes using \xe2\x80\xa600CiCompute the square root of the lower double-precision \xe2\x80\xa600CgCompute the square root of the lower half-precision \xe2\x80\xa600CiCompute the square root of the lower single-precision \xe2\x80\xa600CnUnpack and interleave 8-bit integers from the high half of \xe2\x80\xa600CmUnpack and interleave 8-bit integers from the low half of \xe2\x80\xa600888777666CiTests whether the specified bits in a 128-bit integer \xe2\x80\xa600DeLanewise saturating <code>a + b</code> with lanes as <code>i8</code>.000DeLanewise saturating <code>a + b</code> with lanes as <code>u8</code>.000CnCreate a writable reference from a given buffer reference, \xe2\x80\xa6CjGet a frame with filtered data from sink and put it in \xe2\x80\xa6CnCheck whether a channel layout is valid, i.e. can possibly \xe2\x80\xa6Cl@return the name for provided chroma location or NULL if \xe2\x80\xa6Cl@return the name for provided color primaries or NULL if \xe2\x80\xa6CjAllocate a CPB properties structure and initialize its \xe2\x80\xa6ChExtract the rotation component of the transformation \xe2\x80\xa6ChInitialize a transformation matrix describing a pure \xe2\x80\xa6ClSet the maximum size (in elements) to which the FIFO can \xe2\x80\xa6ClFeed data at specific position from an AVFifoBuffer to a \xe2\x80\xa6CjCheck whether filename actually is a numbered sequence \xe2\x80\xa6CaCrop the given video AVFrame according to its \xe2\x80\xa6Bo@return a string identifying the side data typeBbReturn number of bytes per sample.CfGet the name of a color from the internal table of \xe2\x80\xa6CmGet timing information for the data currently output. The \xe2\x80\xa6BlCopy image data from an image into a buffer.CgFill plane linesizes for an image with pixel format \xe2\x80\xa6AhDefault logging callbackBmWrap an existing array as a packet side data.BaGet side information from packet.CkCreate a writable reference for the data described by a \xe2\x80\xa6BeAllocate new information of a packet.BgWrap existing data as packet side data.BlGet side information from a side data array.B`Allocate a new packet side data.Cn@return number of planes in pix_fmt, a negative AVERROR if \xe2\x80\xa6BeCheck if the sample format is planar.BkWrap an existing array as stream side data.BaGet side information from stream.BeAllocate new information from stream.AgFlush the message queueAlLoad timecode string in buf.CgIterate over all codec descriptors known to libavcodec.Al@addtogroup lavc_encoding @{ClCopy the contents of src to dst. Any allocated fields in \xe2\x80\xa6CeFree an AVCodecParameters instance and everything \xe2\x80\xa6CjUndo the initialization done by avformat_network_init. \xe2\x80\xa6ChReturn the name of the protocol that will handle the \xe2\x80\xa6ClWrite a NULL terminated array of strings to the context. \xe2\x80\xa6BlGet AVClass by names of available protocols.CoFinds the index of the last 1 in <code>bits</code> from the \xe2\x80\xa60ClGets the mask of all bits up to and including the lowest \xe2\x80\xa6000EaUnsets the bits in <code>self</code> to 0 from the <code>[start..=end]</code> \xe2\x80\xa60DfZero out all high bits in a <code>u32</code> starting at the index \xe2\x80\xa60DfZero out all high bits in a <code>u64</code> starting at the index \xe2\x80\xa60CnShifts all bits in the entire register left by a number of \xe2\x80\xa60CmShifts each <code>u128</code> lane left by a number of bytes.DnShifts each <code>u128</code> lane left by a number of <strong>bytes</strong>.ClShifts all bits in the entire register right by a number \xe2\x80\xa60CnShifts each <code>u128</code> lane right by a number of bytes.DoShifts each <code>u128</code> lane right by a number of <strong>bytes</strong>.D`Bit-preserving cast to <code>m128</code> from <code>m128d</code>0D`Bit-preserving cast to <code>m128</code> from <code>m128i</code>0D`Bit-preserving cast to <code>m128d</code> from <code>m128</code>0D`Bit-preserving cast to <code>m128i</code> from <code>m128</code>0DaBit-preserving cast to <code>m256</code> from <code>m256d</code>.0DaBit-preserving cast to <code>m256</code> from <code>m256i</code>.0DaBit-preserving cast to <code>m256i</code> from <code>m256</code>.000DlLow lane <code>(!a.is_nan()) &amp;amp; (!b.is_nan())</code>, other lanes \xe2\x80\xa6DhLow lane <code>(!a.is_nan()) &amp; (!b.is_nan())</code>, other lanes \xe2\x80\xa6EgReturns the UTF-8 byte length of <code>code</code> <strong>without validation</strong>.CjCheck if the pre-condition <code>cond</code> has been met.00CmCopies the specified slice into the buffer. If the buffer \xe2\x80\xa6EfReturns the default value for this <code>Copy</code> type, or <code>None</code> if \xe2\x80\xa600DfHint that the <code>Deserialize</code> type needs to deserialize a \xe2\x80\xa60DjHint that the <code>Deserialize</code> type is expecting a unit struct \xe2\x80\xa60DnLike <code>downcast_unchecked</code> but takes ownership of <code>self</code>.0CeCreate a new zero-sized slice in the provided buffer.DkFor each slice in <code>slices</code>, copies all elements in the slice \xe2\x80\xa6EhGets an <code>i8</code> value out of an <code>m256i</code>, returns as <code>i32</code>.0CmNumber of fixed-function performance counters (if Version \xe2\x80\xa6DcCreates a <code>RawEntryMut</code> from the given key and its hash.C`Access an immutable entry by a key and its hash.Bg<em>const</em> method equivalent to \xe2\x80\xa6CgConvert an offset to a structured <code>Weekday</code>.0CiConverts a mutable slice of bytes to a mutable string \xe2\x80\xa6CgConverts a slice of bytes to a string slice without \xe2\x80\xa60000BhLanewise fused <code>-(a * b) + c</code>000BhLanewise fused <code>-(a * b) - c</code>000DhReads from indices in <code>slice</code> to construct a SIMD vector. \xe2\x80\xa6ClInformation for saving/restoring extended register state \xe2\x80\xa6DkInitializes this <code>OnceLock</code> with the given closure if it has \xe2\x80\xa6CgQuality of service enforcement information (LEAF=0x10).CfQuality of service monitoring information (LEAF=0x0F).DiReturns a copy of <code>self</code> with only the value of the bit at \xe2\x80\xa600BhReturns the current <code>0</code> flag.EgGets the value of the bits in <code>self</code> from the <code>[start..=end]</code> \xe2\x80\xa600000000000DjGets the value of the bits from the <code>[start..=end]</code> checked \xe2\x80\xa600BaLoads the default OpenGL library.CaBreakpoint Addressing masking extended to bit 31.BeAlternate Injection supported if set.AmSupports AVX512_VP2INTERSECT.ChHWP Activity Window. IA32_HWP_REQUEST[bits 41:32] is \xe2\x80\xa6CiMisaligned SSE mode. See \xe2\x80\x9cMisaligned Access Support \xe2\x80\xa6AlTopology extensions support.CiRetrieves the horizontal scaled kerning value for two \xe2\x80\xa6CnNew line metrics for fonts that append characters to lines \xe2\x80\xa6EhCreates a mismatch where <code>need</code> is an <code>Interval::closed_open</code>, \xe2\x80\xa6CmInserts a new key-value pair into the map in the gap that \xe2\x80\xa60CjInserts a new element into the set in the gap that the \xe2\x80\xa60ClInsert a key-value pair into the map without checking if \xe2\x80\xa6ChInsert a value the set without checking if the value \xe2\x80\xa6DjConsumes the <code>Box</code>, returning a wrapped raw pointer and the \xe2\x80\xa6DcConsumes the <code>Rc</code>, returning the wrapped pointer and \xe2\x80\xa6DnConsumes the <code>Weak&lt;T&gt;</code>, returning the wrapped pointer and \xe2\x80\xa62DdConsumes the <code>Arc</code>, returning the wrapped pointer and \xe2\x80\xa61BnChecks if <code>arm</code> feature is enabled.BlReturns true if the mouse button is pressed.0DhWhether <code>self</code> is equal to <code>NUM_MAX_POWER_OF_TWO</code>.00CcCheck whether the screensaver is currently enabled.CnReturns whether the argument\xe2\x80\x99s value is statically known \xe2\x80\xa600D`A macro to test at <em>runtime</em> whether a CPU feature is \xe2\x80\xa60CnIterator over generated IDs with <code>AcqRel</code> ordering.CoLoad controller input mappings from a <code>Read</code> object.CkLoads the reference into a register, replacing the high \xe2\x80\xa60CmOffset in the structure where log_level_offset is stored. \xe2\x80\xa6CjNumber of bytes to be written as padding in a metadata \xe2\x80\xa6EhComputes the non-negative modulo of <code>self</code> over <code>modulus</code>, and \xe2\x80\xa6EfComputes the non-negative modulo of <code>self</code> over |<code>modulus</code>|, \xe2\x80\xa6EeLanewise <code>a * b</code> with lanes as <code>i16</code>, keep the high bits of \xe2\x80\xa60DfMultiply the <code>i16</code> lanes and keep the high half of each \xe2\x80\xa60DePerforms a \xe2\x80\x9ccarryless\xe2\x80\x9d multiplication of two <code>i64</code> \xe2\x80\xa60EeLanewise <code>a * b</code> with lanes as <code>u16</code>, keep the high bits of \xe2\x80\xa60DfMultiply the <code>u16</code> lanes and keep the high half of each \xe2\x80\xa60EfMultiplies the odd <code>i32</code> lanes and gives the widened (<code>i64</code>) \xe2\x80\xa60EfMultiplies the odd <code>u32</code> lanes and gives the widened (<code>u64</code>) \xe2\x80\xa60CeReturn an iterator adaptor that iterates over the \xe2\x80\xa6000BfFlips the <code>Variant0</code> field.BfFlips the <code>Variant1</code> field.BfFlips the <code>Variant2</code> field.BfFlips the <code>Variant3</code> field.BfFlips the <code>Variant4</code> field.DbUnsets the bits from the <code>[start..=end]</code> checked range.00DgCreates a new <code>Components</code> type with the components list \xe2\x80\xa6D`Creates a new <code>Disks</code> type with the disk list loaded.DhCreates a new <code>Networks</code> type with the network interfaces \xe2\x80\xa6D`Creates a new <code>Users</code> type with the user list loaded.DbCreates a new <code>Groups</code> type with the group list loaded.CnThis is a panic called with a message that\xe2\x80\x99s a result of \xe2\x80\xa600000CfReturns a parallel iterator over mutable subslices \xe2\x80\xa60Ce(eventCounts) Retrieves the count of recorded events.Cg(timeOrigin) Retrieves the time origin in milliseconds.DhPrint a <code>Timestamp</code> datetime to the given writer in a way \xe2\x80\xa6CkReturns an iterator of processes with exactly the given \xe2\x80\xa6AkMaximum Frequency (in MHz).AePTS of the last frameBeNumber of incorrect DTS values so farCkRatecontrol attempt to use, at least,  times the amount \xe2\x80\xa6CkReads and returns a unary zeros encoded integer that is \xe2\x80\xa60DjRegisters all the codecs selected by the <code>feature</code> flags in \xe2\x80\xa6CiDetermine whether a window supports the use of render \xe2\x80\xa6Ch(requestAnimationFrame) Requests an animation frame, \xe2\x80\xa6ClConverts the current stack to a different capacity while \xe2\x80\xa6CgConverts the current stack to a different capacity, \xe2\x80\xa6DlCasts <code>self</code> to <code>i128</code> clamping at the numeric bounds.0E`Casts from <code>i16</code> to <code>i128</code> clamping at the numeric bounds.E`Casts from <code>u16</code> to <code>i128</code> clamping at the numeric bounds.DoCasts from <code>u8</code> to <code>i128</code> clamping at the numeric bounds.EaCasts from <code>u128</code> to <code>i128</code> clamping at the numeric bounds.EbCasts from <code>isize</code> to <code>i128</code> clamping at the numeric bounds.E`Casts from <code>u32</code> to <code>i128</code> clamping at the numeric bounds.EbCasts from <code>usize</code> to <code>i128</code> clamping at the numeric bounds.E`Casts from <code>i32</code> to <code>i128</code> clamping at the numeric bounds.E`Casts from <code>u64</code> to <code>i128</code> clamping at the numeric bounds.DoCasts from <code>i8</code> to <code>i128</code> clamping at the numeric bounds.E`Casts from <code>i64</code> to <code>i128</code> clamping at the numeric bounds.EaCasts from <code>i128</code> to <code>i128</code> clamping at the numeric bounds.DlCasts <code>self</code> to <code>u128</code> clamping at the numeric bounds.0EbCasts from <code>isize</code> to <code>u128</code> clamping at the numeric bounds.E`Casts from <code>i16</code> to <code>u128</code> clamping at the numeric bounds.E`Casts from <code>i32</code> to <code>u128</code> clamping at the numeric bounds.EaCasts from <code>u128</code> to <code>u128</code> clamping at the numeric bounds.E`Casts from <code>i64</code> to <code>u128</code> clamping at the numeric bounds.E`Casts from <code>u16</code> to <code>u128</code> clamping at the numeric bounds.E`Casts from <code>u64</code> to <code>u128</code> clamping at the numeric bounds.EbCasts from <code>usize</code> to <code>u128</code> clamping at the numeric bounds.EaCasts from <code>i128</code> to <code>u128</code> clamping at the numeric bounds.DoCasts from <code>u8</code> to <code>u128</code> clamping at the numeric bounds.E`Casts from <code>u32</code> to <code>u128</code> clamping at the numeric bounds.DoCasts from <code>i8</code> to <code>u128</code> clamping at the numeric bounds.CmSaves the supplied buffer to a file at the path specified \xe2\x80\xa6D`Begin to serialize a tuple variant like <code>E::T</code> in \xe2\x80\xa60CkSets whether the queue stays alive if there\xe2\x80\x99s no more \xe2\x80\xa6Dg<strong>Sets</strong> the attribute: the number of buffers used for \xe2\x80\xa6Dn<strong>Sets</strong> the attribute: the number of samples used around the \xe2\x80\xa6EdSets the lowest lane of an <code>m128d</code> as all lanes of an <code>m256d</code>.0EgSets the given <code>value</code> into the bits from the <code>[start..=end]</code> \xe2\x80\xa600000000000EcGets a copy of <code>self</code> with the given <code>value</code> set into the \xe2\x80\xa600ChShow a simple message box, meant to be informative only.FbShuffle <code>f32</code> values in <code>a</code> using <code>i32</code> values in <code>v</code>.0FaShuffle <code>f32</code> lanes in <code>a</code> using <code>i32</code> values in <code>v</code>.0CaAdds elements within a vector from left to right.00CgMultiplies elements within a vector from left to right.00ClSets how much the track\xe2\x80\x99s output should be panned left \xe2\x80\xa6ChSplat the lowest 16-bit lane across the entire 128 bits.0ChSplat the lowest 32-bit lane across the entire 128 bits.0ChSplat the lowest 64-bit lane across the entire 128 bits.0Cn&lt; Time of last status change in microseconds since unix \xe2\x80\xa6DeLanewise saturating <code>a - b</code> with lanes as <code>i8</code>.000DeLanewise saturating <code>a - b</code> with lanes as <code>u8</code>.000CkAbsolute scale factor representing the nominal level of \xe2\x80\xa6BgSet a customized input channel mapping.ClConverts a character to its closest ASCII equivalent, or \xe2\x80\xa6CnCounts the number of trailing zero bits in a <code>u32</code>.0CnCounts the number of trailing zero bits in a <code>u64</code>.0FcTruncate the <code>f64</code> lanes to the lower <code>i32</code> lanes (upper <code>i32</code> \xe2\x80\xa60CaTruncate the lower lane into an <code>i32</code>.0CaTruncate the lower lane into an <code>i64</code>.0ClConstructs a new boxed slice with uninitialized contents \xe2\x80\xa6000DjPerforms a volatile load from the <code>src</code> pointer The pointer \xe2\x80\xa600CmConverts an address back to a mutable pointer, picking up \xe2\x80\xa6CjConverts an address back to a pointer, picking up some \xe2\x80\xa60CgConverts an address back to a pointer, picking up a \xe2\x80\xa60001000010000CmTrailer data, which doesn\xe2\x80\x99t contain actual content, but \xe2\x80\xa6CnThis is any, unlabelled data. It can either be a muxer not \xe2\x80\xa6Cn&lt; full parsing and repack of the first frame only, only \xe2\x80\xa6AiGet volume/mute messages.AgVolume control message.Ad&lt; Not part of ABIAl&lt; Use backslash escaping.CjReplayGain information in the form of the AVReplayGain \xe2\x80\xa6CfProvide encoder-specific hinting information about \xe2\x80\xa6CfThe mapped frame will be overwritten completely in \xe2\x80\xa6ClAccept to parse a value without a key; the key will then \xe2\x80\xa6CkAn AV_PKT_DATA_H263_MB_INFO side data packet contains a \xe2\x80\xa6ClAn AV_PKT_DATA_PARAM_CHANGE side data packet is laid out \xe2\x80\xa6CnRecommmends skipping the specified number of samples @code \xe2\x80\xa6CiViews are packed in a checkerboard-like structure per \xe2\x80\xa6BaAccurate seeking is not supportedfU+00090mADPCM IMA WAVAfMonkey\xe2\x80\x99s Audio (APE)AgPCM signed 8-bit planarAiPCM unsigned 8-bit planarCeAn error occurred when getting the default output \xe2\x80\xa6DdAn iterator that calls <code>EventPump::wait_event_timeout()</code>.fU+001C0000AmReference distance is &lt; 0.CnRepresents special flags that tell compatible terminals to \xe2\x80\xa6Dk<code>MediaSourceStreamOptions</code> specifies the buffering behaviour \xe2\x80\xa6Di<code>miniquad</code> Low-level interface for rendering operations in \xe2\x80\xa60CkIf the element size of a slice changes, then the output \xe2\x80\xa6CeZero-sized type used to mark a lifetime as covariant.00CeZero-sized type used to mark a lifetime as invariant.00DdRepresents Python\xe2\x80\x99s <code>ConnectionAbortedError</code> exception.DdRepresents Python\xe2\x80\x99s <code>ConnectionRefusedError</code> exception.DfRetrieve the fold component of a <code>PyDateTime_DateTime</code>. \xe2\x80\xa6DfRetrieve the hour component of a <code>PyDateTime_DateTime</code>. \xe2\x80\xa6DjRetrieve the fold component of a <code>PyDateTime_Time</code>. Returns \xe2\x80\xa6DjRetrieve the hour component of a <code>PyDateTime_Time</code>. Returns \xe2\x80\xa6CbThe decoder does not support random access seekingCfGet the number of converted/resampled bytes available.B`&lt; Game controller axis motionBc&lt; Game controller button pressedBo&lt; Game controller touchpad finger was liftedCnCopy an existing surface to a new surface of the specified \xe2\x80\xa6CdAllocate a new RGB surface with existing pixel data.BhGet the currently active OpenGL context.BoThe list of buttons available from a controllerBkQuery whether a game controller has an LED.BkStart a rumble effect on a game controller.BgUpdate a game controller\xe2\x80\x99s LED color.CjManually pump game controller updates if not using the \xe2\x80\xa6CjUse this function to get the current audio state of an \xe2\x80\xa6BoGet the index of the display containing a pointBmQuery whether relative mouse mode is enabled.CmGet the size of a window\xe2\x80\x99s borders (decorations) around \xe2\x80\xa6CmQuery the display mode to use when a window is visible at \xe2\x80\xa6CaGet the maximum size of a window\xe2\x80\x99s client area.CaGet the minimum size of a window\xe2\x80\x99s client area.C`Get the pixel format associated with the window.AkGet the YUV conversion modeCkCalculate the intersection of a rectangle and line segment.CcCheck whether the screensaver is currently enabled.CdGet the implementation dependent name of a joystick.CdGet the implementation dependent path of a joystick.DoLock a portion of the texture for <strong>write-only</strong> pixel access, \xe2\x80\xa6BdGet the current log output function.ClReplace the default log output function with one of your \xe2\x80\xa6AgIndividual button data.Bd&lt; The display is in portrait modeBl&lt; The renderer uses hardware accelerationCn&lt; The render targets have been reset and their contents \xe2\x80\xa6C`Get device independent resolution for rendering.CbSet a device independent resolution for rendering.BiClear the list of all assertion failures.Be&lt; windows contextual menu, composeBj&lt; Double arrow pointing north and southBh&lt; Double arrow pointing west and eastCeReturn the SDL_Sensor associated with an instance id.AhSet relative mouse mode.BmSet the window to always be above the others.CkSet the display mode to use when a window is visible at \xe2\x80\xa6CaSet the maximum size of a window\xe2\x80\x99s client area.CaSet the minimum size of a window\xe2\x80\x99s client area.AkSet the YUV conversion modeBcDisplay a simple modal message box.Ba&lt; Changes rarely, not lockableBk&lt; Texture can be used as a render targetAb&lt; No modulationBoCreate a Vulkan rendering surface for a window.CbUnload the Vulkan library previously loaded by \xe2\x80\xa6Cl&lt; Window had a hit test that wasn\xe2\x80\x99t SDL_HITTEST_NORMAL.Ci&lt; Window has been restored to normal size and positionD`&lt; window should be created in high-DPI mode if supported. \xe2\x80\xa6Bi&lt; window should always be above othersCk&lt; window has mouse captured (unrelated to MOUSE_GRABBED)Bc&lt; window has grabbed mouse inputAi&lt; BT.601 (the default)k&lt; BT.709AoFree an enumeration Linked ListCnThe |Sec-WebSocket-Extensions| header field is used in the \xe2\x80\xa6eLinuxCluse MXCSR.RC; see <code>vendor::_MM_SET_ROUNDING_MODE</code>00EhStructure representing a <code>datetime.datetime</code> without a <code>tzinfo</code>\xe2\x80\xa6CmPerforms the last round of an AES decryption flow on each \xe2\x80\xa600CmPerforms the last round of an AES encryption flow on each \xe2\x80\xa600ClBroadcast the low 8-bits from input mask k to all 64-bit \xe2\x80\xa600CmBroadcast the low 16-bits from input mask k to all 32-bit \xe2\x80\xa600CfPerforms a carry-less multiplication of two 64-bit \xe2\x80\xa600ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa600ClCompare packed 32-bit integers in a and b for not-equal, \xe2\x80\xa600ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa600CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa600CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa600CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa600CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa600ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa600DeExtracts 128 bits (composed of integer data) from <code>a</code>, \xe2\x80\xa600DiExtracts 128 bits (of integer data) from <code>a</code> selected with \xe2\x80\xa600ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa600CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa600111ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa600111222CnConcatenate a and b into a 64-byte immediate result, shift \xe2\x80\xa600000CnCompute the bitwise NOT of packed 32-bit integers in a and \xe2\x80\xa600CnCompute the bitwise NOT of packed 64-bit integers in a and \xe2\x80\xa600CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa600CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa600000000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000000000000000222222CkConvert packed double-precision (32-bit) floating-point \xe2\x80\xa600333===<<<CmLoad contiguous active 16-bit integers from a (those with \xe2\x80\xa600CmLoad contiguous active 32-bit integers from a (those with \xe2\x80\xa600CmLoad contiguous active 64-bit integers from a (those with \xe2\x80\xa600DcReturns values from <code>slice</code> at offsets determined by \xe2\x80\xa600000000000CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa600CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa600CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa600ChFor each packed 16-bit integer maps the value to the \xe2\x80\xa600ChFor each packed 32-bit integer maps the value to the \xe2\x80\xa600ChFor each packed 64-bit integer maps the value to the \xe2\x80\xa600CnShuffle 8-bit integers in a within 128-bit lanes using the \xe2\x80\xa600CiStore packed 16-bit integers from a into memory using \xe2\x80\xa600CiStore packed 32-bit integers from a into memory using \xe2\x80\xa600CiStore packed 64-bit integers from a into memory using \xe2\x80\xa600CiConcatenate pairs of 16-byte blocks in a and b into a \xe2\x80\xa600CkContiguously store the active double-precision (64-bit) \xe2\x80\xa600CkContiguously store the active single-precision (32-bit) \xe2\x80\xa600ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa600ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600000000ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600000000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa600CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa600000000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000000000000000222222222222ClLoad contiguous active 8-bit integers from a (those with \xe2\x80\xa600CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa600CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa600ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa600CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa600ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa600222111000CmCopy a to tmp, then insert 128 bits (composed of 4 packed \xe2\x80\xa600CmCopy a to tmp, then insert 128 bits (composed of 2 packed \xe2\x80\xa600111000CjLoad packed 16-bit integers from memory into dst using \xe2\x80\xa600CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa600CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa600CiCounts the number of leading zero bits in each packed \xe2\x80\xa600000CcDuplicate odd-indexed single-precision (32-bit) \xe2\x80\xa600CdDuplicate even-indexed single-precision (32-bit) \xe2\x80\xa600CjMultiply the packed signed 16-bit integers in a and b, \xe2\x80\xa600ClMultiply the packed unsigned 16-bit integers in a and b, \xe2\x80\xa600CmMultiply the packed 16-bit integers in a and b, producing \xe2\x80\xa600CmMultiply the packed 32-bit integers in a and b, producing \xe2\x80\xa600EcMultiply packed 64-bit integers in <code>a</code> and <code>b</code>, producing \xe2\x80\xa600CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa600CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa600CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa600CnFor each packed 8-bit integer maps the value to the number \xe2\x80\xa600CnConcatenate packed 16-bit integers in a and b producing an \xe2\x80\xa600CnConcatenate packed 32-bit integers in a and b producing an \xe2\x80\xa600CnConcatenate packed 64-bit integers in a and b producing an \xe2\x80\xa600222111000CnConcatenate packed 16-bit integers in b and a producing an \xe2\x80\xa600CnConcatenate packed 32-bit integers in b and a producing an \xe2\x80\xa600CnConcatenate packed 64-bit integers in b and a producing an \xe2\x80\xa600222111000CcUnpack and interleave double-precision (64-bit) \xe2\x80\xa600CcUnpack and interleave single-precision (32-bit) \xe2\x80\xa600111000EbPermutes 64-bit integers from <code>a</code> using control mask <code>imm8</code>.00DjShuffles eight 32-bit floating-point elements in <code>a</code> across \xe2\x80\xa600ClShuffle 8-bit integers in a and b across lanes using the \xe2\x80\xa600CgShuffle 16-bit integers in a across lanes using the \xe2\x80\xa600CgShuffle 32-bit integers in a across lanes using the \xe2\x80\xa600CgShuffle 64-bit integers in a across lanes using the \xe2\x80\xa600CjThis intrinsic performs two rounds of SHA512 operation \xe2\x80\xa600CnLoad 256-bits of integer data from memory into dst using a \xe2\x80\xa600CmPerforms the last round of an AES decryption flow on each \xe2\x80\xa600CmPerforms the last round of an AES encryption flow on each \xe2\x80\xa600ClBroadcast the low 8-bits from input mask k to all 64-bit \xe2\x80\xa600CmBroadcast the low 16-bits from input mask k to all 32-bit \xe2\x80\xa600CfPerforms a carry-less multiplication of two 64-bit \xe2\x80\xa600CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa600CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa600CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa600ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa600ClCompare packed 32-bit integers in a and b for not-equal, \xe2\x80\xa600ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa600CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa600CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa600CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa600ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa600ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600000ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600000000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000000CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa600000000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000000000000000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa600000000000CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa600CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa600ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa600CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa600ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa600222111000CkLoads 8 64-bit integer elements from memory starting at \xe2\x80\xa600111222111333222111CgAdd packed double-precision (64-bit) floating-point \xe2\x80\xa600CnAdd packed half-precision (16-bit) floating-point elements \xe2\x80\xa600CgAdd packed single-precision (32-bit) floating-point \xe2\x80\xa600CiConcatenate a and b into a 128-byte immediate result, \xe2\x80\xa600000CnCompute the bitwise NOT of packed 32-bit integers in a and \xe2\x80\xa600CnCompute the bitwise NOT of packed 64-bit integers in a and \xe2\x80\xa600<<<>>>>>>>>>>>>==================<<<<<<CkConvert packed double-precision (32-bit) floating-point \xe2\x80\xa600===CjDivide packed double-precision (64-bit) floating-point \xe2\x80\xa600ChDivide packed half-precision (16-bit) floating-point \xe2\x80\xa600CjDivide packed single-precision (32-bit) floating-point \xe2\x80\xa600CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa600ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa600CmLoad contiguous active 16-bit integers from a (those with \xe2\x80\xa600CmLoad contiguous active 32-bit integers from a (those with \xe2\x80\xa600CmLoad contiguous active 64-bit integers from a (those with \xe2\x80\xa600ClGather double-precision (64-bit) floating-point elements \xe2\x80\xa600ClGather single-precision (32-bit) floating-point elements \xe2\x80\xa600111000CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa600CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa600CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa600222111000ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa600CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa600ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa600CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa600CnMultiplies elements in packed 64-bit integer vectors a and \xe2\x80\xa600CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa600CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa600ChFor each packed 16-bit integer maps the value to the \xe2\x80\xa600ChFor each packed 32-bit integer maps the value to the \xe2\x80\xa600ChFor each packed 64-bit integer maps the value to the \xe2\x80\xa600CnShuffle 8-bit integers in a within 128-bit lanes using the \xe2\x80\xa600CiStore packed 16-bit integers from a into memory using \xe2\x80\xa600CiStore packed 32-bit integers from a into memory using \xe2\x80\xa600CiStore packed 64-bit integers from a into memory using \xe2\x80\xa600ClSubtract packed double-precision (64-bit) floating-point \xe2\x80\xa600CjSubtract packed half-precision (16-bit) floating-point \xe2\x80\xa600ClSubtract packed single-precision (32-bit) floating-point \xe2\x80\xa600CiConcatenate pairs of 16-byte blocks in a and b into a \xe2\x80\xa600CkContiguously store the active double-precision (64-bit) \xe2\x80\xa600CkContiguously store the active single-precision (32-bit) \xe2\x80\xa600ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa600ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600000000ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600000000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600000000CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa600CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa600000000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000000000000000222222222222ClLoad contiguous active 8-bit integers from a (those with \xe2\x80\xa600CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa600CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa600ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa600CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa600ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa600222111000CmCopy a to tmp, then insert 128 bits (composed of 4 packed \xe2\x80\xa600CmCopy a to tmp, then insert 256 bits (composed of 8 packed \xe2\x80\xa600CmCopy a to tmp, then insert 128 bits (composed of 2 packed \xe2\x80\xa600CmCopy a to tmp, then insert 256 bits (composed of 4 packed \xe2\x80\xa600333222111000CjLoad packed 16-bit integers from memory into dst using \xe2\x80\xa600CjLoad packed 32-bit integers from memory into dst using \xe2\x80\xa600CjLoad packed 64-bit integers from memory into dst using \xe2\x80\xa600CiCounts the number of leading zero bits in each packed \xe2\x80\xa600000CcDuplicate odd-indexed single-precision (32-bit) \xe2\x80\xa600CdDuplicate even-indexed single-precision (32-bit) \xe2\x80\xa600CjMultiply the packed signed 16-bit integers in a and b, \xe2\x80\xa600ClMultiply the packed unsigned 16-bit integers in a and b, \xe2\x80\xa600CmMultiply the packed 16-bit integers in a and b, producing \xe2\x80\xa600CmMultiply the packed 32-bit integers in a and b, producing \xe2\x80\xa600EcMultiply packed 64-bit integers in <code>a</code> and <code>b</code>, producing \xe2\x80\xa600CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa600CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa600CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa600CnFor each packed 8-bit integer maps the value to the number \xe2\x80\xa600CnConcatenate packed 16-bit integers in a and b producing an \xe2\x80\xa600CnConcatenate packed 32-bit integers in a and b producing an \xe2\x80\xa600CnConcatenate packed 64-bit integers in a and b producing an \xe2\x80\xa600222111000CnConcatenate packed 16-bit integers in b and a producing an \xe2\x80\xa600CnConcatenate packed 32-bit integers in b and a producing an \xe2\x80\xa600CnConcatenate packed 64-bit integers in b and a producing an \xe2\x80\xa600222111000CcUnpack and interleave double-precision (64-bit) \xe2\x80\xa600CcUnpack and interleave single-precision (32-bit) \xe2\x80\xa600111000ClShuffle 8-bit integers in a and b across lanes using the \xe2\x80\xa600CgShuffle 16-bit integers in a across lanes using the \xe2\x80\xa600CgShuffle 32-bit integers in a across lanes using the \xe2\x80\xa600CgShuffle 64-bit integers in a across lanes using the \xe2\x80\xa600CnLoad 512-bits of integer data from memory into dst using a \xe2\x80\xa600CmBroadcasts 128 bits of integer data from a to all 128-bit \xe2\x80\xa600C`Multiply the lower double-precision (64-bit) \xe2\x80\xa600CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa600C`Multiply the lower single-precision (32-bit) \xe2\x80\xa600222111000CkBroadcasts the lower 2 packed 32-bit integers from a to \xe2\x80\xa600ChBroadcast the low packed 8-bit integer from a to all \xe2\x80\xa600CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa600CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa600111000111000111000111000ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600CjMultiply the lower complex numbers in a by the complex \xe2\x80\xa600CmMultiply the lower complex numbers in a and b, accumulate \xe2\x80\xa600===<<<;;;===<<<;;;ChTest packed double-precision (64-bit) floating-point \xe2\x80\xa600CfTest packed half-precision (16-bit) floating-point \xe2\x80\xa600ChTest packed single-precision (32-bit) floating-point \xe2\x80\xa600CkTest the lower double-precision (64-bit) floating-point \xe2\x80\xa600CiTest the lower half-precision (16-bit) floating-point \xe2\x80\xa600CkTest the lower single-precision (32-bit) floating-point \xe2\x80\xa600CfConvert the exponent of the lower double-precision \xe2\x80\xa600CmConvert the exponent of the lower half-precision (16-bit) \xe2\x80\xa600CfConvert the exponent of the lower single-precision \xe2\x80\xa600DcReturns values from <code>slice</code> at offsets determined by \xe2\x80\xa600000000000CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa600CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa600CkReduce the packed 8-bit integers in a by addition using \xe2\x80\xa600CnReduce the packed 8-bit integers in a by bitwise AND using \xe2\x80\xa600CjReduce the packed 8-bit integers in a by maximum using \xe2\x80\xa600CmReduce the packed unsigned 8-bit integers in a by maximum \xe2\x80\xa600CjReduce the packed 8-bit integers in a by minimum using \xe2\x80\xa600CmReduce the packed unsigned 8-bit integers in a by minimum \xe2\x80\xa600CkReduce the packed 8-bit integers in a by multiplication \xe2\x80\xa600CnReduce the packed 16-bit integers in a by bitwise OR using \xe2\x80\xa600CnExtract the reduced argument of the lower double-precision \xe2\x80\xa600ClExtract the reduced argument of the lower half-precision \xe2\x80\xa600CnExtract the reduced argument of the lower single-precision \xe2\x80\xa600CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa600CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa600000CjShuffle 16-bit integers in the high 64 bits of 128-bit \xe2\x80\xa600CiShuffle 16-bit integers in the low 64 bits of 128-bit \xe2\x80\xa600CnCompute the bitwise AND of packed 16-bit integers in a and \xe2\x80\xa600CnCompute the bitwise AND of packed 32-bit integers in a and \xe2\x80\xa600CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa600CnCompute the bitwise NAND of packed 8-bit integers in a and \xe2\x80\xa600CnBroadcast the low single-precision (32-bit) floating-point \xe2\x80\xa600CjMultiply the lower complex numbers in a by the complex \xe2\x80\xa600CmContiguously store the active 16-bit integers in a (those \xe2\x80\xa600CmContiguously store the active 32-bit integers in a (those \xe2\x80\xa600CmContiguously store the active 64-bit integers in a (those \xe2\x80\xa600CmTest each 32-bit element of a for equality with all other \xe2\x80\xa600CmTest each 64-bit element of a for equality with all other \xe2\x80\xa600CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa600CnConvert the lower double-precision (64-bit) floating-point \xe2\x80\xa600000ClConvert the lower half-precision (16-bit) floating-point \xe2\x80\xa600000CnConvert the lower single-precision (32-bit) floating-point \xe2\x80\xa600000ClSign extend packed 16-bit integers in a to packed 32-bit \xe2\x80\xa600ClSign extend packed 16-bit integers in a to packed 64-bit \xe2\x80\xa600ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa600ClSign extend packed 32-bit integers in a to packed 64-bit \xe2\x80\xa600ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa600ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa600CnZero extend packed unsigned 16-bit integers in a to packed \xe2\x80\xa600ClZero extend packed unsigned 16-bit integers in the low 4 \xe2\x80\xa600CnZero extend packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa600CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa600CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa600CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa600CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa600C`Multiply the lower double-precision (64-bit) \xe2\x80\xa600CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa600C`Multiply the lower single-precision (32-bit) \xe2\x80\xa600222111000ClMultiply the lower complex numbers in a and b, and store \xe2\x80\xa600CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa600000CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa600000ClUnpack and interleave 16-bit integers from the high half \xe2\x80\xa600ClUnpack and interleave 32-bit integers from the high half \xe2\x80\xa600ClUnpack and interleave 64-bit integers from the high half \xe2\x80\xa600CnUnpack and interleave 16-bit integers from the low half of \xe2\x80\xa600CnUnpack and interleave 32-bit integers from the low half of \xe2\x80\xa600CnUnpack and interleave 64-bit integers from the low half of \xe2\x80\xa600EgAdd horizontal pairs of <code>i16</code> values, pack the outputs as <code>a</code> \xe2\x80\xa60CmHorizontal <code>a + b</code> with lanes as <code>i16</code>.0EgAdd horizontal pairs of <code>i32</code> values, pack the outputs as <code>a</code> \xe2\x80\xa60CmHorizontal <code>a + b</code> with lanes as <code>i32</code>.0DfLanewise saturating <code>a + b</code> with lanes as <code>i16</code>.000DfLanewise saturating <code>a + b</code> with lanes as <code>u16</code>.000BfAssist in expanding an AES cipher key.0EhAllocates a new slice of size <code>len</code> slice into this <code>Bump</code> and \xe2\x80\xa6CgView this buffer but keep mutability at a sample level.CkAn atomic fence for synchronization within a single thread.00DkEquivalent to  <code>Self::auth_encap()</code>, but with a one-time use \xe2\x80\xa6CnAppend path component to the existing path. Path separator \xe2\x80\xa6ChAppend a description of a channel layout to a bprint \xe2\x80\xa6BaAdd a frame to the buffer source.ClFind out what channels from a given set are present in a \xe2\x80\xa6CkFree any allocated data in the channel layout and reset \xe2\x80\xa6Cl@return the AVColorRange value for name or an AVError if \xe2\x80\xa6Cl@return the AVColorSpace value for name or an AVError if \xe2\x80\xa6Ck@param disposition a combination of AV_DISPOSITION_* valuesCkReturn a string describing the media_type enum, NULL if \xe2\x80\xa6CkGet the packed alternative form of the given sample format.CmReturn a single letter to describe the given picture type \xe2\x80\xa6CkGet the planar alternative form of the given sample format.CmGenerate a string corresponding to the sample format with \xe2\x80\xa6CnCopy data to or from a hw surface. At least one of dst/src \xe2\x80\xa6CnReturn the size in bytes of the amount of data required to \xe2\x80\xa6CbCheck if given option is set to its default value.CnConvenience function to free all the side data stored. All \xe2\x80\xa6ClConvenience function to free all the side data stored in \xe2\x80\xa6CnModify width and height values so that they will result in \xe2\x80\xa6CiDecode a subtitle message. Return a negative value on \xe2\x80\xa6BnFill AVFrame audio data and linesize pointers.CjAllocate a new AVCodecParameters and set its fields to \xe2\x80\xa6BmAdd a graph described by a string to a graph.CeMake the filter instance process a command. It is \xe2\x80\xa6CfGet the AVIndexEntry corresponding to the given index.DjFilter using <code>BinarizeUsingThreshold</code>: D = (S &gt;= T) ? 255:0.D`Finds the index of the first 1 in <code>bits</code> from the \xe2\x80\xa60CoFinds the index of the last 0 in <code>bits</code> from the \xe2\x80\xa60BcResets (clears) the lowest set bit.000CkGets the value of the lowest set bit in a <code>u32</code>.DdGets the <em>value</em> of the lowest set bit in a <code>u32</code>.CkGets the value of the lowest set bit in a <code>u64</code>.DdGets the <em>value</em> of the lowest set bit in a <code>u64</code>.ClThis helper function is used to \xe2\x80\x9cconnect\xe2\x80\x9d a producer \xe2\x80\xa6DaBit-preserving cast to <code>m128d</code> from <code>m128i</code>0DbBit-preserving cast to <code>m128d</code> from <code>m256d</code>.0DaBit-preserving cast to <code>m128i</code> from <code>m128d</code>0DbBit-preserving cast to <code>m128i</code> from <code>m256i</code>.0DbBit-preserving cast to <code>m256d</code> from <code>m256i</code>.0DbBit-preserving cast to <code>m256i</code> from <code>m256d</code>.0DbCasts <code>self</code> to <code>isize_up</code> with range check.0DeCasts from <code>i8</code> to <code>isize_up</code> with range check.DgCasts from <code>u128</code> to <code>isize_up</code> with range check.DfCasts from <code>i16</code> to <code>isize_up</code> with range check.DfCasts from <code>u16</code> to <code>isize_up</code> with range check.DhCasts from <code>isize</code> to <code>isize_up</code> with range check.DfCasts from <code>i64</code> to <code>isize_up</code> with range check.DhCasts from <code>usize</code> to <code>isize_up</code> with range check.DfCasts from <code>i32</code> to <code>isize_up</code> with range check.DeCasts from <code>u8</code> to <code>isize_up</code> with range check.DfCasts from <code>u32</code> to <code>isize_up</code> with range check.DgCasts from <code>i128</code> to <code>isize_up</code> with range check.DfCasts from <code>u64</code> to <code>isize_up</code> with range check.DbCasts <code>self</code> to <code>usize_up</code> with range check.0DfCasts from <code>u64</code> to <code>usize_up</code> with range check.DhCasts from <code>usize</code> to <code>usize_up</code> with range check.DgCasts from <code>u128</code> to <code>usize_up</code> with range check.DfCasts from <code>u32</code> to <code>usize_up</code> with range check.DeCasts from <code>u8</code> to <code>usize_up</code> with range check.DfCasts from <code>i16</code> to <code>usize_up</code> with range check.DfCasts from <code>i32</code> to <code>usize_up</code> with range check.DgCasts from <code>i128</code> to <code>usize_up</code> with range check.DhCasts from <code>isize</code> to <code>usize_up</code> with range check.DeCasts from <code>i8</code> to <code>usize_up</code> with range check.DfCasts from <code>i64</code> to <code>usize_up</code> with range check.DfCasts from <code>u16</code> to <code>usize_up</code> with range check.DkLow lane <code>(!a.is_nan()) &amp;amp; (!b.is_nan())</code>, other lane \xe2\x80\xa6DgLow lane <code>(!a.is_nan()) &amp; (!b.is_nan())</code>, other lane \xe2\x80\xa6CnReturns true if the table contains an array of tables with \xe2\x80\xa6FjCopies <code>count * size_of::&lt;T&gt;()</code> bytes from <code>src</code> to <code>self</code>. The \xe2\x80\xa6EdCounts the number of 1s in <code>self</code> from the <code>[start..=end]</code> \xe2\x80\xa600000000000AaShorthand for \xe2\x80\xa6DkHint that the <code>Deserialize</code> type is expecting a tuple struct \xe2\x80\xa60CgCasts the PyObject to a concrete Python object type \xe2\x80\xa6BoData TLB associativity for 2-MB and 4-MB pages.CbL2 Data TLB associativity for 2-MB and 4-MB pages.BjDuplicate the odd lanes to the even lanes.0CbDuplicate the odd-indexed lanes to the even lanes.0Cd(addEventListener) Attaches a Rust function as a \xe2\x80\xa6Dj(removeEventListener) Removes a JavaScript function <code>event</code> \xe2\x80\xa6EiGets an <code>i16</code> value out of an <code>m128i</code>, returns as <code>i32</code>.0EiGets an <code>i16</code> value out of an <code>m256i</code>, returns as <code>i32</code>.0CfExtracts an <code>m128d</code> from <code>m256d</code>0CfExtracts an <code>m128i</code> from <code>m256i</code>0CkReturns the name of the current font face without doing \xe2\x80\xa6CjWrites the prime factors in the given <code>buffer</code>.0CcReturns the unique prime factors with its exponent.0BdFlip an image horizontally in place.DoConstructs a new <code>Bound&lt;&#39;py, PyAny&gt;</code> from a pointer by \xe2\x80\xa6DoCreate a <code>Py&lt;T&gt;</code> instance by creating a new reference from \xe2\x80\xa610Bg<em>const</em> method equivalent to \xe2\x80\xa60000CeConvert from a duration, clamped between 0 and an \xe2\x80\xa6CjLow lane <code>-(a * b) + c</code>, other lanes unchanged.0D`Low lane fused <code>-(a * b) - c</code>, other lanes unchanged.0CjThe value at the bit range of <code>Variant0</code> field.CjThe value at the bit range of <code>Variant1</code> field.CjThe value at the bit range of <code>Variant2</code> field.CjThe value at the bit range of <code>Variant3</code> field.CjThe value at the bit range of <code>Variant4</code> field.CkCalculates the 1D array index from the given 2D coordinates0CjIntel Processor Trace Enumeration Information (LEAF=0x14).BgGet the currently active OpenGL window.CkComputes the Hamming edit distance between two strings, \xe2\x80\xa6Ae3DNow AMD extensions.BiDeprecates FPU CS and FPU DS values if 1.CnFast access mode for the IA32_HWP_REQUEST MSR is supported \xe2\x80\xa6AnSupports occupancy monitoring.CaProcessor performance counter extensions support.BfRestricted Injection supported if set.CfIf true, ToPA tables can hold any number of output \xe2\x80\xa6BaReturns the unique prime factors.00BhCalls `NumInt::int_ref_digits_base_sign.00CdSimilar to int_digits_base_sign, but operates on \xe2\x80\xa600BhCalls `NumInt::int_ref_div_ties_towards.00CdSimilar to int_div_ties_towards, but operates on \xe2\x80\xa600CmReturns the interpolated orientation between the previous \xe2\x80\xa6BoChecks if <code>mips</code> feature is enabled.EcReturns <code>true</code> if <code>self</code> has a negative sign and is not zero.00EcReturns <code>true</code> if <code>self</code> has a positive sign and is not zero.00CcWrite-Back Invalidate/Invalidate (Bit 0) False: \xe2\x80\xa6CfInstruction TLB associativity for 2-MB and 4-MB pages.CiL2 Instruction TLB associativity for 2-MB and 4-MB pages.CnReturn the elements producing the k largest outputs of the \xe2\x80\xa6000CbIf we should error when max redirects are reached.0BeMax size of the HTTP response header.0CkCalculates the modular additive inverse, unchecked version.0ClCalculates the modular multiplicative inverse, unchecked \xe2\x80\xa60BgUnsets the <code>Variant0</code> field.BgUnsets the <code>Variant1</code> field.BgUnsets the <code>Variant2</code> field.BgUnsets the <code>Variant3</code> field.BgUnsets the <code>Variant4</code> field.CkHPKE Base mode sender with a supplied ephemeral private \xe2\x80\xa6CjHPKE Psk mode sender with a supplied ephemeral private \xe2\x80\xa6CkHPKE Auth mode sender with a supplied ephemeral private \xe2\x80\xa6CnHPKE AuthPsk mode sender with a supplied ephemeral private \xe2\x80\xa6CnThis is a panic called with a message that\xe2\x80\x99s a result of \xe2\x80\xa6000000000000000CjReturns a parallel iterator over the mutable pixels of \xe2\x80\xa6CeSorts the slice in parallel with a key extraction \xe2\x80\xa60BePhysical Line partitions (Bits 21-12)BbProcessor Base Frequency (in MHz).E`See documentation of <code>&lt;*const T&gt;::offset_from_unsigned</code> for \xe2\x80\xa600CmAppends an element and returns a reference to it if there \xe2\x80\xa6CkRatecontrol attempt to use, at maximum,  of what can be \xe2\x80\xa6CkReads the CPU\xe2\x80\x99s timestamp counter value and store the \xe2\x80\xa60CjReturns the recommended line spacing for text rendered \xe2\x80\xa6BmRefreshes system memory specific information.DkRegisters all the formats selected by the <code>feature</code> flags in \xe2\x80\xa6DmCasts <code>self</code> to <code>isize</code> clamping at the numeric bounds.0EaCasts from <code>i16</code> to <code>isize</code> clamping at the numeric bounds.E`Casts from <code>i8</code> to <code>isize</code> clamping at the numeric bounds.EaCasts from <code>u64</code> to <code>isize</code> clamping at the numeric bounds.EcCasts from <code>usize</code> to <code>isize</code> clamping at the numeric bounds.EaCasts from <code>u16</code> to <code>isize</code> clamping at the numeric bounds.EaCasts from <code>i64</code> to <code>isize</code> clamping at the numeric bounds.EbCasts from <code>i128</code> to <code>isize</code> clamping at the numeric bounds.EaCasts from <code>i32</code> to <code>isize</code> clamping at the numeric bounds.E`Casts from <code>u8</code> to <code>isize</code> clamping at the numeric bounds.EaCasts from <code>u32</code> to <code>isize</code> clamping at the numeric bounds.EcCasts from <code>isize</code> to <code>isize</code> clamping at the numeric bounds.EbCasts from <code>u128</code> to <code>isize</code> clamping at the numeric bounds.DmCasts <code>self</code> to <code>usize</code> clamping at the numeric bounds.0EaCasts from <code>u64</code> to <code>usize</code> clamping at the numeric bounds.EbCasts from <code>u128</code> to <code>usize</code> clamping at the numeric bounds.EaCasts from <code>u16</code> to <code>usize</code> clamping at the numeric bounds.EcCasts from <code>usize</code> to <code>usize</code> clamping at the numeric bounds.EaCasts from <code>i16</code> to <code>usize</code> clamping at the numeric bounds.EbCasts from <code>i128</code> to <code>usize</code> clamping at the numeric bounds.E`Casts from <code>i8</code> to <code>usize</code> clamping at the numeric bounds.EaCasts from <code>i64</code> to <code>usize</code> clamping at the numeric bounds.EaCasts from <code>i32</code> to <code>usize</code> clamping at the numeric bounds.E`Casts from <code>u8</code> to <code>usize</code> clamping at the numeric bounds.EaCasts from <code>u32</code> to <code>usize</code> clamping at the numeric bounds.EcCasts from <code>isize</code> to <code>usize</code> clamping at the numeric bounds.ClWrites values from a SIMD vector to multiple potentially \xe2\x80\xa6DdSerialize a newtype struct like <code>struct Millimeters(u8)</code>.0DaBegin to serialize a struct variant like <code>E::S</code> in \xe2\x80\xa60DmSets the <code>value</code> into the bitrange of <code>Variant0</code> field.DmSets the <code>value</code> into the bitrange of <code>Variant1</code> field.DmSets the <code>value</code> into the bitrange of <code>Variant2</code> field.DmSets the <code>value</code> into the bitrange of <code>Variant3</code> field.DmSets the <code>value</code> into the bitrange of <code>Variant4</code> field.CfSet the permissions of a file, unless it is a symlink.CgSet <code>m128d</code> args into an <code>m256d</code>.0CgSet <code>m128i</code> args into an <code>m256i</code>.0FaShuffle the <code>f32</code> lanes from <code>$a</code> and <code>$b</code> together using an \xe2\x80\xa60EdShuffle the <code>i32</code> lanes in <code>$a</code> using an immediate control \xe2\x80\xa60EfShuffle the <code>f64</code> lanes from <code>$a</code> using an immediate control \xe2\x80\xa60EdShuffle the <code>f64</code> lanes in <code>$a</code> using an immediate control \xe2\x80\xa60FbShuffle <code>f32</code> values in <code>a</code> using <code>i32</code> values in <code>v</code>.0FlShuffle <code>f64</code> lanes in <code>a</code> using bit 1 of the <code>i64</code> lanes in <code>v</code>GmShuffle <code>f64</code> lanes in <code>a</code> using <strong>bit 1</strong> of the <code>i64</code> lanes in <code>v</code>FaShuffle <code>i32</code> lanes in <code>a</code> using <code>i32</code> values in <code>v</code>.0EoShuffle <code>i8</code> lanes in <code>a</code> using <code>i8</code> values in <code>v</code>.0CmSign extends an arbitrary, 16-bit or less, signed two\xe2\x80\x99s \xe2\x80\xa6CmSign extends an arbitrary, 32-bit or less, signed two\xe2\x80\x99s \xe2\x80\xa6CmSign extends an arbitrary, 64-bit or less, signed two\xe2\x80\x99s \xe2\x80\xa6CjForms a mutable raw slice from a mutable pointer and a \xe2\x80\xa6CfForms a raw mutable slice from a pointer and a length.00DfReturns an iterator over substrings of <code>self</code>, split on \xe2\x80\xa6DjSubtract horizontal pairs of <code>i16</code> values, pack the outputs \xe2\x80\xa60CmHorizontal <code>a - b</code> with lanes as <code>i16</code>.0DjSubtract horizontal pairs of <code>i32</code> values, pack the outputs \xe2\x80\xa60CmHorizontal <code>a - b</code> with lanes as <code>i32</code>.0DfLanewise saturating <code>a - b</code> with lanes as <code>i16</code>.000DfLanewise saturating <code>a - b</code> with lanes as <code>u16</code>.000CjCompute \xe2\x80\x9csum of <code>u8</code> absolute differences\xe2\x80\x9d.000BhReturn the swr build-time configuration.Ch@return A negative error code on error, non negative \xe2\x80\xa6Ce@param c the scaling context @param dstRange flag \xe2\x80\xa6CgMetal-specific note: if texture was created without \xe2\x80\xa6000BlReturns the total number of incoming errors.DjPerforms a volatile store to the <code>dst</code> pointer. The pointer \xe2\x80\xa600ClGenerates a default substitution matrix for use with the \xe2\x80\xa6DfCreates an empty <code>HashMap</code> with the specified capacity, \xe2\x80\xa6DhCreates an empty <code>HashSet</code> with the specified capacity, usingDeCreates an empty <code>HashMap</code> with at least the specified \xe2\x80\xa6DeCreates an empty <code>HashSet</code> with at least the specified \xe2\x80\xa6CmReturns the total number of times the given worker thread \xe2\x80\xa6CkWrites the supplied buffer to a writer in the specified \xe2\x80\xa6AoSupport for legacy x87 in XCR0.AoSupport for MPX BNDCSR in XCR0.Bf&lt; all automatic conversions enabledD`&lt; full parsing and interpolation of timestamps for frames \xe2\x80\xa6AfMute control messages.AkWindow size change message.jSee above.CnThe data contains an ICC profile as an opaque octet buffer \xe2\x80\xa6Ck&lt; bayer, BGBG..(odd line), GRGR..(even line), 16-bit \xe2\x80\xa60Ck&lt; bayer, GBGB..(odd line), RGRG..(even line), 16-bit \xe2\x80\xa60Ck&lt; bayer, GRGR..(odd line), BGBG..(even line), 16-bit \xe2\x80\xa60Ck&lt; bayer, RGRG..(odd line), GBGB..(even line), 16-bit \xe2\x80\xa60CgThis side data contains a 3x3 transformation matrix \xe2\x80\xa6CmThe AV_PKT_DATA_NEW_EXTRADATA is used to notify the codec \xe2\x80\xa6ClThis side data contains quality related information from \xe2\x80\xa6CnTimecode which conforms to SMPTE ST 12-1:2014. The data is \xe2\x80\xa6B`Views are alternated temporally.DkA deserializer holding a <code>&amp;[u8]</code> with a lifetime tied to \xe2\x80\xa6BeIterator over all connected gamepads.Cmmaximum number of services provided on the same listening \xe2\x80\xa6CmRepresent Escape and modified keys using CSI-u sequences, \xe2\x80\xa6fU+001D0000CkInfo about performance monitoring \xe2\x80\x93 how many counters \xe2\x80\xa6CoRetrieve the days component of a <code>PyDateTime_Delta</code>.Ak&lt; dstA, dstA, dstA, dstAAk&lt; dstR, dstG, dstB, dstAAk&lt; srcA, srcA, srcA, srcAAk&lt; srcR, srcG, srcB, srcACl&lt; A new Game controller has been inserted into the systemCa\\brief Game controller button event structure \xe2\x80\xa6Cj\\brief Controller device event structure (event.cdevice.*)Ca\\brief Game controller sensor event structure \xe2\x80\xa6Bd&lt; GLX_CONTEXT_ES2_PROFILE_BIT_EXTCmCheck if an OpenGL extension is supported for the current \xe2\x80\xa6CfGet the current state of an axis control on a game \xe2\x80\xa6C`Get the type of this currently opened controllerCaQuery whether a game controller has a given axis.BmGet the current mapping of a Game Controller.CdGet the closest match to the requested display mode.BiGet the name of the current audio driver.BoGet information about the current display mode.CgGet the name of the currently initialized video driver.CcGet information about the desktop\xe2\x80\x99s display mode.BaGet the orientation of a display.CeGet the current value of the high resolution counter.BiRetrieve the relative state of the mouse.CeGet the output size in pixels of a rendering context.CfGet the index of the display associated with a window.BdGet a window\xe2\x80\x99s keyboard grab mode.BcGet the size of a window in pixels.CjCheck to see if an effect is supported by a haptic device.CiGet the status of the current effect on the specified \xe2\x80\xa6CeCheck whether rumble is supported on a haptic device.CnCalculate the intersection of a rectangle and line segment \xe2\x80\xa6ChCheck whether the screen keyboard is shown for given \xe2\x80\xa6AnAttach a new virtual joystick.AjDetach a virtual joystick.CmGet the implementation-dependent GUID for the joystick at \xe2\x80\xa6BiGet the type of a joystick, if available.CbGet an ASCII string representation for a given \xe2\x80\xa6CbSet values on an opened, virtual-joystick\xe2\x80\x99s hat.BcFlags for SDL_MessageBoxButtonData.BnA set of colors to use for message box dialogsCnGet the size of a window\xe2\x80\x99s underlying drawable in pixels \xe2\x80\xa6Cn&lt; The display is in landscape mode, with the right side \xe2\x80\xa6Be&lt; Plugged in, no battery availableBk&lt; Not plugged in, running on the batteryCb&lt; Present is synchronized with the refresh rateBmGet whether integer scales are forced for \xe2\x80\xa6CnGet real coordinates of point in window when given logical \xe2\x80\xa6BkSet whether to force integer scales for \xe2\x80\xa6CkDetermine whether a renderer supports the use of render \xe2\x80\xa6CkGet logical coordinates of point in renderer when given \xe2\x80\xa6Aa&lt; AC BookmarksBk&lt; num lock on PC, clear on Mac keyboardsCm&lt; Four pointed arrow pointing north, south, east, and westBmSet the palette for a pixel format structure.BdSet a window\xe2\x80\x99s keyboard grab mode.Ah&lt; srcA = srcA * alphaAh&lt; srcC = srcC * colorAn&lt; Window has been maximizedAn&lt; Window has been minimizedCiTells the client to communicate with HTTPS instead of \xe2\x80\xa6CjSends a signal to the server expressing the client\xe2\x80\x99s \xe2\x80\xa6A`round to nearest00CkExtract 128 bits (composed of 4 packed 32-bit integers) \xe2\x80\xa600ClExtracts 128 bits (composed of 2 packed 64-bit integers) \xe2\x80\xa600CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa600000ClCompare packed signed 8-bit integers in a and b based on \xe2\x80\xa600CnCompare packed unsigned 8-bit integers in a and b based on \xe2\x80\xa600ClContiguously store the active 8-bit integers in a (those \xe2\x80\xa600CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa600CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa600CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa600CkSign extend packed 8-bit integers in a to packed 16-bit \xe2\x80\xa600CkSign extend packed 8-bit integers in a to packed 32-bit \xe2\x80\xa600CmSign extend packed 8-bit integers in the low 4 bytes of a \xe2\x80\xa600CmZero extend packed unsigned 8-bit integers in a to packed \xe2\x80\xa600CkZero extend packed unsigned 8-bit integers in the low 8 \xe2\x80\xa600CkZero extend packed unsigned 8-bit integers in the low 4 \xe2\x80\xa600CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa600ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa600CmPerforms a multiplication in GF(2^8) on the packed bytes. \xe2\x80\xa600CnStores 4 double-precision (64-bit) floating-point elements \xe2\x80\xa600CnStores 8 single-precision (32-bit) floating-point elements \xe2\x80\xa600111CnStores 4 single-precision (32-bit) floating-point elements \xe2\x80\xa600CjMultiply packed unsigned 8-bit integers in a by packed \xe2\x80\xa600CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa600CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa600CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa600CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa600CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa600CkShuffle 32-bit integers in a within 128-bit lanes using \xe2\x80\xa600CmShuffle 128-bits (composed of 4 single-precision (32-bit) \xe2\x80\xa600CmShuffle 128-bits (composed of 2 double-precision (64-bit) \xe2\x80\xa600CmShuffle 128-bits (composed of 4 32-bit integers) selected \xe2\x80\xa600CmShuffle 128-bits (composed of 2 64-bit integers) selected \xe2\x80\xa600CnUnpack and interleave 8-bit integers from the high half of \xe2\x80\xa600CmUnpack and interleave 8-bit integers from the low half of \xe2\x80\xa600CnConcatenate a and b into a 64-byte immediate result, shift \xe2\x80\xa600000CnCompute the bitwise NOT of packed 32-bit integers in a and \xe2\x80\xa600CnCompute the bitwise NOT of packed 64-bit integers in a and \xe2\x80\xa600CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa600CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa600000000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000000000000000222222CkConvert packed double-precision (32-bit) floating-point \xe2\x80\xa600333CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa600ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa600CmLoad contiguous active 16-bit integers from a (those with \xe2\x80\xa600CmLoad contiguous active 32-bit integers from a (those with \xe2\x80\xa600CmLoad contiguous active 64-bit integers from a (those with \xe2\x80\xa600CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa600CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa600CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa600ChFor each packed 16-bit integer maps the value to the \xe2\x80\xa600ChFor each packed 32-bit integer maps the value to the \xe2\x80\xa600ChFor each packed 64-bit integer maps the value to the \xe2\x80\xa600CkShuffle packed 8-bit integers in a according to shuffle \xe2\x80\xa600CmLoads 4 double-precision (64-bit) floating-point elements \xe2\x80\xa600CmLoads 8 single-precision (32-bit) floating-point elements \xe2\x80\xa600111CmLoads 4 single-precision (32-bit) floating-point elements \xe2\x80\xa600ClShuffles 128-bits (composed of integer data) selected by \xe2\x80\xa600EgShuffles 128-bits of integer data selected by <code>imm8</code> from <code>a</code> \xe2\x80\xa600CmShuffle 16-bit integers in a and b across lanes using the \xe2\x80\xa600CmShuffle 32-bit integers in a and b across lanes using the \xe2\x80\xa600CmShuffle 64-bit integers in a and b across lanes using the \xe2\x80\xa600CiBitwise ternary logic that provides the capability to \xe2\x80\xa600000CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa600000000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000000000000000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa600000000000CkExtract 128 bits (composed of 4 packed 32-bit integers) \xe2\x80\xa600ClExtracts 256 bits (composed of 8 packed 32-bit integers) \xe2\x80\xa600ClExtracts 128 bits (composed of 2 packed 64-bit integers) \xe2\x80\xa600CkExtract 256 bits (composed of 4 packed 64-bit integers) \xe2\x80\xa600CnStores 8 64-bit integer elements from a to memory starting \xe2\x80\xa600ClCompare packed signed 8-bit integers in a and b based on \xe2\x80\xa600CnCompare packed unsigned 8-bit integers in a and b based on \xe2\x80\xa600CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa600CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa600111000111000ClContiguously store the active 8-bit integers in a (those \xe2\x80\xa600CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa600CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa600ClPerforms element-by-element conversion of the lower half \xe2\x80\xa600CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa600CkSign extend packed 8-bit integers in a to packed 16-bit \xe2\x80\xa600CkSign extend packed 8-bit integers in a to packed 32-bit \xe2\x80\xa600CmSign extend packed 8-bit integers in the low 8 bytes of a \xe2\x80\xa600444CmZero extend packed unsigned 8-bit integers in a to packed \xe2\x80\xa600000CkZero extend packed unsigned 8-bit integers in the low 8 \xe2\x80\xa600CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa600ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa600CmPerforms a multiplication in GF(2^8) on the packed bytes. \xe2\x80\xa600CmScatter double-precision (64-bit) floating-point elements \xe2\x80\xa600CmScatter single-precision (32-bit) floating-point elements \xe2\x80\xa600111000CjMultiply packed unsigned 8-bit integers in a by packed \xe2\x80\xa600CmMultiply the packed complex numbers in a and b, and store \xe2\x80\xa600CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa600CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa600CnReduce the packed double-precision (64-bit) floating-point \xe2\x80\xa600CnReduce the packed single-precision (32-bit) floating-point \xe2\x80\xa600111000111000111000CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa600CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa600CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa600CkShuffle 32-bit integers in a within 128-bit lanes using \xe2\x80\xa600CmShuffle 128-bits (composed of 4 single-precision (32-bit) \xe2\x80\xa600CmShuffle 128-bits (composed of 2 double-precision (64-bit) \xe2\x80\xa600CmShuffle 128-bits (composed of 4 32-bit integers) selected \xe2\x80\xa600CmShuffle 128-bits (composed of 2 64-bit integers) selected \xe2\x80\xa600CfCompute the square root of packed double-precision \xe2\x80\xa600CmCompute the square root of packed half-precision (16-bit) \xe2\x80\xa600CfCompute the square root of packed single-precision \xe2\x80\xa600CnUnpack and interleave 8-bit integers from the high half of \xe2\x80\xa600CmUnpack and interleave 8-bit integers from the low half of \xe2\x80\xa600CgAdd packed double-precision (64-bit) floating-point \xe2\x80\xa600CnAdd packed half-precision (16-bit) floating-point elements \xe2\x80\xa600CgAdd packed single-precision (32-bit) floating-point \xe2\x80\xa600CiConcatenate a and b into a 128-byte immediate result, \xe2\x80\xa600000CnCompute the bitwise NOT of packed 32-bit integers in a and \xe2\x80\xa600CnCompute the bitwise NOT of packed 64-bit integers in a and \xe2\x80\xa600CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa600CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa600000000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000000000000000222222CkConvert packed double-precision (32-bit) floating-point \xe2\x80\xa600333CjDivide packed double-precision (64-bit) floating-point \xe2\x80\xa600ChDivide packed half-precision (16-bit) floating-point \xe2\x80\xa600CjDivide packed single-precision (32-bit) floating-point \xe2\x80\xa600CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa600ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa600CmLoad contiguous active 16-bit integers from a (those with \xe2\x80\xa600CmLoad contiguous active 32-bit integers from a (those with \xe2\x80\xa600CmLoad contiguous active 64-bit integers from a (those with \xe2\x80\xa600CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa600CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa600CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa600222111000ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa600CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa600111CfMultiply packed signed 16-bit integers in a and b, \xe2\x80\xa600CiConvert packed signed 16-bit integers from a and b to \xe2\x80\xa600CiConvert packed signed 32-bit integers from a and b to \xe2\x80\xa600ChFor each packed 16-bit integer maps the value to the \xe2\x80\xa600ChFor each packed 32-bit integer maps the value to the \xe2\x80\xa600ChFor each packed 64-bit integer maps the value to the \xe2\x80\xa600CkShuffle packed 8-bit integers in a according to shuffle \xe2\x80\xa600ClSubtract packed double-precision (64-bit) floating-point \xe2\x80\xa600CjSubtract packed half-precision (16-bit) floating-point \xe2\x80\xa600ClSubtract packed single-precision (32-bit) floating-point \xe2\x80\xa600CmShuffle 16-bit integers in a and b across lanes using the \xe2\x80\xa600CmShuffle 32-bit integers in a and b across lanes using the \xe2\x80\xa600CmShuffle 64-bit integers in a and b across lanes using the \xe2\x80\xa600CiBitwise ternary logic that provides the capability to \xe2\x80\xa600000BgAssist in expanding the AES cipher key.00EfConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as \xe2\x80\xa600CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa600CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa600CmMultiply the lower complex numbers in a and b, accumulate \xe2\x80\xa600C`Multiply the lower double-precision (64-bit) \xe2\x80\xa600CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa600C`Multiply the lower single-precision (32-bit) \xe2\x80\xa600222111000CiBroadcast the low packed 32-bit integer from a to all \xe2\x80\xa600CiBroadcast the low packed 64-bit integer from a to all \xe2\x80\xa600CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa600ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa600CkCompare packed 32-bit integers in a and b for equality, \xe2\x80\xa600CkCompare packed 64-bit integers in a and b for equality, \xe2\x80\xa600CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa600CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa600CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa600555ChCompare packed signed 32-bit integers in a and b for \xe2\x80\xa600ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa600444333222777111000444333222777111000444333222777111000444333222CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa600CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa600CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000ChLoad contiguous active 8-bit integers from unaligned \xe2\x80\xa600CiMultiply the lower complex number in a by the complex \xe2\x80\xa600CiNormalize the mantissas of the lower double-precision \xe2\x80\xa600CgNormalize the mantissas of the lower half-precision \xe2\x80\xa600CiNormalize the mantissas of the lower single-precision \xe2\x80\xa600CnStores 4 32-bit integer elements from a to memory starting \xe2\x80\xa600CnStores 2 64-bit integer elements from a to memory starting \xe2\x80\xa600CnStores 2 32-bit integer elements from a to memory starting \xe2\x80\xa600111CfShuffle 8-bit integers in a across lanes using the \xe2\x80\xa600ClReduce the packed 16-bit integers in a by addition using \xe2\x80\xa600CiReduce the packed 16-bit integers in a by bitwise AND \xe2\x80\xa600CkReduce the packed 16-bit integers in a by maximum using \xe2\x80\xa600CnReduce the packed unsigned 16-bit integers in a by maximum \xe2\x80\xa600CkReduce the packed 16-bit integers in a by minimum using \xe2\x80\xa600CnReduce the packed unsigned 16-bit integers in a by minimum \xe2\x80\xa600ClReduce the packed 16-bit integers in a by multiplication \xe2\x80\xa600CkCompute the bitwise NAND of packed 16-bit integers in a \xe2\x80\xa600CkCompute the bitwise NAND of packed 32-bit integers in a \xe2\x80\xa600CkCompute the bitwise NAND of packed 64-bit integers in a \xe2\x80\xa600CkBroadcasts the lower 2 packed 32-bit integers from a to \xe2\x80\xa600ChBroadcast the low packed 8-bit integer from a to all \xe2\x80\xa600ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600CjMultiply the lower complex numbers in a by the complex \xe2\x80\xa600CmMultiply the lower complex numbers in a and b, accumulate \xe2\x80\xa600C`Multiply the lower double-precision (64-bit) \xe2\x80\xa600CmMultiply the lower half-precision (16-bit) floating-point \xe2\x80\xa600C`Multiply the lower single-precision (32-bit) \xe2\x80\xa600222111000CfConvert the exponent of the lower double-precision \xe2\x80\xa600CmConvert the exponent of the lower half-precision (16-bit) \xe2\x80\xa600CfConvert the exponent of the lower single-precision \xe2\x80\xa600CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa600CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa600CnExtract the reduced argument of the lower double-precision \xe2\x80\xa600ClExtract the reduced argument of the lower half-precision \xe2\x80\xa600CnExtract the reduced argument of the lower single-precision \xe2\x80\xa600CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa600CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa600000CjShuffle 16-bit integers in the high 64 bits of 128-bit \xe2\x80\xa600CiShuffle 16-bit integers in the low 64 bits of 128-bit \xe2\x80\xa600CkLoads 4 32-bit integer elements from memory starting at \xe2\x80\xa600CkLoads 2 64-bit integer elements from memory starting at \xe2\x80\xa600CkLoads 2 32-bit integer elements from memory starting at \xe2\x80\xa600111CjFor each 64-bit element in b, select 8 unaligned bytes \xe2\x80\xa600CfPerform the InvMixColumns transform on <code>a</code>.0EhAllocates a new slice of size <code>len</code> slice into this <code>Bump</code> and \xe2\x80\xa6EbAllocates a new slice of size <code>len</code> into this <code>Bump</code> and \xe2\x80\xa6C`Init a print buffer using a pre-existing buffer.CnSame as av_buffersink_get_frame(), but with the ability to \xe2\x80\xa6CjCheck whether two channel layouts are semantically the \xe2\x80\xa6ChGet the default channel layout for a given number of \xe2\x80\xa6CjCompute what kind of losses will occur when converting \xe2\x80\xa6CiCallback used by devices to communicate with application.CiGet the buffer reference a given data plane is stored in.CjRemove and free all side data instances of the given type.BiGet the string name of an AVHWDeviceType.BdIterate over supported device types.CkFill plane sizes for an image with pixel format pix_fmt \xe2\x80\xa6BgGet the index for a specific timestamp.ClEnsure the data described by a given packet is reference \xe2\x80\xa6BgPack a dictionary for use in side_data.CnModify width and height values so that they will result in \xe2\x80\xa6CkGet the number of elements in an AVFilter\xe2\x80\x99s inputs or \xe2\x80\xa6CjGet a filter instance identified by instance name from \xe2\x80\xa6CkRead packets of a media file to get stream information. \xe2\x80\xa6BhFree entry allocated by avio_read_dir().D`Finds the index of the first 0 in <code>bits</code> from the \xe2\x80\xa60D`Reverses the order of the bits in <code>self</code> from the \xe2\x80\xa60CnBuild a forward finder using the given needle and a custom \xe2\x80\xa6CkCalculates the distance between two pointers within the \xe2\x80\xa6CnReturns the smallest power of two greater than or equal to \xe2\x80\xa600000BeCreates a command writer/reader pair.DbCompile-time friendly version of <code>try_from_millis_f64</code>.EdCounts the number of 0s in <code>self</code> from the <code>[start..=end]</code> \xe2\x80\xa600000000000CmSpecifies the ratio of the compute unit power accumulator \xe2\x80\xa6DiDecrements the strong reference count on the <code>Rc&lt;T&gt;</code> \xe2\x80\xa6DjDecrements the strong reference count on the <code>Arc&lt;T&gt;</code> \xe2\x80\xa6BiL1 Data TLB associativity for 1-GB pages.BiL2 Data TLB associativity for 1-GB pages.BjDuplicate the odd lanes to the even lanes.0CbDuplicate the even-indexed lanes to the odd lanes.0CbDuplicate the odd-indexed lanes to the even lanes.0ClReturns the family name of the current font face without \xe2\x80\xa6CkConverts a boxed slice of bytes to a boxed string slice \xe2\x80\xa6000BgCreates a layout, bypassing all checks.CjLow lane <code>-(a * b) + c</code>, other lanes unchanged.0D`Low lane fused <code>-(a * b) - c</code>, other lanes unchanged.0CnGet the number of sample chunk decoders available from the \xe2\x80\xa6CkCalculates the 2D coordinates from the given 1D array index0CfFind out about more features supported by this CPU \xe2\x80\xa6CcL1 Instruction Cache Information (LEAF=0x8000_0005)ChWhether the aspect ratio is maintained on window resize.BkGet the number of music decoders available.ClSet the window\xe2\x80\x99s OpenGL context to the current context \xe2\x80\xa6ClConvert the supplied image to a grayscale image with the \xe2\x80\xa60CfHardware cache coherency across encryption domains \xe2\x80\xa6CkReports whether the response of the delay values is linear.BcIs MCA overflow recovery available?BhHas Processor power reporting interface?BlFP Error Pointers Restored by XRSTOR if set.CbVMSAVE and VMLOAD virtualization supported if set.DiIncrements the strong reference count on the <code>Rc&lt;T&gt;</code> \xe2\x80\xa6DjIncrements the strong reference count on the <code>Arc&lt;T&gt;</code> \xe2\x80\xa6E`Inserts the low 16 bits of an <code>i32</code> value into an <code>m128i</code>.0BiCalls `NumInt::int_ref_digital_root_base.00CeSimilar to int_digital_root_base, but operates on \xe2\x80\xa600BiCalls `NumInt::int_ref_factors_prime_buf.00CeSimilar to int_factors_prime_buf, but operates on \xe2\x80\xa600BiCalls `NumInt::int_ref_modulo_add_cycles.00CeSimilar to int_modulo_add_cycles, but operates on \xe2\x80\xa600BiCalls `NumInt::int_ref_modulo_mul_cycles.00CeSimilar to int_modulo_mul_cycles, but operates on \xe2\x80\xa600BiCalls `NumInt::int_ref_modulo_sub_cycles.00CeSimilar to int_modulo_sub_cycles, but operates on \xe2\x80\xa600CjSupports treating interrupts as break-event for MWAIT, \xe2\x80\xa6DcDecomposes a <code>Vec&lt;T&gt;</code> into its raw components: \xe2\x80\xa6CoDecomposes a <code>Vec&lt;T&gt;</code> into its raw components.DdA macro to test at <em>runtime</em> whether instruction sets are \xe2\x80\xa6C`Checks if <code>s390x</code> feature is enabled.CmReturns true if the call failed because the Tokio context \xe2\x80\xa6CfReturns an iterator over raw pointers to chunks of \xe2\x80\xa6C`L1 Instruction TLB associativity for 1-GB pages.C`L2 Instruction TLB associativity for 1-GB pages.CkReturn the elements producing the k smallest outputs of \xe2\x80\xa6000BfLoad data from memory into a register.0ClMaximum number of addressable IDs for logical processors \xe2\x80\xa6EfMultiply <code>i16</code> lanes into <code>i32</code> intermediates, keep the high \xe2\x80\xa6000CiOffset in the structure where a pointer to the parent \xe2\x80\xa6DjThe <code>prefetch</code> intrinsic is a hint to the code generator to \xe2\x80\xa600ChRetrieves the layout rasterized bitmap for the given \xe2\x80\xa6CnReturns the amount of time elapsed from another instant to \xe2\x80\xa6EdSerialize a newtype variant like <code>E::N</code> in <code>enum E { N(u8) }</code>.0Da<strong>Sets</strong> the attribute: OpenGL context major versionDa<strong>Sets</strong> the attribute: OpenGL context minor versionDgSet whether to <code>maintain</code> the aspect ratio on window resize.00FaShuffle the <code>f64</code> lanes from <code>$a</code> and <code>$b</code> together using an \xe2\x80\xa60EcShuffle the <code>i32</code> lanes in <code>a</code> using an immediate control \xe2\x80\xa60FmShuffle <code>f64</code> lanes in <code>a</code> using bit 1 of the <code>i64</code> lanes in <code>v</code>.GnShuffle <code>f64</code> lanes in <code>a</code> using <strong>bit 1</strong> of the <code>i64</code> lanes in <code>v</code>.EoShuffle <code>i8</code> lanes in <code>a</code> using <code>i8</code> values in <code>v</code>.0CnAdds elements within a vector in arbitrary order. May also \xe2\x80\xa600CkMultiplies elements within a vector in arbitrary order. \xe2\x80\xa600BnReturns the total number of outcoming packets.DdSame as <code>alloc_slice_fill_copy</code> but does not panic on \xe2\x80\xa6DiAllocates a new slice of size <code>iter.len()</code> slice into this \xe2\x80\xa6EbAllocates a new slice of size <code>len</code> into this <code>Bump</code> and \xe2\x80\xa6CfNon-overlapping <em>typed</em> swap of a single value.00DfReturns a new <code>Pieces</code> with the given time zone annotation.E`Casts <code>self</code> to <code>isize_up</code> wrapping at the numeric bounds.0EdCasts from <code>u32</code> to <code>isize_up</code> wrapping at the numeric bounds.EeCasts from <code>i128</code> to <code>isize_up</code> wrapping at the numeric bounds.EeCasts from <code>u128</code> to <code>isize_up</code> wrapping at the numeric bounds.EdCasts from <code>u16</code> to <code>isize_up</code> wrapping at the numeric bounds.EdCasts from <code>i32</code> to <code>isize_up</code> wrapping at the numeric bounds.EcCasts from <code>u8</code> to <code>isize_up</code> wrapping at the numeric bounds.EdCasts from <code>i16</code> to <code>isize_up</code> wrapping at the numeric bounds.EdCasts from <code>i64</code> to <code>isize_up</code> wrapping at the numeric bounds.EcCasts from <code>i8</code> to <code>isize_up</code> wrapping at the numeric bounds.EbCasts from <code>usize</code> to <code>isize_up</code> wrapping at the numeric \xe2\x80\xa6EbCasts from <code>isize</code> to <code>isize_up</code> wrapping at the numeric \xe2\x80\xa6EdCasts from <code>u64</code> to <code>isize_up</code> wrapping at the numeric bounds.E`Casts <code>self</code> to <code>usize_up</code> wrapping at the numeric bounds.0EdCasts from <code>u16</code> to <code>usize_up</code> wrapping at the numeric bounds.EdCasts from <code>u32</code> to <code>usize_up</code> wrapping at the numeric bounds.EcCasts from <code>u8</code> to <code>usize_up</code> wrapping at the numeric bounds.EeCasts from <code>i128</code> to <code>usize_up</code> wrapping at the numeric bounds.EbCasts from <code>isize</code> to <code>usize_up</code> wrapping at the numeric \xe2\x80\xa6EeCasts from <code>u128</code> to <code>usize_up</code> wrapping at the numeric bounds.EdCasts from <code>u64</code> to <code>usize_up</code> wrapping at the numeric bounds.EdCasts from <code>i64</code> to <code>usize_up</code> wrapping at the numeric bounds.EbCasts from <code>usize</code> to <code>usize_up</code> wrapping at the numeric \xe2\x80\xa6EcCasts from <code>i8</code> to <code>usize_up</code> wrapping at the numeric bounds.EdCasts from <code>i16</code> to <code>usize_up</code> wrapping at the numeric bounds.EdCasts from <code>i32</code> to <code>usize_up</code> wrapping at the numeric bounds.B`Support for MPX BNDREGS in XCR0.ClThe duration of a video can be estimated through various \xe2\x80\xa6Bg&lt; all automatic conversions disabledCk&lt; Duration estimated from a stream with a known durationCfstage of the initialization of the link properties \xe2\x80\xa6AcRequest pause/play.CbKeep a reference to the frame. If the frame if \xe2\x80\xa6CnThe audio is represented as the decomposition of the sound \xe2\x80\xa6jSee above.CmMetadata relevant to a downmix procedure. The data is the \xe2\x80\xa6CnThe GOP timecode in 25 bit timecode format. Data format is \xe2\x80\xa6CnRecommmends skipping the specified number of samples. This \xe2\x80\xa6Ac&lt; coded as frameCiThis side data corresponds to the AVCPBProperties struct.CmThis side data contains an integer value representing the \xe2\x80\xa6CmPerform non-blocking operation. If this flag is set, send \xe2\x80\xa6Ak&lt; timecode is drop frameCkInserts one ASCII whitespace between the unit value and \xe2\x80\xa6Ch505 HTTP Version Not Supported [RFC9110, Section 15.6.6]Dj<code>IntoParallelRefMutIterator</code> implements the conversion to a \xe2\x80\xa60DhRetrieve the minute component of a <code>PyDateTime_DateTime</code>. \xe2\x80\xa6DhRetrieve the second component of a <code>PyDateTime_DateTime</code>. \xe2\x80\xa6DhRetrieve the tzinfo component of a <code>PyDateTime_DateTime</code>. \xe2\x80\xa6DdRetrieve the minute component of a <code>PyDateTime_Time</code>. \xe2\x80\xa62DdRetrieve the tzinfo component of a <code>PyDateTime_Time</code>. \xe2\x80\xa6CkSet if the type implements the vectorcall protocol (PEP \xe2\x80\xa6Da&lt; The application did enter the background and may not get \xe2\x80\xa6Cl&lt; The application is now interactive Called on iOS in \xe2\x80\xa6Bm&lt; max(dst, src) : supported by D3D9, D3D11Bm&lt; min(dst, src) : supported by D3D9, D3D11Bg&lt; Game controller sensor was updatedBi&lt; Game controller touchpad was touchedBjCompose a custom blend mode for renderers.CeCreate a 2D software rendering context for a surface.Bi&lt; Display has been added to the systemCeGet the usable desktop area represented by a display.BoGet the blend mode used for drawing operations.CdOpen a haptic device for use from a joystick device.CdGet the SDL_Joystick associated with an instance id.BkGet the player index of an opened joystick.CbStart a rumble effect in the joystick\xe2\x80\x99s triggersBkSet the player index of an opened joystick.CcSet values on an opened, virtual-joystick\xe2\x80\x99s axis.BfSets the UNIX nice value for a thread.Ai&lt; informational dialogCmConvert a bpp value and RGBA masks to an enumerated pixel \xe2\x80\xa6CnConvert one of the enumerated pixel formats to a bpp value \xe2\x80\xa6Bo&lt; The renderer supports rendering to textureCm&lt; display mirroring/dual display switch, video mode switchCb&lt; Double arrow pointing northeast and southwestCb&lt; Double arrow pointing northwest and southeastCcSave all currently loaded Dollar Gesture templates.ClSet the blend mode used for drawing operations (Fill and \xe2\x80\xa6CfGet the size of the window\xe2\x80\x99s underlying drawable \xe2\x80\xa6Bc&lt; Window has lost keyboard focusC`&lt; Window is being offered a focus (should \xe2\x80\xa6BgGet a feature report from a HID device.CjGet a string from a HID device, based on its string index.BiGet The Product String from a HID device.DkIf SSD is not supported, will try to load <code>libdecor</code> to draw \xe2\x80\xa6CbIf SSD is not supported, draw a light gray border.DfA type for formatting a <code>Timestamp</code> with a specific offset.Cg<code>XFEATURE_ENABLED_MASK</code> for <code>XCR</code>00CnBroadcast the low double-precision (64-bit) floating-point \xe2\x80\xa600CnBroadcast the low single-precision (32-bit) floating-point \xe2\x80\xa600CmCompare packed signed 16-bit integers in a and b based on \xe2\x80\xa600CmCompare packed signed 32-bit integers in a and b based on \xe2\x80\xa600CmCompare packed signed 64-bit integers in a and b based on \xe2\x80\xa600ClCompare packed unsigned 16-bit integers in a and b based \xe2\x80\xa600ClCompare packed unsigned 32-bit integers in a and b based \xe2\x80\xa600ClCompare packed unsigned 64-bit integers in a and b based \xe2\x80\xa600CmContiguously store the active 16-bit integers in a (those \xe2\x80\xa600CmContiguously store the active 32-bit integers in a (those \xe2\x80\xa600CmContiguously store the active 64-bit integers in a (those \xe2\x80\xa600CmTest each 32-bit element of a for equality with all other \xe2\x80\xa600CmTest each 64-bit element of a for equality with all other \xe2\x80\xa600CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa600ClSign extend packed 16-bit integers in a to packed 32-bit \xe2\x80\xa600ClSign extend packed 16-bit integers in a to packed 64-bit \xe2\x80\xa600ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa600ClSign extend packed 32-bit integers in a to packed 64-bit \xe2\x80\xa600ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa600ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa600CnZero extend packed unsigned 16-bit integers in a to packed \xe2\x80\xa600ClZero extend packed unsigned 16-bit integers in the low 8 \xe2\x80\xa600CnZero extend packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa600CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa600CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa600CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa600CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa600CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa600000CkShuffle 64-bit integers in a within 256-bit lanes using \xe2\x80\xa600CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa600CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa600CmReduce the packed 8-bit integers in a by bitwise OR using \xe2\x80\xa600CmCompute the bitwise AND of packed 8-bit integers in a and \xe2\x80\xa600ClUnpack and interleave 16-bit integers from the high half \xe2\x80\xa600ClUnpack and interleave 32-bit integers from the high half \xe2\x80\xa600ClUnpack and interleave 64-bit integers from the high half \xe2\x80\xa600CnUnpack and interleave 16-bit integers from the low half of \xe2\x80\xa600CnUnpack and interleave 32-bit integers from the low half of \xe2\x80\xa600CnUnpack and interleave 64-bit integers from the low half of \xe2\x80\xa600ClContiguously store the active 8-bit integers in a (those \xe2\x80\xa600CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa600CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa600CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa600CkSign extend packed 8-bit integers in a to packed 16-bit \xe2\x80\xa600CkSign extend packed 8-bit integers in a to packed 32-bit \xe2\x80\xa600CmSign extend packed 8-bit integers in the low 4 bytes of a \xe2\x80\xa600CmZero extend packed unsigned 8-bit integers in a to packed \xe2\x80\xa600CkZero extend packed unsigned 8-bit integers in the low 8 \xe2\x80\xa600CkZero extend packed unsigned 8-bit integers in the low 4 \xe2\x80\xa600CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa600ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa600CmPerforms a multiplication in GF(2^8) on the packed bytes. \xe2\x80\xa600CjMultiply packed unsigned 8-bit integers in a by packed \xe2\x80\xa600CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa600CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa600CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa600CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa600CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa600CkShuffle 32-bit integers in a within 128-bit lanes using \xe2\x80\xa600CmShuffle 128-bits (composed of 4 single-precision (32-bit) \xe2\x80\xa600CmShuffle 128-bits (composed of 2 double-precision (64-bit) \xe2\x80\xa600CmShuffle 128-bits (composed of 4 32-bit integers) selected \xe2\x80\xa600CmShuffle 128-bits (composed of 2 64-bit integers) selected \xe2\x80\xa600CnUnpack and interleave 8-bit integers from the high half of \xe2\x80\xa600CmUnpack and interleave 8-bit integers from the low half of \xe2\x80\xa600CnBroadcast the low double-precision (64-bit) floating-point \xe2\x80\xa600CnBroadcast the low single-precision (32-bit) floating-point \xe2\x80\xa600CmCompare packed signed 16-bit integers in a and b based on \xe2\x80\xa600CmCompare packed signed 32-bit integers in a and b based on \xe2\x80\xa600CmCompare packed signed 64-bit integers in a and b based on \xe2\x80\xa600ClCompare packed unsigned 16-bit integers in a and b based \xe2\x80\xa600ClCompare packed unsigned 32-bit integers in a and b based \xe2\x80\xa600ClCompare packed unsigned 64-bit integers in a and b based \xe2\x80\xa600CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa600CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa600111000111000111000CgMultiply packed complex numbers in a by the complex \xe2\x80\xa600CmContiguously store the active 16-bit integers in a (those \xe2\x80\xa600CmContiguously store the active 32-bit integers in a (those \xe2\x80\xa600CmContiguously store the active 64-bit integers in a (those \xe2\x80\xa600CmTest each 32-bit element of a for equality with all other \xe2\x80\xa600CmTest each 64-bit element of a for equality with all other \xe2\x80\xa600CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa600000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa600000ClSign extend packed 16-bit integers in a to packed 32-bit \xe2\x80\xa600ClSign extend packed 16-bit integers in a to packed 64-bit \xe2\x80\xa600ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa600ClSign extend packed 32-bit integers in a to packed 64-bit \xe2\x80\xa600ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa600ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa600CnZero extend packed unsigned 16-bit integers in a to packed \xe2\x80\xa600000CnZero extend packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa600CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa600CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa600CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa600CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa600ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa600CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa600ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa600222111000CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa600CmLoads 8 double-precision (64-bit) floating-point elements \xe2\x80\xa600CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa600000CkShuffle 64-bit integers in a within 256-bit lanes using \xe2\x80\xa600CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa600CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa600CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa600000CmCompute the bitwise AND of packed 8-bit integers in a and \xe2\x80\xa600ClUnpack and interleave 16-bit integers from the high half \xe2\x80\xa600ClUnpack and interleave 32-bit integers from the high half \xe2\x80\xa600ClUnpack and interleave 64-bit integers from the high half \xe2\x80\xa600CnUnpack and interleave 16-bit integers from the low half of \xe2\x80\xa600CnUnpack and interleave 32-bit integers from the low half of \xe2\x80\xa600CnUnpack and interleave 64-bit integers from the low half of \xe2\x80\xa600ClContiguously store the active 8-bit integers in a (those \xe2\x80\xa600CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa600CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa600CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa600CkSign extend packed 8-bit integers in a to packed 16-bit \xe2\x80\xa600CkSign extend packed 8-bit integers in a to packed 32-bit \xe2\x80\xa600CmSign extend packed 8-bit integers in the low 8 bytes of a \xe2\x80\xa600CmZero extend packed unsigned 8-bit integers in a to packed \xe2\x80\xa600000CkZero extend packed unsigned 8-bit integers in the low 8 \xe2\x80\xa600CiMultiply groups of 4 adjacent pairs of unsigned 8-bit \xe2\x80\xa600ChMultiply groups of 2 adjacent pairs of signed 16-bit \xe2\x80\xa600CmPerforms a multiplication in GF(2^8) on the packed bytes. \xe2\x80\xa600CjMultiply packed unsigned 8-bit integers in a by packed \xe2\x80\xa600CmMultiply the packed complex numbers in a and b, and store \xe2\x80\xa600CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa600CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa600CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa600CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa600CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa600CkShuffle 32-bit integers in a within 128-bit lanes using \xe2\x80\xa600CmShuffle 128-bits (composed of 4 single-precision (32-bit) \xe2\x80\xa600CmShuffle 128-bits (composed of 2 double-precision (64-bit) \xe2\x80\xa600CmShuffle 128-bits (composed of 4 32-bit integers) selected \xe2\x80\xa600CmShuffle 128-bits (composed of 2 64-bit integers) selected \xe2\x80\xa600CfCompute the square root of packed double-precision \xe2\x80\xa600CmCompute the square root of packed half-precision (16-bit) \xe2\x80\xa600CfCompute the square root of packed single-precision \xe2\x80\xa600CnUnpack and interleave 8-bit integers from the high half of \xe2\x80\xa600CmUnpack and interleave 8-bit integers from the low half of \xe2\x80\xa600<<<;;;:::CkPerforms an affine transformation on the packed bytes in x.00CiMultiply the lower complex number in a by the complex \xe2\x80\xa600CnCompare the lower double-precision (64-bit) floating-point \xe2\x80\xa600ClCompare the lower half-precision (16-bit) floating-point \xe2\x80\xa600CnCompare the lower single-precision (32-bit) floating-point \xe2\x80\xa600ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa600ClCompare packed 32-bit integers in a and b for not-equal, \xe2\x80\xa600ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa600CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa600CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa600CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa600CkContiguously store the active double-precision (64-bit) \xe2\x80\xa600CkContiguously store the active single-precision (32-bit) \xe2\x80\xa600CiLoad contiguous active 16-bit integers from unaligned \xe2\x80\xa600CiLoad contiguous active 32-bit integers from unaligned \xe2\x80\xa600CiLoad contiguous active 64-bit integers from unaligned \xe2\x80\xa600CmFix up the lower double-precision (64-bit) floating-point \xe2\x80\xa600CmFix up the lower single-precision (32-bit) floating-point \xe2\x80\xa600ClShuffle 8-bit integers in a and b across lanes using the \xe2\x80\xa600CgShuffle 16-bit integers in a across lanes using the \xe2\x80\xa600CiBroadcast the low packed 32-bit integer from a to all \xe2\x80\xa600CiBroadcast the low packed 64-bit integer from a to all \xe2\x80\xa600CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa600CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000ChLoad contiguous active 8-bit integers from unaligned \xe2\x80\xa600CiMultiply the lower complex number in a by the complex \xe2\x80\xa600CiNormalize the mantissas of the lower double-precision \xe2\x80\xa600CgNormalize the mantissas of the lower half-precision \xe2\x80\xa600CiNormalize the mantissas of the lower single-precision \xe2\x80\xa600CfShuffle 8-bit integers in a across lanes using the \xe2\x80\xa600BkWhether to allow non-standard HTTP methods.0CkChecks that the preconditions of an unsafe function are \xe2\x80\xa6000CmGet a human-readable string describing the channel layout \xe2\x80\xa6BjIterate over all standard channel layouts.Cn@return The AV_DISPOSITION_* flag corresponding to disp or \xe2\x80\xa6BgGet the description of a given channel.CnAllocate a HW-specific configuration structure for a given \xe2\x80\xa6CnCompute the max pixel step for each plane of an image with \xe2\x80\xa6AmAudio input devices iterator.AmVideo input devices iterator.CkWrite a packet to an output media file ensuring correct \xe2\x80\xa6ChIterate over potential AVOptions-enabled children of \xe2\x80\xa6BmShrink the already allocated side data bufferCjRemove side data of the given type from a side data array.CjUtility function to swap the endianness of a pixel format.CdGet the required buffer size for the given audio \xe2\x80\xa6CiConverts swscale x/y chroma position to AVChromaLocation.CiConverts AVChromaLocation to swscale x/y chroma position.BiConvenient function to free result of \xe2\x80\xa6DdCasts <code>self</code> to <code>isize_down</code> with range check.0DgCasts from <code>i8</code> to <code>isize_down</code> with range check.DiCasts from <code>i128</code> to <code>isize_down</code> with range check.DgCasts from <code>u8</code> to <code>isize_down</code> with range check.DhCasts from <code>u32</code> to <code>isize_down</code> with range check.DhCasts from <code>u16</code> to <code>isize_down</code> with range check.DhCasts from <code>i16</code> to <code>isize_down</code> with range check.DjCasts from <code>usize</code> to <code>isize_down</code> with range check.DhCasts from <code>i64</code> to <code>isize_down</code> with range check.DjCasts from <code>isize</code> to <code>isize_down</code> with range check.DiCasts from <code>u128</code> to <code>isize_down</code> with range check.DhCasts from <code>u64</code> to <code>isize_down</code> with range check.DhCasts from <code>i32</code> to <code>isize_down</code> with range check.DdCasts <code>self</code> to <code>usize_down</code> with range check.0DhCasts from <code>u64</code> to <code>usize_down</code> with range check.DiCasts from <code>i128</code> to <code>usize_down</code> with range check.DjCasts from <code>usize</code> to <code>usize_down</code> with range check.DhCasts from <code>i64</code> to <code>usize_down</code> with range check.DjCasts from <code>isize</code> to <code>usize_down</code> with range check.DhCasts from <code>u32</code> to <code>usize_down</code> with range check.DhCasts from <code>i16</code> to <code>usize_down</code> with range check.DgCasts from <code>u8</code> to <code>usize_down</code> with range check.DhCasts from <code>i32</code> to <code>usize_down</code> with range check.DiCasts from <code>u128</code> to <code>usize_down</code> with range check.DgCasts from <code>i8</code> to <code>usize_down</code> with range check.DhCasts from <code>u16</code> to <code>usize_down</code> with range check.EcConvert <code>i32</code> to <code>f32</code> and replace the low lane of the input.0EcConvert <code>i64</code> to <code>f32</code> and replace the low lane of the input.DfConvert the lowest <code>f32</code> lane to a single <code>f32</code>.0DlRounds the two <code>f64</code> lanes to the low two <code>f32</code> lanes.0ClConvert <code>f64</code> lanes to be <code>f32</code> lanes.0ClConvert <code>f32</code> lanes to be <code>f64</code> lanes.0EhCopies the <code>a</code> value and replaces the low lane with the low <code>b</code>\xe2\x80\xa60DfHint that the <code>Deserialize</code> type is expecting a newtype \xe2\x80\xa60CeThe percentage of damaged samples to discard a frame.CkCopy the low lane of the input to both lanes of the output.0CmThe duration field can be estimated through various ways, \xe2\x80\xa6CkComputes the Levenshtein edit distance between two UTF8 \xe2\x80\xa6Cd(addEventListener) Attaches a Rust function as a \xe2\x80\xa6BjReturns the count of unique prime factors.0DjHelper macro when implementing the <code>Deserializer</code> part of a \xe2\x80\xa6EeReturns a string from an array of <code>bytes</code>, truncated to <code>n</code> \xe2\x80\xa6DjAttempts to get mutable references to <code>N</code> values in the map \xe2\x80\xa6BgInformation about topology (LEAF=0x0B).C`Informations about memory encryption support \xe2\x80\xa6BoReturns how many channels are currently paused.ChRetrieve processor brand string (LEAF=0x8000_000{2..4}).CmReleases the thread\xe2\x80\x99s current OpenGL context, i.e. sets \xe2\x80\xa6AeAnyThread deprecationCiIf true, Indicates support of IP Filtering, TraceStop \xe2\x80\xa6CfIndicates support for the PAUSE filter cycle count \xe2\x80\xa6BaEFER.LMSLE is unsupported if set.BjCalls `NumInt::int_ref_factors_proper_buf.00CfSimilar to int_factors_proper_buf, but operates on \xe2\x80\xa600BdCore cycle event not available if 1.BmInstruction retired event not available if 1.CaChecks if <code>mips64</code> feature is enabled.BfLoad data from memory into a register.000ClThe maximum supported enclave size in non-64-bit mode is \xe2\x80\xa6DjThe size of the <code>apic_id_size</code> field determines the maximum \xe2\x80\xa6DhLike <code>panic_nounwind</code>, but also inhibits showing a backtrace.0ChReturns a parallel iterator over the sub-slices of a \xe2\x80\xa60AnPhysical Address bit reductionCfReturn the player index of the joystick with index \xe2\x80\xa6DjThe <code>prefetch</code> intrinsic is a hint to the code generator to \xe2\x80\xa600CmRetrieves the layout metrics and rasterized bitmap at the \xe2\x80\xa6EdSets the lowest <code>i8</code> lane of an <code>m128i</code> as all lanes of an \xe2\x80\xa60Dl<strong>Gets</strong> the attribute: OpenGL context sharing; defaults to \xe2\x80\xa6BgStore data from a register into memory.0ClReturns the slice omitting the last <code>n</code> elements.DgLike <code>alloc_slice_fill_clone</code> but does not panic on failure.CmGet the names of the Vulkan instance extensions needed to \xe2\x80\xa6CgProvide the bits per sample of an encoded audio sample.C`Provide the maximum number of frames per packet.ChSpecify if the packet\xe2\x80\x99s data integrity was guaranteed.CjReturns the amount of time the given worker thread has \xe2\x80\xa6CeIndicates whether the response can be shared with \xe2\x80\xa6Cc&lt; Chromaticity-derived constant luminance systemCd&lt; Duration estimated from bitrate (less accurate)CnA point in the output bytestream where a decoder can start \xe2\x80\xa6jSee above.CgThis side data contains a 3x3 transformation matrix \xe2\x80\xa6CkParsed Dolby Vision metadata, suitable for passing to a \xe2\x80\xa6ClTimecode which conforms to SMPTE ST 12-1. The data is an \xe2\x80\xa6CnThis side data contains encryption info for how to decrypt \xe2\x80\xa6ClA list of zero terminated key/value strings. There is no \xe2\x80\xa6CgThe optional settings (rendering instructions) that \xe2\x80\xa6Bb&lt; timecode wraps after 24 hoursBkPCM 32-bit big-endian floating point planarBnPCM 32-bit little-endian floating point planarBkPCM 64-bit big-endian floating point planarBnPCM 64-bit little-endian floating point planarBcPCM signed 16-bit big-endian planarBfPCM signed 16-bit little-endian planarBcPCM signed 24-bit big-endian planarBfPCM signed 24-bit little-endian planarBcPCM signed 32-bit big-endian planarBfPCM signed 32-bit little-endian planarBePCM unsigned 16-bit big-endian planarBhPCM unsigned 16-bit little-endian planarBePCM unsigned 24-bit big-endian planarBhPCM unsigned 24-bit little-endian planarBePCM unsigned 32-bit big-endian planarBhPCM unsigned 32-bit little-endian planarD`An iterator to iterate through all the <code>n</code>-length \xe2\x80\xa60ChThis is the minimum interval time used internally by \xe2\x80\xa6ClOwned RAII structure used to release the exclusive write \xe2\x80\xa6ChSends reports of pinning violation to the report-uri \xe2\x80\xa6CgPerformance Optimization Identifier (LEAF=0x8000_001A).CgA command that disables extra kinds of keyboard events.EhThis variant corresponds with <code>METH_FASTCALL</code> | <code>METH_KEYWORDS</code>\xe2\x80\xa6DgRepresents Python\xe2\x80\x99s <code>PendingDeprecationWarning</code> exception.D`&lt; The application is about to enter the background Called \xe2\x80\xa6D`&lt; The application is about to enter the foreground Called \xe2\x80\xa6Bc&lt; Ignore the assert from now on.Ck&lt; dst - src : supported by D3D9, D3D11, OpenGL, OpenGLESBo&lt; An opened Game controller has been removedCc\\brief Game controller touchpad event structure \xe2\x80\xa6BeCreate a window and default renderer.CgGet the current state of a button on a game controller.CeGet the serial number of an opened controller, if \xe2\x80\xa6CeGet the USB vendor ID of an opened controller, if \xe2\x80\xa6CcQuery whether a game controller has a given button.CcQuery whether a game controller has rumble support.CiReturn whether a game controller has a particular sensor.ChGet the count per second of the high resolution counter.ClGet UTF-8 text from the primary selection, which must be \xe2\x80\xa6CmGet the number of effects a haptic device can play at the \xe2\x80\xa6CmQuery whether the primary selection exists and contains a \xe2\x80\xa6CgAttach a new virtual joystick with extended properties.CdGet the SDL_Joystick associated with a player index.CbGet the USB vendor ID of a joystick, if available.Cf&lt; used on Asian keyboards, see footnotes in USB doch&lt; YenD`&lt; This is the additional key that ISO keyboards have over \xe2\x80\xa6n&lt; CrosshairCa&lt; Small wait cursor (or Wait if not available)BjPut UTF-8 text into the primary selection.Ba&lt; Changes frequently, lockableBf&lt; window has grabbed keyboard inputCgCheck to see if devices may have been added or removed.BdSend a Feature report to the device.CmBroadcasts 128 bits of integer data from a to all 128-bit \xe2\x80\xa600CkBroadcasts the lower 2 packed single-precision (32-bit) \xe2\x80\xa600CdBroadcast the 4 packed single-precision (32-bit) \xe2\x80\xa600CeBroadcasts the 2 packed double-precision (64-bit) \xe2\x80\xa600CkBroadcasts the lower 2 packed 32-bit integers from a to \xe2\x80\xa600ChBroadcast the 4 packed 32-bit integers from a to all \xe2\x80\xa600CiBroadcasts the 2 packed 64-bit integers from a to all \xe2\x80\xa600ChBroadcast the low packed 8-bit integer from a to all \xe2\x80\xa600CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa600CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa600111000111000111000111000ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600CkExtract 128 bits (composed of 4 packed single-precision \xe2\x80\xa600ClExtracts 128 bits (composed of 2 packed double-precision \xe2\x80\xa600ChTest packed double-precision (64-bit) floating-point \xe2\x80\xa600CfTest packed half-precision (16-bit) floating-point \xe2\x80\xa600ChTest packed single-precision (32-bit) floating-point \xe2\x80\xa600DcReturns values from <code>slice</code> at offsets determined by \xe2\x80\xa600000000000CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa600CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa600CkReduce the packed 8-bit integers in a by addition using \xe2\x80\xa600CnReduce the packed 8-bit integers in a by bitwise AND using \xe2\x80\xa600CjReduce the packed 8-bit integers in a by maximum using \xe2\x80\xa600CmReduce the packed unsigned 8-bit integers in a by maximum \xe2\x80\xa600CjReduce the packed 8-bit integers in a by minimum using \xe2\x80\xa600CmReduce the packed unsigned 8-bit integers in a by minimum \xe2\x80\xa600CkReduce the packed 8-bit integers in a by multiplication \xe2\x80\xa600CnReduce the packed 16-bit integers in a by bitwise OR using \xe2\x80\xa600CjShuffle 16-bit integers in the high 64 bits of 128-bit \xe2\x80\xa600CiShuffle 16-bit integers in the low 64 bits of 128-bit \xe2\x80\xa600CnCompute the bitwise AND of packed 16-bit integers in a and \xe2\x80\xa600CnCompute the bitwise AND of packed 32-bit integers in a and \xe2\x80\xa600CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa600CnCompute the bitwise NAND of packed 8-bit integers in a and \xe2\x80\xa600CnBroadcast the low double-precision (64-bit) floating-point \xe2\x80\xa600CnBroadcast the low single-precision (32-bit) floating-point \xe2\x80\xa600CmContiguously store the active 16-bit integers in a (those \xe2\x80\xa600CmContiguously store the active 32-bit integers in a (those \xe2\x80\xa600CmContiguously store the active 64-bit integers in a (those \xe2\x80\xa600CmTest each 32-bit element of a for equality with all other \xe2\x80\xa600CmTest each 64-bit element of a for equality with all other \xe2\x80\xa600CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa600ClSign extend packed 16-bit integers in a to packed 32-bit \xe2\x80\xa600ClSign extend packed 16-bit integers in a to packed 64-bit \xe2\x80\xa600ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa600ClSign extend packed 32-bit integers in a to packed 64-bit \xe2\x80\xa600ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa600ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa600CnZero extend packed unsigned 16-bit integers in a to packed \xe2\x80\xa600ClZero extend packed unsigned 16-bit integers in the low 8 \xe2\x80\xa600CnZero extend packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa600CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa600CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa600CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa600CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa600CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa600000CkShuffle 64-bit integers in a within 256-bit lanes using \xe2\x80\xa600CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa600CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa600ClUnpack and interleave 16-bit integers from the high half \xe2\x80\xa600ClUnpack and interleave 32-bit integers from the high half \xe2\x80\xa600ClUnpack and interleave 64-bit integers from the high half \xe2\x80\xa600CnUnpack and interleave 16-bit integers from the low half of \xe2\x80\xa600CnUnpack and interleave 32-bit integers from the low half of \xe2\x80\xa600CnUnpack and interleave 64-bit integers from the low half of \xe2\x80\xa600DhPermutes packed 32-bit integers from <code>a</code> according to the \xe2\x80\xa600ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa600CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa600ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa600222111000CkBroadcasts the lower 2 packed single-precision (32-bit) \xe2\x80\xa600CdBroadcast the 4 packed single-precision (32-bit) \xe2\x80\xa600CeBroadcasts the 8 packed single-precision (32-bit) \xe2\x80\xa600CeBroadcasts the 2 packed double-precision (64-bit) \xe2\x80\xa600CdBroadcast the 4 packed double-precision (64-bit) \xe2\x80\xa600CkBroadcasts the lower 2 packed 32-bit integers from a to \xe2\x80\xa600ChBroadcast the 4 packed 32-bit integers from a to all \xe2\x80\xa600CiBroadcasts the 8 packed 32-bit integers from a to all \xe2\x80\xa600CiBroadcasts the 2 packed 64-bit integers from a to all \xe2\x80\xa600ChBroadcast the 4 packed 64-bit integers from a to all \xe2\x80\xa600ChBroadcast the low packed 8-bit integer from a to all \xe2\x80\xa600CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa600CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa600111000111000111000111000ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa600CkExtract 128 bits (composed of 4 packed single-precision \xe2\x80\xa600ClExtracts 256 bits (composed of 8 packed single-precision \xe2\x80\xa600ClExtracts 128 bits (composed of 2 packed double-precision \xe2\x80\xa600CkExtract 256 bits (composed of 4 packed double-precision \xe2\x80\xa600CgMultiply packed complex numbers in a by the complex \xe2\x80\xa600CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa600ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa600CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa600ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa600222111000ChTest packed double-precision (64-bit) floating-point \xe2\x80\xa600CfTest packed half-precision (16-bit) floating-point \xe2\x80\xa600ChTest packed single-precision (32-bit) floating-point \xe2\x80\xa600ChConvert the exponent of each packed double-precision \xe2\x80\xa600CfConvert the exponent of each packed half-precision \xe2\x80\xa600ChConvert the exponent of each packed single-precision \xe2\x80\xa600ClGather 32-bit integers from memory using 32-bit indices. \xe2\x80\xa600ClGather 64-bit integers from memory using 32-bit indices. \xe2\x80\xa600CnStores 8 double-precision (64-bit) floating-point elements \xe2\x80\xa600ClGather 32-bit integers from memory using 64-bit indices. \xe2\x80\xa600ClGather 64-bit integers from memory using 64-bit indices. \xe2\x80\xa600CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa600CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa600CnReduce the packed 32-bit integers in a by bitwise OR using \xe2\x80\xa600CnReduce the packed 64-bit integers in a by bitwise OR using \xe2\x80\xa600CkExtract the reduced argument of packed double-precision \xe2\x80\xa600CiExtract the reduced argument of packed half-precision \xe2\x80\xa600CkExtract the reduced argument of packed single-precision \xe2\x80\xa600CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa600CkScale the packed half-precision (16-bit) floating-point \xe2\x80\xa600CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa600CjShuffle 16-bit integers in the high 64 bits of 128-bit \xe2\x80\xa600CiShuffle 16-bit integers in the low 64 bits of 128-bit \xe2\x80\xa600CnCompute the bitwise AND of packed 16-bit integers in a and \xe2\x80\xa600CnCompute the bitwise AND of packed 32-bit integers in a and \xe2\x80\xa600CnCompute the bitwise AND of packed 64-bit integers in a and \xe2\x80\xa600CnCompute the bitwise NAND of packed 8-bit integers in a and \xe2\x80\xa600CnBroadcast the low double-precision (64-bit) floating-point \xe2\x80\xa600CnBroadcast the low single-precision (32-bit) floating-point \xe2\x80\xa600CgMultiply packed complex numbers in a by the complex \xe2\x80\xa600CmContiguously store the active 16-bit integers in a (those \xe2\x80\xa600CmContiguously store the active 32-bit integers in a (those \xe2\x80\xa600CmContiguously store the active 64-bit integers in a (those \xe2\x80\xa600CmTest each 32-bit element of a for equality with all other \xe2\x80\xa600CmTest each 64-bit element of a for equality with all other \xe2\x80\xa600CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa600000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa600000ClSign extend packed 16-bit integers in a to packed 32-bit \xe2\x80\xa600ClSign extend packed 16-bit integers in a to packed 64-bit \xe2\x80\xa600ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa600ClSign extend packed 32-bit integers in a to packed 64-bit \xe2\x80\xa600ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa600ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa600CnZero extend packed unsigned 16-bit integers in a to packed \xe2\x80\xa600000CnZero extend packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa600CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa600CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa600CdLoad contiguous active double-precision (64-bit) \xe2\x80\xa600CdLoad contiguous active single-precision (32-bit) \xe2\x80\xa600ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa600CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa600ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa600222111000CmMultiply packed complex numbers in a and b, and store the \xe2\x80\xa600CkMultiply packed unsigned 52-bit integers in each 64-bit \xe2\x80\xa600000CkShuffle 64-bit integers in a within 256-bit lanes using \xe2\x80\xa600CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa600CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa600CiCalculate the max, min, absolute max, or absolute min \xe2\x80\xa600000ClUnpack and interleave 16-bit integers from the high half \xe2\x80\xa600ClUnpack and interleave 32-bit integers from the high half \xe2\x80\xa600ClUnpack and interleave 64-bit integers from the high half \xe2\x80\xa600CnUnpack and interleave 16-bit integers from the low half of \xe2\x80\xa600CnUnpack and interleave 32-bit integers from the low half of \xe2\x80\xa600CnUnpack and interleave 64-bit integers from the low half of \xe2\x80\xa600ClShuffle 8-bit integers in a and b across lanes using the \xe2\x80\xa600CmShuffle 16-bit integers in a and b across lanes using the \xe2\x80\xa600CmShuffle 32-bit integers in a and b across lanes using the \xe2\x80\xa600CmShuffle 64-bit integers in a and b across lanes using the \xe2\x80\xa600CiBitwise ternary logic that provides the capability to \xe2\x80\xa600000CiLoad contiguous active 16-bit integers from unaligned \xe2\x80\xa600CiLoad contiguous active 32-bit integers from unaligned \xe2\x80\xa600CiLoad contiguous active 64-bit integers from unaligned \xe2\x80\xa600CmFix up the lower double-precision (64-bit) floating-point \xe2\x80\xa600CmFix up the lower single-precision (32-bit) floating-point \xe2\x80\xa600999CgShuffle 16-bit integers in a across lanes using the \xe2\x80\xa600CjInitialize the buffersrc or abuffersrc filter with the \xe2\x80\xa6CeInitialize a native channel layout from a bitmask \xe2\x80\xa6Cl@return the AVColorTransferCharacteristic value for name \xe2\x80\xa6CaFind the programs which belong to a given stream.AlReturn audio frame duration.BgFree an AVHWFrameConstraints structure.ClCopy image data located in uncacheable (e.g. GPU mapped) \xe2\x80\xa6BfCompute the length of an integer list.CjGet a default list of allowed ranges for the given option.AnAudio output devices iterator.AnVideo output devices iterator.BcUnpack a dictionary from side_data.BeGet the duration for a Vorbis packet.CmThe default callback for AVCodecContext.get_buffer2(). It \xe2\x80\xa6mList devices.BoCreate a new filter instance in a filter graph.CiFree the provided AVFilterGraphSegment and everything \xe2\x80\xa6CcInitialize all filter instances in a graph segment.B`Link filters in a graph segment.BoSend a command to one or more filter instances.Cf@return the table mapping MOV FourCCs for audio to \xe2\x80\xa6Cf@return the table mapping MOV FourCCs for video to \xe2\x80\xa6DbGets the rightwards shifted bits in <code>self</code> from the \xe2\x80\xa60EgSets the given <code>value</code> into the bits from the <code>[start..=end]</code> \xe2\x80\xa60DhSimilar to <code>call_once_force</code>, but releases the Python GIL \xe2\x80\xa6DoReturns the ASCII representation as a <code>&amp;&#39;static str</code>, or \xe2\x80\xa6EfCounts <code>$a</code> as the high bytes and <code>$b</code> as the low bytes then \xe2\x80\xa60DgWorks like <code>combined_byte_shr_imm_m128i</code>, but twice as wide.0CfCreates a set of command writers and readers and a \xe2\x80\xa6CmNumber of configurable Address Ranges for filtering (Bits \xe2\x80\xa6EcConvert <code>i32</code> to <code>f64</code> and replace the low lane of the input.0EcConvert <code>i64</code> to <code>f64</code> and replace the low lane of the input.0DfConvert the lowest <code>f64</code> lane to a single <code>f64</code>.0DfConvert the lowest <code>i32</code> lane to a single <code>i32</code>.0BkCreates a texture from an existing surface.DgGets the <code>i8</code> lane requested. Only the lowest 4 bits are \xe2\x80\xa60CoFinds the index of the last 1 in <code>self</code> from the \xe2\x80\xa600000000000Do<strong>Gets</strong> the attribute: requests sRGB capable visual; defaults \xe2\x80\xa6EeReturns a string from an array of <code>bytes</code>, truncated to <code>n</code> \xe2\x80\xa6EaConvert a <code>Bytes</code> directly into a <code>HeaderValue</code> without \xe2\x80\xa6EhReturns a weekday from its index, from <code>Monday=0</code> to <code>Sunday=6</code>\xe2\x80\xa6EhReturns a weekday from its index, from <code>Sunday=0</code> to <code>Monday=6</code>\xe2\x80\xa6DkConverts a Vec&lt;u8&gt; to a <code>CString</code> without checking the \xe2\x80\xa6DhLike <code>get_item_unchecked</code>, but returns a borrowed object, \xe2\x80\xa60C`Returns how many channels are currently playing.ChInformations about processor topology (LEAF=0x8000_001E)AkGuest Physical Address BitsBjNB performance counter extensions support.BlHas Read-only effective frequency interface?DiThis macro tests, at runtime, whether an <code>aarch64</code> feature \xe2\x80\xa6CdLast-level cache reference event not available if 1.CbChecks if <code>powerpc</code> feature is enabled.BjReference cycles event not available if 1.BhMemory Bandwidth Allocation Information.EgComputes the modulo of <code>self + other</code> over <code>modulus</code>, and the \xe2\x80\xa6DgComputes the non-negative modulo of <code>self + other</code> over |\xe2\x80\xa610DgComputes the non-negative modulo of <code>self - other</code> over |\xe2\x80\xa6EgComputes the modulo of <code>self - other</code> over <code>modulus</code>, and the \xe2\x80\xa6EdSets the given <code>value</code> into the <code>[start..=end]</code> checked range.00CkReturns the number of unhandled stream errors discarded \xe2\x80\xa6CgConverts the current stack to a different capacity, \xe2\x80\xa6CmSets whether the track should stay alive while sounds are \xe2\x80\xa60CfPrepares the use of Python in a free-threaded context.DjCalls <code>sys.excepthook</code> and then prints a standard traceback \xe2\x80\xa6DhPrint a <code>Timestamp</code> datetime to the given writer with the \xe2\x80\xa6ClNumber of bits which should be loaded into the rc buffer \xe2\x80\xa6CiGets all processes and updates the specified information.E`Casts <code>self</code> to <code>isize_up</code> clamping at the numeric bounds.0EeCasts from <code>i128</code> to <code>isize_up</code> clamping at the numeric bounds.EcCasts from <code>i8</code> to <code>isize_up</code> clamping at the numeric bounds.EdCasts from <code>i32</code> to <code>isize_up</code> clamping at the numeric bounds.EbCasts from <code>usize</code> to <code>isize_up</code> clamping at the numeric \xe2\x80\xa6EdCasts from <code>u16</code> to <code>isize_up</code> clamping at the numeric bounds.EdCasts from <code>u64</code> to <code>isize_up</code> clamping at the numeric bounds.EdCasts from <code>u32</code> to <code>isize_up</code> clamping at the numeric bounds.EcCasts from <code>u8</code> to <code>isize_up</code> clamping at the numeric bounds.EeCasts from <code>u128</code> to <code>isize_up</code> clamping at the numeric bounds.EbCasts from <code>isize</code> to <code>isize_up</code> clamping at the numeric \xe2\x80\xa6EdCasts from <code>i16</code> to <code>isize_up</code> clamping at the numeric bounds.EdCasts from <code>i64</code> to <code>isize_up</code> clamping at the numeric bounds.E`Casts <code>self</code> to <code>usize_up</code> clamping at the numeric bounds.0EdCasts from <code>i32</code> to <code>usize_up</code> clamping at the numeric bounds.EbCasts from <code>isize</code> to <code>usize_up</code> clamping at the numeric \xe2\x80\xa6EeCasts from <code>i128</code> to <code>usize_up</code> clamping at the numeric bounds.EdCasts from <code>i16</code> to <code>usize_up</code> clamping at the numeric bounds.EdCasts from <code>u16</code> to <code>usize_up</code> clamping at the numeric bounds.EeCasts from <code>u128</code> to <code>usize_up</code> clamping at the numeric bounds.EdCasts from <code>u32</code> to <code>usize_up</code> clamping at the numeric bounds.EcCasts from <code>u8</code> to <code>usize_up</code> clamping at the numeric bounds.EcCasts from <code>i8</code> to <code>usize_up</code> clamping at the numeric bounds.EbCasts from <code>usize</code> to <code>usize_up</code> clamping at the numeric \xe2\x80\xa6EdCasts from <code>u64</code> to <code>usize_up</code> clamping at the numeric bounds.EdCasts from <code>i64</code> to <code>usize_up</code> clamping at the numeric bounds.ClSets how much the track\xe2\x80\x99s output should be panned left \xe2\x80\xa6EeSets the lowest <code>i16</code> lane of an <code>m128i</code> as all lanes of an \xe2\x80\xa60EeSets the lowest <code>i32</code> lane of an <code>m128i</code> as all lanes of an \xe2\x80\xa60EeSets the lowest <code>i64</code> lane of an <code>m128i</code> as all lanes of an \xe2\x80\xa60EfShuffle 128 bits of integer data from <code>$a</code> and <code>$b</code> using an \xe2\x80\xa60EaShuffle the high <code>i16</code> lanes in <code>$a</code> using an immediate \xe2\x80\xa60EhShuffle the low <code>i16</code> lanes in <code>$a</code> using an immediate control \xe2\x80\xa60BgStore data from a register into memory.000BeGet the alignment required for slicesDkFormat a <code>Timestamp</code> datetime into a string in a way that is \xe2\x80\xa6BmReturns the total number of outcoming errors.Chforces the use of wallclock timestamps as pts/dts of \xe2\x80\xa6BaLoads the default Vulkan library.DfCreates an empty <code>HashMap</code> with the specified capacity, \xe2\x80\xa6DhCreates an empty <code>HashSet</code> with the specified capacity, usingCmConverts an address back to a mutable pointer, picking up \xe2\x80\xa6000DhCreate a new <code>Bump</code> that enforces a minimum alignment and \xe2\x80\xa6EbCasts <code>self</code> to <code>isize_down</code> wrapping at the numeric bounds.0EbCasts from <code>u32</code> to <code>isize_down</code> wrapping at the numeric \xe2\x80\xa6EdCasts from <code>usize</code> to <code>isize_down</code> wrapping at the numeric \xe2\x80\xa6EeCasts from <code>i8</code> to <code>isize_down</code> wrapping at the numeric bounds.EbCasts from <code>u64</code> to <code>isize_down</code> wrapping at the numeric \xe2\x80\xa6EbCasts from <code>i16</code> to <code>isize_down</code> wrapping at the numeric \xe2\x80\xa6EcCasts from <code>i128</code> to <code>isize_down</code> wrapping at the numeric \xe2\x80\xa6EeCasts from <code>u8</code> to <code>isize_down</code> wrapping at the numeric bounds.EdCasts from <code>isize</code> to <code>isize_down</code> wrapping at the numeric \xe2\x80\xa6EbCasts from <code>i32</code> to <code>isize_down</code> wrapping at the numeric \xe2\x80\xa6EbCasts from <code>u16</code> to <code>isize_down</code> wrapping at the numeric \xe2\x80\xa6EcCasts from <code>u128</code> to <code>isize_down</code> wrapping at the numeric \xe2\x80\xa6EbCasts from <code>i64</code> to <code>isize_down</code> wrapping at the numeric \xe2\x80\xa6EbCasts <code>self</code> to <code>usize_down</code> wrapping at the numeric bounds.0EbCasts from <code>u32</code> to <code>usize_down</code> wrapping at the numeric \xe2\x80\xa6EbCasts from <code>i64</code> to <code>usize_down</code> wrapping at the numeric \xe2\x80\xa6EdCasts from <code>usize</code> to <code>usize_down</code> wrapping at the numeric \xe2\x80\xa6EbCasts from <code>i32</code> to <code>usize_down</code> wrapping at the numeric \xe2\x80\xa6EbCasts from <code>i16</code> to <code>usize_down</code> wrapping at the numeric \xe2\x80\xa6EeCasts from <code>u8</code> to <code>usize_down</code> wrapping at the numeric bounds.EeCasts from <code>i8</code> to <code>usize_down</code> wrapping at the numeric bounds.EbCasts from <code>u16</code> to <code>usize_down</code> wrapping at the numeric \xe2\x80\xa6EcCasts from <code>u128</code> to <code>usize_down</code> wrapping at the numeric \xe2\x80\xa6EdCasts from <code>isize</code> to <code>usize_down</code> wrapping at the numeric \xe2\x80\xa6EcCasts from <code>i128</code> to <code>usize_down</code> wrapping at the numeric \xe2\x80\xa6EbCasts from <code>u64</code> to <code>usize_down</code> wrapping at the numeric \xe2\x80\xa6BbSupport for AVX512 OPMASK in XCR0.CePreflight response indicating permitted HTTP headers.CiPreflight header response indicating permitted access \xe2\x80\xa6Cg&lt; Chromaticity-derived non-constant luminance systemCiA point in the output bytestream where the underlying \xe2\x80\xa6AhRepaint request message.jSee above.CdThe data is the AVMatrixEncoding enum defined in \xe2\x80\xa6CmMotion vectors exported by some codecs (on demand through \xe2\x80\xa6l&lt; unknownCmMPEGTS stream ID as uint8_t, this is required to pass the \xe2\x80\xa6ClA list of zero terminated key/value strings. There is no \xe2\x80\xa6CkHPKE suite: DHKEM(X25519, HKDF-SHA256), HKDF-SHA256 and \xe2\x80\xa6ChA force feedback effect has ran for its duration and \xe2\x80\xa60CiZero-sized type used to mark a lifetime as contravariant.00CmA command that enables the kitty keyboard protocol, which \xe2\x80\xa6DbRetrieve the seconds component of a <code>PyDateTime_Delta</code>.Bg&lt; The controller mapping was updatedBn&lt; Game controller touchpad finger was movedBjCreate a texture from an existing surface.Bm&lt; Display orientation has changed to data1ClAdd support for controllers that SDL is unaware of or to \xe2\x80\xa6CjGet the SDL joystick layer binding for this controller \xe2\x80\xa6ChQuery or change current state of Game Controller events.CfGet the USB product ID of an opened controller, if \xe2\x80\xa6BhSend a controller specific effect packetCgCheck whether the platform has screen keyboard support.CcGet the USB product ID of a joystick, if available.CeSet values on an opened, virtual-joystick\xe2\x80\x99s button.Ba&lt; Android video texture formatBlGet the platform dependent type of a sensor.BoCopy areas of the window surface to the screen.Be&lt; Window has gained keyboard focusCn&lt; The window size has changed, either as a result of an \xe2\x80\xa6Ca&lt; BT.601 for SD content, BT.709 for HD contentCkAn iterator over time zone transitions going forward in \xe2\x80\xa6ClAn iterator over time zone transitions going backward in \xe2\x80\xa6EhThis variant corresponds with <code>METH_FASTCALL</code> | <code>METH_KEYWORDS</code>\xe2\x80\xa6EfConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as \xe2\x80\xa600CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa600CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa600CiBroadcast the low packed 32-bit integer from a to all \xe2\x80\xa600CiBroadcast the low packed 64-bit integer from a to all \xe2\x80\xa600CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa600ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa600CkCompare packed 32-bit integers in a and b for equality, \xe2\x80\xa600CkCompare packed 64-bit integers in a and b for equality, \xe2\x80\xa600CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa600CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa600CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa600555ChCompare packed signed 32-bit integers in a and b for \xe2\x80\xa600ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa600444333222777111000444333222777111000444333222777111000444333222CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa600CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa600CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000ChLoad contiguous active 8-bit integers from unaligned \xe2\x80\xa600CnStores 8 32-bit integer elements from a to memory starting \xe2\x80\xa600CnStores 4 64-bit integer elements from a to memory starting \xe2\x80\xa600CnStores 4 32-bit integer elements from a to memory starting \xe2\x80\xa600111CfShuffle 8-bit integers in a across lanes using the \xe2\x80\xa600ClReduce the packed 16-bit integers in a by addition using \xe2\x80\xa600CiReduce the packed 16-bit integers in a by bitwise AND \xe2\x80\xa600CkReduce the packed 16-bit integers in a by maximum using \xe2\x80\xa600CnReduce the packed unsigned 16-bit integers in a by maximum \xe2\x80\xa600CkReduce the packed 16-bit integers in a by minimum using \xe2\x80\xa600CnReduce the packed unsigned 16-bit integers in a by minimum \xe2\x80\xa600ClReduce the packed 16-bit integers in a by multiplication \xe2\x80\xa600CkCompute the bitwise NAND of packed 16-bit integers in a \xe2\x80\xa600CkCompute the bitwise NAND of packed 32-bit integers in a \xe2\x80\xa600CkCompute the bitwise NAND of packed 64-bit integers in a \xe2\x80\xa600CkBroadcasts the lower 2 packed single-precision (32-bit) \xe2\x80\xa600CdBroadcast the 4 packed single-precision (32-bit) \xe2\x80\xa600CeBroadcasts the 2 packed double-precision (64-bit) \xe2\x80\xa600CkBroadcasts the lower 2 packed 32-bit integers from a to \xe2\x80\xa600ChBroadcast the 4 packed 32-bit integers from a to all \xe2\x80\xa600CiBroadcasts the 2 packed 64-bit integers from a to all \xe2\x80\xa600ChBroadcast the low packed 8-bit integer from a to all \xe2\x80\xa600ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600CkExtract 128 bits (composed of 4 packed single-precision \xe2\x80\xa600ClExtracts 128 bits (composed of 2 packed double-precision \xe2\x80\xa600CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa600CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa600CjShuffle 16-bit integers in the high 64 bits of 128-bit \xe2\x80\xa600CiShuffle 16-bit integers in the low 64 bits of 128-bit \xe2\x80\xa600CkLoads 8 32-bit integer elements from memory starting at \xe2\x80\xa600CkLoads 4 64-bit integer elements from memory starting at \xe2\x80\xa600CkLoads 4 32-bit integer elements from memory starting at \xe2\x80\xa600111CjFor each 64-bit element in b, select 8 unaligned bytes \xe2\x80\xa600EfConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as \xe2\x80\xa600888777CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa600ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa600CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa600ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa600222111000CiBroadcast the low packed 32-bit integer from a to all \xe2\x80\xa600CiBroadcast the low packed 64-bit integer from a to all \xe2\x80\xa600CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa600ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa600CkCompare packed 32-bit integers in a and b for equality, \xe2\x80\xa600CkCompare packed 64-bit integers in a and b for equality, \xe2\x80\xa600CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa600CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa600CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa600555ChCompare packed signed 32-bit integers in a and b for \xe2\x80\xa600ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa600444333222777111000444333222777111000444333222777111000444333222CgCompare packed signed 8-bit integers in a and b for \xe2\x80\xa600CiCompare packed unsigned 8-bit integers in a and b for \xe2\x80\xa600CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa600CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa600CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000ChLoad contiguous active 8-bit integers from unaligned \xe2\x80\xa600CgMultiply packed complex numbers in a by the complex \xe2\x80\xa600CfNormalize the mantissas of packed double-precision \xe2\x80\xa600CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa600CfNormalize the mantissas of packed single-precision \xe2\x80\xa600CkScatter 32-bit integers from a into memory using 32-bit \xe2\x80\xa600CkScatter 64-bit integers from a into memory using 32-bit \xe2\x80\xa600CkScatter 32-bit integers from a into memory using 64-bit \xe2\x80\xa600CkScatter 64-bit integers from a into memory using 64-bit \xe2\x80\xa600CgShuffle 32-bit integers in a across lanes using the \xe2\x80\xa600CfShuffle 8-bit integers in a across lanes using the \xe2\x80\xa600ClReduce the packed 32-bit integers in a by addition using \xe2\x80\xa600ClReduce the packed 64-bit integers in a by addition using \xe2\x80\xa600CiReduce the packed 32-bit integers in a by bitwise AND \xe2\x80\xa600111ClReduce the packed signed 32-bit integers in a by maximum \xe2\x80\xa600ClReduce the packed signed 64-bit integers in a by maximum \xe2\x80\xa600CnReduce the packed unsigned 32-bit integers in a by maximum \xe2\x80\xa600CnReduce the packed unsigned 64-bit integers in a by maximum \xe2\x80\xa600333222111222ClReduce the packed 32-bit integers in a by multiplication \xe2\x80\xa600ClReduce the packed 64-bit integers in a by multiplication \xe2\x80\xa600CkCompute the bitwise NAND of packed 16-bit integers in a \xe2\x80\xa600CkCompute the bitwise NAND of packed 32-bit integers in a \xe2\x80\xa600CkCompute the bitwise NAND of packed 64-bit integers in a \xe2\x80\xa600CkBroadcasts the lower 2 packed single-precision (32-bit) \xe2\x80\xa600CdBroadcast the 4 packed single-precision (32-bit) \xe2\x80\xa600CeBroadcasts the 8 packed single-precision (32-bit) \xe2\x80\xa600CeBroadcasts the 2 packed double-precision (64-bit) \xe2\x80\xa600CdBroadcast the 4 packed double-precision (64-bit) \xe2\x80\xa600CkBroadcasts the lower 2 packed 32-bit integers from a to \xe2\x80\xa600ChBroadcast the 4 packed 32-bit integers from a to all \xe2\x80\xa600CiBroadcasts the 8 packed 32-bit integers from a to all \xe2\x80\xa600CiBroadcasts the 2 packed 64-bit integers from a to all \xe2\x80\xa600ChBroadcast the 4 packed 64-bit integers from a to all \xe2\x80\xa600ChBroadcast the low packed 8-bit integer from a to all \xe2\x80\xa600ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa600CkExtract 128 bits (composed of 4 packed single-precision \xe2\x80\xa600ClExtracts 256 bits (composed of 8 packed single-precision \xe2\x80\xa600ClExtracts 128 bits (composed of 2 packed double-precision \xe2\x80\xa600CkExtract 256 bits (composed of 4 packed double-precision \xe2\x80\xa600CgMultiply packed complex numbers in a by the complex \xe2\x80\xa600CmMultiply packed complex numbers in a and b, accumulate to \xe2\x80\xa600ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa600CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa600ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa600222111000ChConvert the exponent of each packed double-precision \xe2\x80\xa600CfConvert the exponent of each packed half-precision \xe2\x80\xa600ChConvert the exponent of each packed single-precision \xe2\x80\xa600CmShuffle double-precision (64-bit) floating-point elements \xe2\x80\xa600CmShuffle single-precision (32-bit) floating-point elements \xe2\x80\xa600CkExtract the reduced argument of packed double-precision \xe2\x80\xa600CiExtract the reduced argument of packed half-precision \xe2\x80\xa600CkExtract the reduced argument of packed single-precision \xe2\x80\xa600CmScale the packed double-precision (64-bit) floating-point \xe2\x80\xa600CkScale the packed half-precision (16-bit) floating-point \xe2\x80\xa600CmScale the packed single-precision (32-bit) floating-point \xe2\x80\xa600CjShuffle 16-bit integers in the high 64 bits of 128-bit \xe2\x80\xa600CiShuffle 16-bit integers in the low 64 bits of 128-bit \xe2\x80\xa600CjFor each 64-bit element in b, select 8 unaligned bytes \xe2\x80\xa600CmShuffle 16-bit integers in a and b across lanes using the \xe2\x80\xa600CmShuffle 32-bit integers in a and b across lanes using the \xe2\x80\xa600CmShuffle 64-bit integers in a and b across lanes using the \xe2\x80\xa600ClContiguously store the active 8-bit integers in a (those \xe2\x80\xa600ClRound the lower double-precision (64-bit) floating-point \xe2\x80\xa600CjRound the lower half-precision (16-bit) floating-point \xe2\x80\xa600ClRound the lower single-precision (32-bit) floating-point \xe2\x80\xa600666555444CiBitwise ternary logic that provides the capability to \xe2\x80\xa600000BlSet the frame size for an audio buffer sink.BaAdd a frame to the buffer source.Cm@return the AVChromaLocation value for name or an AVError \xe2\x80\xa6Cm@return the AVColorPrimaries value for name or an AVError \xe2\x80\xa6B`This function is the same as \xe2\x80\xa6ClReturn a description of a channel layout. If nb_channels \xe2\x80\xa6ClReturn the number of bits per pixel for the pixel format \xe2\x80\xa6CkGuess the sample aspect ratio of a frame, based on both \xe2\x80\xa6CiAllocate a complete AVFrameSideData and add it to the \xe2\x80\xa6BnGet the internal codec timebase from a stream.AeFree a message queue.BaReceive a message from the queue.AlSend a message on the queue.ClCheck if the timecode feature is available for the given \xe2\x80\xa6C`Parse timecode representation (hh:mm:ss[:;.]ff).BlTest whether a muxer supports uncoded frame.CbFind a registered decoder with the specified name.CbFind a registered encoder with the specified name.CmReturn a value representing the fourCC code associated to \xe2\x80\xa6ClCreate and add a filter instance into an existing graph. \xe2\x80\xa6CaQueue a command for one or more filter instances.CnApply all filter/link descriptions from a graph segment to \xe2\x80\xa6CcParse a textual filtergraph description into an \xe2\x80\xa6Cg@return the table mapping RIFF FourCCs for audio to \xe2\x80\xa6Ch@defgroup riff_fourcc RIFF FourCCs @{ Get the tables \xe2\x80\xa6EdCounts the number of 1s in <code>bits</code> from the <code>[start..=end]</code> \xe2\x80\xa60DiConverts the Unicode scalar <code>code</code> to a UTF-8 encoded byte \xe2\x80\xa6CaCompile-time <code>lightness_to_luminance</code>.CaCompile-time <code>luminance_to_lightness</code>.DjWrites the unique prime factors in the given <code>fbuffer</code>, and \xe2\x80\xa60D`Finds the index of the first 1 in <code>self</code> from the \xe2\x80\xa600000000000CoFinds the index of the last 0 in <code>self</code> from the \xe2\x80\xa600000000000DhConverts bytes to an <code>OsString</code> without checking that the \xe2\x80\xa6CkConverts a slice of bytes to an OS string slice without \xe2\x80\xa6CiAdvanced Power Management Information (LEAF=0x8000_0007).BeDirect cache access info (LEAF=0x09).CcL2/L3 Cache and TLB Information (LEAF=0x8000_0006).BlProcessor Frequency Information (LEAF=0x16).CeIs Code and Data Prioritization Technology supported?BmSupport for L3 performance counter extension.CnReturn the instance ID of the controller with player index \xe2\x80\xa6ClReturn the instance ID of the joystick with player index \xe2\x80\xa6CjWrites the prime factors in the given <code>buffer</code>.00BlCalls `NumInt::int_ref_factors_prime_unique.00ChSimilar to int_factors_prime_unique, but operates on \xe2\x80\xa600EgConsumes the <code>Box</code>, returning a wrapped <code>NonNull</code> pointer and \xe2\x80\xa60BdCreate a new image from a byte sliceEeMultiply <code>i16</code> lanes producing <code>i32</code> values, horizontal add \xe2\x80\xa6000DkCreate a new <code>Packet</code> with trimming information from a boxed \xe2\x80\xa6CnThis is a panic called with a message that\xe2\x80\x99s a result of \xe2\x80\xa6000ClReturns a reference to the remaining bytes in the buffer \xe2\x80\xa6BmReceives data and ancillary data from socket.0DeSearch for <code>needle</code> in `haystack, with explicit string \xe2\x80\xa60DeSearch for <code>needle</code> in `haystack, with implicit string \xe2\x80\xa60BlSends data and ancillary data on the socket.0DkFilter using <code>ShiftRightAndMultByByte</code>: D = saturation255((S \xe2\x80\xa6CnNumber of bits to shift right on x2APIC ID to get a unique \xe2\x80\xa6EaShuffle the high <code>i16</code> lanes in <code>$a</code> using an immediate \xe2\x80\xa60EhShuffle the low <code>i16</code> lanes in <code>$a</code> using an immediate control \xe2\x80\xa60ChCreates a vector of pointers from a vector of addresses.00DfReturns an iterator over substrings of <code>self</code>, split on \xe2\x80\xa6DdLike <code>alloc_slice_fill_default</code> but does not panic on \xe2\x80\xa6EcDecodes a UTF-8 code point from <code>bytes</code>, starting at <code>index</code>.DkSame as <code>with_texture_canvas</code>, but allows to change multiple \xe2\x80\xa6DhChecks if the <code>Request</code> would be satisfied if provided with aCiIndicates which headers can be exposed as part of the \xe2\x80\xa6CjInforms the server know which HTTP method will be used \xe2\x80\xa6ClDetails about which channels are present in this layout. \xe2\x80\xa6CnColor Transfer Characteristic. These values match the ones \xe2\x80\xa6jSee above.B`Buffer fullness status messages.AiBuffer readable/writable.0CnDolby Vision RPU raw data, suitable for passing to x265 or \xe2\x80\xa6ClSubtitle event position @code u32le x1 u32le y1 u32le x2 \xe2\x80\xa6CcThe optional first identifier line of a WebVTT cue.Cm\xf0\x9f\x95\x98\xf0\x9f\x9a\xa9 <code>core</code> Error returned from converting \xe2\x80\xa60BlWhere the extended register state is stored.Ck203 Non-Authoritative Information [RFC9110, Section 15.3.4]Ck407 Proxy Authentication Required [RFC9110, Section 15.5.8]BoCreate a new thread with a specific stack size.Bm&lt; Display has been removed from the systemCjCheck if a controller has been opened and is currently \xe2\x80\xa6BkGet the Joystick ID from a Game Controller.BeGet the number of mappings installed.BjGet the battery level of a joystick as \xe2\x80\xa6ChConvert a GUID string into a SDL_JoystickGUID structure.CeGet the product version of an opened joystick, if \xe2\x80\xa6ChQuery whether a joystick has rumble support on triggers.B`Get the instance ID of a sensor.Ch\\brief A binarized alpha cutoff with a given integer \xe2\x80\xa6Cf451 Unavailable For Legal Reasons [RFC7725, Section 3]CkPerforms an affine transformation on the packed bytes in x.00ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa600ClCompare packed 32-bit integers in a and b for not-equal, \xe2\x80\xa600ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa600CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa600CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa600CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa600CkContiguously store the active double-precision (64-bit) \xe2\x80\xa600CkContiguously store the active single-precision (32-bit) \xe2\x80\xa600CiLoad contiguous active 16-bit integers from unaligned \xe2\x80\xa600CiLoad contiguous active 32-bit integers from unaligned \xe2\x80\xa600CiLoad contiguous active 64-bit integers from unaligned \xe2\x80\xa600ClShuffle 8-bit integers in a and b across lanes using the \xe2\x80\xa600CgShuffle 16-bit integers in a across lanes using the \xe2\x80\xa600CgShuffle 32-bit integers in a across lanes using the \xe2\x80\xa600CgShuffle 64-bit integers in a across lanes using the \xe2\x80\xa600CiBroadcast the low packed 32-bit integer from a to all \xe2\x80\xa600CiBroadcast the low packed 64-bit integer from a to all \xe2\x80\xa600CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa600CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000ChLoad contiguous active 8-bit integers from unaligned \xe2\x80\xa600CfShuffle 8-bit integers in a across lanes using the \xe2\x80\xa600CkPerforms an affine transformation on the packed bytes in x.00CgMultiply packed complex numbers in a by the complex \xe2\x80\xa600CkCompare packed double-precision (64-bit) floating-point \xe2\x80\xa600CiCompare packed half-precision (16-bit) floating-point \xe2\x80\xa600CkCompare packed single-precision (32-bit) floating-point \xe2\x80\xa600ChCompare packed signed 16-bit integers in a and b for \xe2\x80\xa600ClCompare packed 32-bit integers in a and b for not-equal, \xe2\x80\xa600ChCompare packed signed 64-bit integers in a and b for \xe2\x80\xa600CjCompare packed unsigned 16-bit integers in a and b for \xe2\x80\xa600CjCompare packed unsigned 32-bit integers in a and b for \xe2\x80\xa600CjCompare packed unsigned 64-bit integers in a and b for \xe2\x80\xa600CkContiguously store the active double-precision (64-bit) \xe2\x80\xa600CkContiguously store the active single-precision (32-bit) \xe2\x80\xa600ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa600ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600000ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600000000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000000CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa600000000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000000000000000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa600000000000CiLoad contiguous active 16-bit integers from unaligned \xe2\x80\xa600CiLoad contiguous active 32-bit integers from unaligned \xe2\x80\xa600CiLoad contiguous active 64-bit integers from unaligned \xe2\x80\xa600CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa600CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa600ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa600CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa600ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa600222111000CkLoads 8 64-bit integer elements from memory starting at \xe2\x80\xa600ClShuffle 8-bit integers in a and b across lanes using the \xe2\x80\xa600CgShuffle 16-bit integers in a across lanes using the \xe2\x80\xa600CgShuffle 32-bit integers in a across lanes using the \xe2\x80\xa600CgShuffle 64-bit integers in a across lanes using the \xe2\x80\xa600CiBroadcast the low packed 32-bit integer from a to all \xe2\x80\xa600CiBroadcast the low packed 64-bit integer from a to all \xe2\x80\xa600CiBroadcast the low packed 16-bit integer from a to all \xe2\x80\xa600CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000ChLoad contiguous active 8-bit integers from unaligned \xe2\x80\xa600CgMultiply packed complex numbers in a by the complex \xe2\x80\xa600CfNormalize the mantissas of packed double-precision \xe2\x80\xa600CmNormalize the mantissas of packed half-precision (16-bit) \xe2\x80\xa600CfNormalize the mantissas of packed single-precision \xe2\x80\xa600CfShuffle 8-bit integers in a across lanes using the \xe2\x80\xa600ClPerforms an affine transformation on the inverted packed \xe2\x80\xa600CmContiguously store the active 16-bit integers in a (those \xe2\x80\xa600CmContiguously store the active 32-bit integers in a (those \xe2\x80\xa600CmContiguously store the active 64-bit integers in a (those \xe2\x80\xa600CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa600CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa600CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa600ClRound the lower double-precision (64-bit) floating-point \xe2\x80\xa600CjRound the lower half-precision (16-bit) floating-point \xe2\x80\xa600ClRound the lower single-precision (32-bit) floating-point \xe2\x80\xa600CjGet a frame with filtered data from sink and put it in \xe2\x80\xa6ClAllocate a new AVBufferSrcParameters instance. It should \xe2\x80\xa6Bkbprint variant of av_channel_description().CcInitialize a channel layout from a given string \xe2\x80\xa6CgReturn default channel layout for a given number of \xe2\x80\xa6BbLook up an AVHWDeviceType by name.CnCreate and initialise an AVHWFramesContext as a mapping of \xe2\x80\xa6AmAllocate a new message queue.CgFill the codec context based on the values from the \xe2\x80\xa6BhRequest a frame on the oldest sink link.EdCounts the number of 0s in <code>bits</code> from the <code>[start..=end]</code> \xe2\x80\xa60jVideo only00DcReturn an iterator that iterates over the <code>k</code>-length \xe2\x80\xa6000EbCopies data in both directions between <code>a</code> and <code>b</code> using \xe2\x80\xa6DjWrites the prime factors in <code>pfbuf</code>, and the unique factors \xe2\x80\xa6DhWrites the prime factors in <code>pfbuf</code>, and the unique prime \xe2\x80\xa6D`Finds the index of the first 0 in <code>self</code> from the \xe2\x80\xa600000000000CfUnsafely creates a C string wrapper from a byte slice.C`Extended information about topology (LEAF=0x1F).CgComputes the Hamming edit distance between two UTF8 \xe2\x80\xa6CjHWP Package Level Request. IA32_HWP_REQUEST_PKG MSR is \xe2\x80\xa6CkIf true, Indicates support of output to Trace Transport \xe2\x80\xa6DbChecks if <code>loongarch</code> feature is enabled. Supported \xe2\x80\xa6CbChecks if <code>powerpc</code> feature is enabled.CnLoads the font at the given index of the SDL2 rwops object \xe2\x80\xa6CjMax number of idle pooled connections per host/port combo.0CnThis is a panic called with a message that\xe2\x80\x99s a result of \xe2\x80\xa6000BeNumber of incorrect PTS values so farBfCurrent statistics for PTS correction.BoFor depth-only render pass returns empty slice.000EbCasts <code>self</code> to <code>isize_down</code> clamping at the numeric bounds.0EcCasts from <code>i128</code> to <code>isize_down</code> clamping at the numeric \xe2\x80\xa6EbCasts from <code>u16</code> to <code>isize_down</code> clamping at the numeric \xe2\x80\xa6EcCasts from <code>u128</code> to <code>isize_down</code> clamping at the numeric \xe2\x80\xa6EbCasts from <code>i64</code> to <code>isize_down</code> clamping at the numeric \xe2\x80\xa6EbCasts from <code>i16</code> to <code>isize_down</code> clamping at the numeric \xe2\x80\xa6EbCasts from <code>i32</code> to <code>isize_down</code> clamping at the numeric \xe2\x80\xa6EeCasts from <code>i8</code> to <code>isize_down</code> clamping at the numeric bounds.EeCasts from <code>u8</code> to <code>isize_down</code> clamping at the numeric bounds.EdCasts from <code>isize</code> to <code>isize_down</code> clamping at the numeric \xe2\x80\xa6EbCasts from <code>u64</code> to <code>isize_down</code> clamping at the numeric \xe2\x80\xa6EbCasts from <code>u32</code> to <code>isize_down</code> clamping at the numeric \xe2\x80\xa6EdCasts from <code>usize</code> to <code>isize_down</code> clamping at the numeric \xe2\x80\xa6EbCasts <code>self</code> to <code>usize_down</code> clamping at the numeric bounds.0EdCasts from <code>usize</code> to <code>usize_down</code> clamping at the numeric \xe2\x80\xa6EbCasts from <code>u64</code> to <code>usize_down</code> clamping at the numeric \xe2\x80\xa6EeCasts from <code>i8</code> to <code>usize_down</code> clamping at the numeric bounds.EbCasts from <code>i32</code> to <code>usize_down</code> clamping at the numeric \xe2\x80\xa6EbCasts from <code>u32</code> to <code>usize_down</code> clamping at the numeric \xe2\x80\xa6EcCasts from <code>u128</code> to <code>usize_down</code> clamping at the numeric \xe2\x80\xa6EcCasts from <code>i128</code> to <code>usize_down</code> clamping at the numeric \xe2\x80\xa6EbCasts from <code>i64</code> to <code>usize_down</code> clamping at the numeric \xe2\x80\xa6EbCasts from <code>u16</code> to <code>usize_down</code> clamping at the numeric \xe2\x80\xa6EeCasts from <code>u8</code> to <code>usize_down</code> clamping at the numeric bounds.EbCasts from <code>i16</code> to <code>usize_down</code> clamping at the numeric \xe2\x80\xa6EdCasts from <code>isize</code> to <code>usize_down</code> clamping at the numeric \xe2\x80\xa6DeSearch for <code>needle</code> in `haystack, with explicit string \xe2\x80\xa60DeSearch for <code>needle</code> in `haystack, with implicit string \xe2\x80\xa60CmQueries the terminal\xe2\x80\x99s support for progressive keyboard \xe2\x80\xa6CmConvert an 8-bit paletted frame into a frame with a color \xe2\x80\xa60BdSupport for AVX512 ZMM Hi16 in XCR0.CnInforms the server which HTTP headers will be used when an \xe2\x80\xa6B`Buffer fullness status messages.CnBounding boxes for object detection and classification, as \xe2\x80\xa6CkHDR dynamic metadata associated with a video frame. The \xe2\x80\xa6CkUser data unregistered metadata associated with a video \xe2\x80\xa6CjEncoding parameters for a video frame, as described by \xe2\x80\xa6Ag&lt; coded as top fieldClThis side data should be associated with an audio stream \xe2\x80\xa6CnHDR10+ dynamic metadata associated with a video frame. The \xe2\x80\xa6Be&lt; negative time values are allowedChAllocate a new RGB surface with a specific pixel format.CfGet the implementation dependent name for the game \xe2\x80\xa6CfGet the implementation dependent path for the game \xe2\x80\xa6BbGet the type of a game controller.BbGet the default assertion handler.BlGet the original set of SDL memory functionsCfGet the firmware version of an opened joystick, if \xe2\x80\xa6CfGet the current state of an opened sensor with the \xe2\x80\xa6CaNegates results only before the end of the string00CbDo not negate results before the end of the string00ClShuffle 8-bit integers in a and b across lanes using the \xe2\x80\xa600CkExtract 128 bits (composed of 4 packed 32-bit integers) \xe2\x80\xa600ClExtracts 128 bits (composed of 2 packed 64-bit integers) \xe2\x80\xa600CmShuffle 16-bit integers in a and b across lanes using the \xe2\x80\xa600CmShuffle 32-bit integers in a and b across lanes using the \xe2\x80\xa600CmShuffle 64-bit integers in a and b across lanes using the \xe2\x80\xa600CiBitwise ternary logic that provides the capability to \xe2\x80\xa600000CiLoad contiguous active 16-bit integers from unaligned \xe2\x80\xa600CiLoad contiguous active 32-bit integers from unaligned \xe2\x80\xa600CiLoad contiguous active 64-bit integers from unaligned \xe2\x80\xa600999CgShuffle 16-bit integers in a across lanes using the \xe2\x80\xa600CgShuffle 32-bit integers in a across lanes using the \xe2\x80\xa600CgShuffle 64-bit integers in a across lanes using the \xe2\x80\xa600<<<ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa600CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa600111ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa600111222CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa600000000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000000000000000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa600000000000CkExtract 128 bits (composed of 4 packed 32-bit integers) \xe2\x80\xa600ClExtracts 256 bits (composed of 8 packed 32-bit integers) \xe2\x80\xa600ClExtracts 128 bits (composed of 2 packed 64-bit integers) \xe2\x80\xa600CkExtract 256 bits (composed of 4 packed 64-bit integers) \xe2\x80\xa600CnStores 8 64-bit integer elements from a to memory starting \xe2\x80\xa600CmShuffle 16-bit integers in a and b across lanes using the \xe2\x80\xa600CmShuffle 32-bit integers in a and b across lanes using the \xe2\x80\xa600CmShuffle 64-bit integers in a and b across lanes using the \xe2\x80\xa600CiBitwise ternary logic that provides the capability to \xe2\x80\xa600000ChConvert packed signed 16-bit integers in a to packed \xe2\x80\xa600ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600000ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600000000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000000CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa600000000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000000000000000CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa600000000000CiLoad contiguous active 16-bit integers from unaligned \xe2\x80\xa600CiLoad contiguous active 32-bit integers from unaligned \xe2\x80\xa600CiLoad contiguous active 64-bit integers from unaligned \xe2\x80\xa600CjFix up packed double-precision (64-bit) floating-point \xe2\x80\xa600CjFix up packed single-precision (32-bit) floating-point \xe2\x80\xa600ClMultiply packed double-precision (64-bit) floating-point \xe2\x80\xa600CjMultiply packed half-precision (16-bit) floating-point \xe2\x80\xa600ClMultiply packed single-precision (32-bit) floating-point \xe2\x80\xa600222111000ClShuffle 8-bit integers in a and b across lanes using the \xe2\x80\xa600CgShuffle 16-bit integers in a across lanes using the \xe2\x80\xa600CgShuffle 32-bit integers in a across lanes using the \xe2\x80\xa600CgShuffle 64-bit integers in a across lanes using the \xe2\x80\xa600EfConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as \xe2\x80\xa600ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa600ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa600ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa600CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa600CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa600CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa600CjFor each 64-bit element in b, select 8 unaligned bytes \xe2\x80\xa600DjA guard for <code>std::mem::uninitialized</code>. This will statically \xe2\x80\xa600CiConverts AVChromaLocation to swscale x/y chroma position.CiConverts swscale x/y chroma position to AVChromaLocation.ClReturn a channel layout and the number of channels based \xe2\x80\xa6CdGet the value and name of a standard channel layout.CnCreate a new device of the specified type from an existing \xe2\x80\xa6Cn@return codec descriptor with the given name or NULL if no \xe2\x80\xa6CeAllocate an AVFormatContext for an output format. \xe2\x80\xa6EgConverts the lower <code>f32</code> to <code>f64</code> and replace the low lane of \xe2\x80\xa60EfConverts the low <code>f64</code> to <code>f32</code> and replaces the low lane of \xe2\x80\xa60ClRounds the <code>f32</code> lanes to <code>i32</code> lanes.0ClConvert <code>f32</code> lanes to be <code>i32</code> lanes.0DfRounds the four <code>i32</code> lanes to four <code>f32</code> lanes.0ClConvert <code>i32</code> lanes to be <code>f32</code> lanes.0BaData access breakpoint extension.BdSupports local bandwidth monitoring.CiIf true, Indicates support of Single-Range Output scheme.BdSupports total bandwidth monitoring.CkSlowly inserts an <code>m128i</code> to <code>m256i</code>.0Dl<strong>Sets</strong> the attribute: OpenGL context sharing; defaults to \xe2\x80\xa6CeBitmap of supported MTC period encodings (Bit 31:16).DhChecks if the <code>Request</code> would be satisfied if provided with aBbSupport for AVX512 ZMM Hi256 XCR0.CnA point in the output bytestream where a demuxer can start \xe2\x80\xa6CmHDR Vivid dynamic metadata associated with a video frame. \xe2\x80\xa6CcFilm grain parameters for a frame, described by \xe2\x80\xa6CkContent light level (based on CTA-861.3). This metadata \xe2\x80\xa6ClViews are next to each other, but when upscaling apply a \xe2\x80\xa6Ch511 Network Authentication Required [RFC6585, Section 6]CfProcessor Capacity Parameters and Extended Feature \xe2\x80\xa6DkRetrieve the microsecond component of a <code>PyDateTime_DateTime</code>\xe2\x80\xa60CmRepresent all keyboard events as CSI-u sequences. This is \xe2\x80\xa6Ch431 Request Header Fields Too Large [RFC6585, Section 5]Ck&lt; src - dst : supported by D3D9, D3D11, OpenGL, OpenGLESCbGet the current state of a game controller sensor.CgGet the initial state of an axis control on a joystick.BbGet the instance ID of a joystick.Bl&lt; Window has been moved to display data1.Ck&lt; The ICC profile of the window\xe2\x80\x99s display has changed.BnGet The Manufacturer String from a HID device.CmThe audio uses an unsupported channel configuration. Only \xe2\x80\xa6CmShuffle 16-bit integers in a and b across lanes using the \xe2\x80\xa600CmShuffle 32-bit integers in a and b across lanes using the \xe2\x80\xa600CmShuffle 64-bit integers in a and b across lanes using the \xe2\x80\xa600ClContiguously store the active 8-bit integers in a (those \xe2\x80\xa600CkExtract 128 bits (composed of 4 packed 32-bit integers) \xe2\x80\xa600ClExtracts 128 bits (composed of 2 packed 64-bit integers) \xe2\x80\xa600555444333CiBitwise ternary logic that provides the capability to \xe2\x80\xa600000666555444333CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa600CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa600CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa600CkConvert packed single-precision (32-bit) floating-point \xe2\x80\xa600CkConvert packed double-precision (64-bit) floating-point \xe2\x80\xa600000000CiConvert packed half-precision (16-bit) floating-point \xe2\x80\xa600000000000000000222222222222888ClExtracts 256 bits (composed of 8 packed 32-bit integers) \xe2\x80\xa600888CkExtract 256 bits (composed of 4 packed 64-bit integers) \xe2\x80\xa600>>>===<<<888888ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600CkPerforms an affine transformation on the packed bytes in x.00CjFor each 64-bit element in b, select 8 unaligned bytes \xe2\x80\xa600CkAdd a new side data to a frame from an existing AVBufferRefCmGet a list of possible source or target formats usable in \xe2\x80\xa6CkGet the timecode string from the 25-bit timecode format \xe2\x80\xa6CiGet the AVClass for AVSubtitleRect. It can be used in \xe2\x80\xa6CkFill the parameters struct based on the values from the \xe2\x80\xa6ClEnable or disable automatic format conversion inside the \xe2\x80\xa6CkCheck if the stream st contained in s is matched by the \xe2\x80\xa6CoFinds the index of the last 1 in <code>bits</code> from the \xe2\x80\xa60ClCalculates the total byte size of an image buffer, given \xe2\x80\xa6DlRounds the two <code>f64</code> lanes to the low two <code>i32</code> lanes.0ClConvert <code>f64</code> lanes to be <code>i32</code> lanes.0ClConvert <code>i32</code> lanes to be <code>f64</code> lanes.0BnInfo about performance monitoring (LEAF=0x0A).CcSupports INVD execution prevention after BIOS Done.BeSupports Memory Bandwidth Allocation.CaLast-level cache misses event not available if 1.CfSends data and ancillary data on the socket to the \xe2\x80\xa6DdSets the given checked <code>value</code> into the bits from the \xe2\x80\xa600000000000EgGets a copy of <code>self</code> with the given checked <code>value</code> set into \xe2\x80\xa600Do<strong>Sets</strong> the attribute: requests sRGB capable visual; defaults \xe2\x80\xa6CfSkip duration calcuation in estimate_timings_from_pts.DiFormat a <code>Timestamp</code> datetime into a string with the given \xe2\x80\xa6DhCreate a new <code>Bump</code> that enforces a minimum alignment and \xe2\x80\xa6ChPreflight response indicating if the response to the \xe2\x80\xa6CeThe codec supports this format by some ad-hoc method.AjMute state change message.CmThis side data must be associated with an audio frame and \xe2\x80\xa6BjTransfer the data to the queried hw frame.CiThis side data is encryption initialization data. The \xe2\x80\xa6CjGet the SDL_GameController associated with an instance id.ClGet the SDL joystick layer binding for a controller axis \xe2\x80\xa6CbGet the player index of an opened game controller.ChGet the game controller mapping string for a given GUID.CjStart a rumble effect in the game controller\xe2\x80\x99s triggers.CbSet the player index of an opened game controller.CkGet the player index of a joystick, or -1 if it\xe2\x80\x99s not \xe2\x80\xa6ClMemory barriers are designed to prevent reads and writes \xe2\x80\xa6Ca&lt; The display is in portrait mode, upside downCcGet the Metal command encoder for the current frameCmGet the names of the Vulkan instance extensions needed to \xe2\x80\xa6BoGet The Serial Number String from a HID device.Bc&lt; Blackman Nuttall windowed sincClPerforms an affine transformation on the inverted packed \xe2\x80\xa600CmContiguously store the active 16-bit integers in a (those \xe2\x80\xa600CmContiguously store the active 32-bit integers in a (those \xe2\x80\xa600CmContiguously store the active 64-bit integers in a (those \xe2\x80\xa600CgConvert packed 16-bit integers in a to packed 8-bit \xe2\x80\xa600CgConvert packed 32-bit integers in a to packed 8-bit \xe2\x80\xa600CgConvert packed 64-bit integers in a to packed 8-bit \xe2\x80\xa600666555444333222111000CiRound packed double-precision (64-bit) floating-point \xe2\x80\xa600CgRound packed half-precision (16-bit) floating-point \xe2\x80\xa600CiRound packed single-precision (32-bit) floating-point \xe2\x80\xa600CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000CkPerforms an affine transformation on the packed bytes in x.00CnQuery the original opaque parameter of an allocated buffer \xe2\x80\xa6ClGet a frame\xe2\x80\x99s AV_FRAME_DATA_DOWNMIX_INFO side data for \xe2\x80\xa6BjIndicates with a boolean result if the \xe2\x80\xa6CbCheck if given option is set to its default value.CkUtility function to access log2_chroma_w log2_chroma_h fromCcReturn the current number of messages in the queue.CkInit a timecode struct from the passed timecode components.CgGet the timecode string from the SMPTE timecode format.CnCreate and return a AVHWFramesContext with values adequate \xe2\x80\xa6CaGet the index entry count for the given AVStream.D`Finds the index of the first 1 in <code>bits</code> from the \xe2\x80\xa60CoFinds the index of the last 0 in <code>bits</code> from the \xe2\x80\xa60CnReturns true if the current worker thread currently has \xe2\x80\x9c\xe2\x80\xa6EeGets the <code>f32</code> lane requested. Returns as an <code>i32</code> bit pattern.0DjAttempts to get mutable references to <code>N</code> values in the map \xe2\x80\xa6CmA hint that specifies whether a fullscreen Window will be \xe2\x80\xa6C`Calls `NumInt::int_ref_factors_prime_unique_buf.00ClSimilar to int_factors_prime_unique_buf, but operates on \xe2\x80\xa600CcBranch mispredict retired event not available if 1.CnThis is a panic called with a message that\xe2\x80\x99s a result of \xe2\x80\xa604CkReturns if, among the masked bits, there\xe2\x80\x99s both 0s and 1s0DeGets the pointer to the <code>vkGetInstanceProcAddr</code> Vulkan \xe2\x80\xa6CiExecutes the provided closure with an embedded Python \xe2\x80\xa6CbMaximum size (bytes, from the beginning of the \xe2\x80\xa6B`Do not check for format changes.CjContent light level (based on CTA-861.3). This payload \xe2\x80\xa6C`Regions Of Interest, the data is an array of \xe2\x80\xa6Aj&lt; coded as bottom fieldDbRetrieve the seconds component of a <code>PyDateTime_Delta</code>.CjGet the SDL_GameController associated with a player index.CaGet the number of touchpads on a game controller.CmQuery whether sensor data reporting is enabled for a game \xe2\x80\xa6BfGet the mapping at a particular index.Da&lt; The display is in landscape mode, with the left side up, \xe2\x80\xa6EfConsiders the input <code>b</code> as packed 64-bit integers and <code>c</code> as \xe2\x80\xa600ChConvert packed 32-bit integers in a to packed 16-bit \xe2\x80\xa600ChConvert packed 64-bit integers in a to packed 16-bit \xe2\x80\xa600ChConvert packed 64-bit integers in a to packed 32-bit \xe2\x80\xa600CnConvert packed signed 16-bit integers in a to packed 8-bit \xe2\x80\xa600CnConvert packed signed 32-bit integers in a to packed 8-bit \xe2\x80\xa600CnConvert packed signed 64-bit integers in a to packed 8-bit \xe2\x80\xa600CjFor each 64-bit element in b, select 8 unaligned bytes \xe2\x80\xa600777666555444333222111000Bobprint variant of av_channel_layout_describe().CkGet the channel with the given index in channel_layout. \xe2\x80\xa6ClThis function will cause global side data to be injected \xe2\x80\xa6ChReturn the number of channels in the channel layout. \xe2\x80\xa6CbAdjust frame number for NTSC drop frame time code.CgGet the timecode string from the SMPTE timecode format.AlThe default callback for \xe2\x80\xa6ClFind the best pixel format to convert to given a certain \xe2\x80\xa6CgApply parsed options to filter instances in a graph \xe2\x80\xa6D`Finds the index of the first 0 in <code>bits</code> from the \xe2\x80\xa60DlRounds the two <code>f64</code> lanes to the low two <code>f32</code> lanes.0ChBit width of fixed-function performance counters (if \xe2\x80\xa6BoInformations about performance optimization \xe2\x80\xa6CdBranch instruction retired event not available if 1.DgCreates a new <code>Disks</code> type with the disk list loaded and \xe2\x80\xa6CnThis is a panic called with a message that\xe2\x80\x99s a result of \xe2\x80\xa60BmReceives data and ancillary data from socket.ClBitmap of supported Configurable PSB frequency encodings \xe2\x80\xa6CgThe codec supports this format by some internal method.AmCreate window buffer message.AlVolume level change message.BlTransfer the data from the queried hw frame.CiAllocate a new RGB surface with with a specific pixel \xe2\x80\xa6CnGet the SDL joystick layer binding for a controller button \xe2\x80\xa6ChConvert from an SDL_GameControllerAxis enum to a string.CnSet whether data reporting for a game controller sensor is \xe2\x80\xa6BlGet the platform dependent type of a sensor.ChConvert packed signed 32-bit integers in a to packed \xe2\x80\xa600ChConvert packed signed 64-bit integers in a to packed \xe2\x80\xa600000CjConvert packed unsigned 16-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600CkPerforms an affine transformation on the packed bytes in x.00CjFor each 64-bit element in b, select 8 unaligned bytes \xe2\x80\xa600666555555444333222111000ClPerforms an affine transformation on the inverted packed \xe2\x80\xa600CjCalculates the number of bytes requested from the Rust \xe2\x80\xa6BoWrite an uncoded frame to an output media file.CfAllocate a data pointers array, samples buffer for \xe2\x80\xa6CjConvert <code>i8</code> values to <code>i16</code> values.0CjConvert <code>u8</code> values to <code>i16</code> values.0DkComputes eight <code>u16</code> \xe2\x80\x9csum of absolute difference\xe2\x80\x9d values \xe2\x80\xa6000CnThis is a panic called with a message that\xe2\x80\x99s a result of \xe2\x80\xa6000CbMaximum size (bytes, from the beginning of the \xe2\x80\xa6AnDestroy window buffer message.AnDisplay window buffer message.AnPrepare window buffer message.CjAllows experimenting with policies by monitoring their \xe2\x80\xa6ChExtended Processor and Processor Feature Identifiers \xe2\x80\xa6Bc&lt; 1-dstA, 1-dstA, 1-dstA, 1-dstABc&lt; 1-dstR, 1-dstG, 1-dstB, 1-dstABc&lt; 1-srcA, 1-srcA, 1-srcA, 1-srcABc&lt; 1-srcR, 1-srcG, 1-srcB, 1-srcACnLoad a set of Game Controller mappings from a seekable SDL \xe2\x80\xa6CbConvert a string into SDL_GameControllerAxis enum.CgGet the product version of an opened controller, if \xe2\x80\xa6CmGet the data rate (number of events per second) of a game \xe2\x80\xa6CmGet the current state of a finger on a touchpad on a game \xe2\x80\xa6CiQuery whether a game controller has rumble support on \xe2\x80\xa6CdGet the product version of a joystick, if available.ClSets the priority (not nice level) and scheduling policy \xe2\x80\xa6DcGet the address of the <code>vkGetInstanceProcAddr</code> function.CjConvert packed unsigned 32-bit integers in a to packed \xe2\x80\xa600CjConvert packed unsigned 64-bit integers in a to packed \xe2\x80\xa600000CkPerforms an affine transformation on the packed bytes in x.00222111111000ClPerforms an affine transformation on the inverted packed \xe2\x80\xa600DiAdd horizontal pairs of <code>i16</code> values, saturating, pack the \xe2\x80\xa60DhHorizontal saturating <code>a + b</code> with lanes as <code>i16</code>.0BbGet the number of failed requests.ClGet the index in a channel layout of a channel described \xe2\x80\xa6BmGet the index of a channel in channel_layout.CnCreate a new device of the specified type from an existing \xe2\x80\xa6CkGet the constraints on HW frames given a device and the \xe2\x80\xa6ChConvert frame number to SMPTE 12M binary representation.C`Send control message from application to device.C`Send control message from device to application.DdSets the given checked <code>value</code> into the bits from the \xe2\x80\xa60CkConvert <code>i16</code> values to <code>i32</code> values.0CkConvert <code>u16</code> values to <code>i32</code> values.0CkConvert <code>i32</code> values to <code>i64</code> values.0CkConvert <code>u32</code> values to <code>i64</code> values.0CfProcessor Capacity Parameters and Extended Feature \xe2\x80\xa6EaSets the given checked <code>value</code> into the <code>[start..=end]</code> \xe2\x80\xa600CnThis is a panic called with a message that\xe2\x80\x99s a result of \xe2\x80\xa60DjSubtract horizontal pairs of <code>i16</code> values, saturating, pack \xe2\x80\xa60DhHorizontal saturating <code>a - b</code> with lanes as <code>i16</code>.0Ck@param[in]  pix_fmt the pixel format @return a positive \xe2\x80\xa6DeEquivalent to the appropriate <code>llvm.memcpy.p0i8.0i8.*</code> \xe2\x80\xa600CeData found in BlockAdditional element of matroska \xe2\x80\xa6ChGet the firmware version of an opened controller, if \xe2\x80\xa6CjConvert from an SDL_GameControllerButton enum to a string.Ba&lt; buttons placed left to rightBa&lt; buttons placed right to leftBbGet the frame evaluation function.BbSet the frame evaluation function.CiGet the channel with the given index in a channel layout.ClGet the index of a given channel in a channel layout. In \xe2\x80\xa6AmSet the receiving error code.AkSet the sending error code.CgConvert a string into an SDL_GameControllerButton enum.CkGet the YUV conversion mode, returning the correct mode \xe2\x80\xa6ClPerforms an affine transformation on the inverted packed \xe2\x80\xa600000BlGet a channel described by the given string.CnSet the optional free message callback function which will \xe2\x80\xa6BlCreate filters specified in a graph segment.ClHWP Energy Performance Preference. IA32_HWP_REQUEST[bits \xe2\x80\xa6ClIgnoring Idle Logical Processor HWP request is supported \xe2\x80\xa6CnThis is a panic called with a message that\xe2\x80\x99s a result of \xe2\x80\xa60CjMastering display metadata (based on SMPTE-2086:2014). \xe2\x80\xa6777777DjRounds the lower two <code>i32</code> lanes to two <code>f64</code> lanes.022ChThe codec supports this format via the hw_device_ctx \xe2\x80\xa6ChThe codec supports this format via the hw_frames_ctx \xe2\x80\xa6Bm@deprecated those are not used by any decoderCiGet the number of supported simultaneous fingers on a \xe2\x80\xa6BeGet the mapping of a game controller.C`&lt; Marks the default button when escape is hitC`&lt; Marks the default button when return is hitCjGet the AVIndexEntry corresponding to the given timestamp.DiConvert <code>f32</code> lanes to <code>i32</code> lanes with truncation.0CgIf true, Indicates support of MTC timing packet and \xe2\x80\xa6CmMastering display metadata associated with a video frame. \xe2\x80\xa68ClYou tried to cast a reference into a reference to a type \xe2\x80\xa6DiConvert <code>f64</code> lanes to <code>i32</code> lanes with truncation.0AgThis is dumb and weird.000CjAmbient viewing environment metadata, as defined by H.274.C`Returns the method used to set ctx-&gt;duration.DnConvert the lower eight <code>i8</code> lanes to eight <code>i16</code> lanes.0DbConvert lower 4 <code>u8</code> values to <code>i16</code> values.0DbConvert lower 8 <code>u8</code> values to <code>i16</code> values.0DlConvert the lower four <code>i8</code> lanes to four <code>i32</code> lanes.0DfConvert the lower 8 <code>i8</code> values to <code>i32</code> values.0DjConvert the lower two <code>i8</code> lanes to two <code>i64</code> lanes.0DfConvert the lower 4 <code>i8</code> values to <code>i64</code> values.0DnConvert the lower eight <code>u8</code> lanes to eight <code>u16</code> lanes.0DlConvert the lower four <code>u8</code> lanes to four <code>u32</code> lanes.0DjConvert the lower two <code>u8</code> lanes to two <code>u64</code> lanes.0CmBitmap of supported Cycle Threshold value encodings (Bits \xe2\x80\xa6DkConvert the lower two <code>i64</code> lanes to two <code>i32</code> lanes.0DmConvert the lower four <code>i16</code> lanes to four <code>i32</code> lanes.0DkConvert the lower two <code>i32</code> lanes to two <code>i64</code> lanes.0CkConvert <code>i16</code> values to <code>i64</code> values.0CkConvert <code>u16</code> values to <code>i64</code> values.0DmConvert the lower four <code>u16</code> lanes to four <code>u32</code> lanes.0DkConvert the lower two <code>u16</code> lanes to two <code>u64</code> lanes.0DkConvert the lower two <code>u32</code> lanes to two <code>u64</code> lanes.0CcQuery deterministic address translation feature \xe2\x80\xa6CnGet the current state of a game controller sensor with the \xe2\x80\xa6CfIf true, Indicates support of Configurable PSB and \xe2\x80\xa6CnSupports ENCLS instruction leaves ETRACKC, ERDINFO, ELDBC, \xe2\x80\xa6CkTransfer internal timing information from one stream to \xe2\x80\xa6CgReturn the sfSymbolsName for a given axis on a game \xe2\x80\xa6ChExtended Processor and Processor Feature Identifiers \xe2\x80\xa6CmA hint that specifies whether a fullscreen Window will be \xe2\x80\xa6CiReturn the sfSymbolsName for a given button on a game \xe2\x80\xa6CdSupports ENCLV instruction leaves EINCVIRTCHILD, \xe2\x80\xa6")